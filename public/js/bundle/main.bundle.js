/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/public/js/bundle/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../../node_modules/can-assign/can-assign.js":
/*!**************************************************************!*\
  !*** C:/Projects/game/node_modules/can-assign/can-assign.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var namespace = __webpack_require__(/*! can-namespace */ \"../../../../node_modules/can-namespace/can-namespace.js\");\n\n/**\n * @module {function} can-assign can-assign\n * @parent can-js-utilities\n * @collection can-infrastructure\n * @signature `assign(target, source)`\n * @package ./package.json\n *\n * A simplified version of [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign), which only accepts a single source argument.\n *\n * ```js\n * var assign = require(\"can-assign\");\n *\n * var obj = {};\n *\n * assign(obj, {\n *   foo: \"bar\"\n * });\n *\n * console.log(obj.foo); // -> \"bar\"\n * ```\n *\n * @param {Object} target The destination object. This object's properties will be mutated based on the object provided as `source`.\n * @param {Object} source The source object whose own properties will be applied to `target`.\n *\n * @return {Object} Returns the `target` argument.\n */\n\nmodule.exports = namespace.assign = function (d, s) {\n\tfor (var prop in s) {\n\t\tvar desc = Object.getOwnPropertyDescriptor(d,prop);\n\t\tif(!desc || desc.writable !== false){\n\t\t\td[prop] = s[prop];\n\t\t}\n\t}\n\treturn d;\n};\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-assign/can-assign.js?");

/***/ }),

/***/ "../../../../node_modules/can-construct-super/can-construct-super.js":
/*!********************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-construct-super/can-construct-super.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* global require, module */\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../../../node_modules/can-reflect/can-reflect.js\");\nvar Construct = __webpack_require__(/*! can-construct */ \"../../../../node_modules/can-construct/can-construct.js\");\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n// tests if we can get super in .toString()\nvar isFunction = function(val) {\n\treturn typeof val === 'function';\n},\n\tfnTest = /xyz/.test(function () {\n\t\treturn this.xyz;\n\t}) ? /\\b_super\\b/ : /.*/,\n\tgetset = ['get', 'set'],\n\tgetSuper = function (base, name, fn) {\n\t\treturn function () {\n\t\t\tvar hasExistingValue = false;\n\t\t\tvar existingValue;\n\t\t\tvar prototype = getPrototypeOf(this);\n\t\t\tvar existingPrototypeValue = prototype._super;\n\n\t\t\t/* We must delete the instance's _super so the lookup\n\t\t\t\t\twill reach the prototype. */\n\t\t\tif (hasOwnProperty.call(this, '_super')) {\n\t\t\t\thasExistingValue = true;\n\t\t\t\texistingValue = this._super;\n\t\t\t\t/* NOTE: if the object is sealed this will not work.\n\t\t\t\t\t\tThe '_super' key cannot be used on the instance\n\t\t\t\t\t\tin that rare case. */\n\t\t\t\tdelete this._super;\n\t\t\t}\n\n\t\t\t/* Add a new ._super() method that is the same method\n\t\t\t\t\tbut on the super-class. It must be set on the prototype\n\t\t\t\t\tbecause the instance may be sealed. */\n\t\t\tprototype._super = base[name];\n\n\t\t\t// The method only need to be bound temporarily, so we\n\t\t\t// remove it when we're done executing\n\t\t\tvar ret = fn.apply(this, arguments);\n\t\t\tprototype._super = existingPrototypeValue;\n\t\t\tif (hasExistingValue) {\n\t\t\t\tthis._super = existingValue;\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t};\n\nConstruct._defineProperty = function(addTo, base, name, descriptor) {\n\tvar _super = Object.getOwnPropertyDescriptor(base, name);\n\tif(_super) {\n\t\tcanReflect.each(getset, function (method) {\n\t\t\tif(isFunction(_super[method]) && isFunction(descriptor[method])) {\n\t\t\t\tdescriptor[method] = getSuper(_super, method, descriptor[method]);\n\t\t\t} else if(!isFunction(descriptor[method])) {\n\t\t\t\tdescriptor[method] = _super[method];\n\t\t\t}\n\t\t});\n\t}\n\n\tObject.defineProperty(addTo, name, descriptor);\n};\n\nvar getPrototypeOf = Object.getPrototypeOf || function(obj){\n\treturn obj.__proto__; // jshint ignore:line\n};\n\nvar getPropertyDescriptor = Object.getPropertyDescriptor || function(subject, name) {\n\tif(name in subject) {\n\t\tvar pd = Object.getOwnPropertyDescriptor(subject, name);\n\t\tvar proto = getPrototypeOf(subject);\n\t\twhile (pd === undefined && proto !== null) {\n\t\t\tpd = Object.getOwnPropertyDescriptor(proto, name);\n\t\t\tproto = getPrototypeOf(proto);\n\t\t}\n\t\treturn pd;\n\t}\n};\n\n// overwrites a single property so it can still call super\nConstruct._overwrite = function (addTo, base, name, val) {\n\t// Check if we're overwriting an existing function\n\tvar baseDescriptor = getPropertyDescriptor(base, name);\n\tvar baseValue = baseDescriptor && baseDescriptor.value;\n\n\tObject.defineProperty(addTo, name, {\n\t\tvalue: isFunction(val) && isFunction(baseValue) && fnTest.test(val) ?\n\t\t\t\tgetSuper(base, name, val) : val,\n\t\tconfigurable: true,\n\t\tenumerable: true,\n\t\twritable: true\n\t});\n};\n\nmodule.exports = Construct;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-construct-super/can-construct-super.js?");

/***/ }),

/***/ "../../../../node_modules/can-construct/can-construct.js":
/*!********************************************************************!*\
  !*** C:/Projects/game/node_modules/can-construct/can-construct.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../../../node_modules/can-reflect/can-reflect.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../../../node_modules/can-log/dev/dev.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../../../node_modules/can-namespace/can-namespace.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../../../node_modules/can-symbol/can-symbol.js\");\n\nvar inSetupSymbol = canSymbol.for(\"can.initializing\");\n\n//!steal-remove-start\nif(true) {\n\tvar CanString = __webpack_require__(/*! can-string */ \"../../../../node_modules/can-string/can-string.js\");\n\tvar reservedWords = {\n\t\t\"abstract\": true,\n\t\t\"boolean\": true,\n\t\t\"break\": true,\n\t\t\"byte\": true,\n\t\t\"case\": true,\n\t\t\"catch\": true,\n\t\t\"char\": true,\n\t\t\"class\": true,\n\t\t\"const\": true,\n\t\t\"continue\": true,\n\t\t\"debugger\": true,\n\t\t\"default\": true,\n\t\t\"delete\": true,\n\t\t\"do\": true,\n\t\t\"double\": true,\n\t\t\"else\": true,\n\t\t\"enum\": true,\n\t\t\"export\": true,\n\t\t\"extends\": true,\n\t\t\"false\": true,\n\t\t\"final\": true,\n\t\t\"finally\": true,\n\t\t\"float\": true,\n\t\t\"for\": true,\n\t\t\"function\": true,\n\t\t\"goto\": true,\n\t\t\"if\": true,\n\t\t\"implements\": true,\n\t\t\"import\": true,\n\t\t\"in\": true,\n\t\t\"instanceof\": true,\n\t\t\"int\": true,\n\t\t\"interface\": true,\n\t\t\"let\": true,\n\t\t\"long\": true,\n\t\t\"native\": true,\n\t\t\"new\": true,\n\t\t\"null\": true,\n\t\t\"package\": true,\n\t\t\"private\": true,\n\t\t\"protected\": true,\n\t\t\"public\": true,\n\t\t\"return\": true,\n\t\t\"short\": true,\n\t\t\"static\": true,\n\t\t\"super\": true,\n\t\t\"switch\": true,\n\t\t\"synchronized\": true,\n\t\t\"this\": true,\n\t\t\"throw\": true,\n\t\t\"throws\": true,\n\t\t\"transient\": true,\n\t\t\"true\": true,\n\t\t\"try\": true,\n\t\t\"typeof\": true,\n\t\t\"var\": true,\n\t\t\"void\": true,\n\t\t\"volatile\": true,\n\t\t\"while\": true,\n\t\t\"with\": true\n\t};\n\tvar constructorNameRegex = /[^A-Z0-9_]/gi;\n}\n//!steal-remove-end\n\n// ## construct.js\n// `Construct`\n// _This is a modified version of\n// [John Resig's class](http://ejohn.org/blog/simple-javascript-inheritance/).\n// It provides class level inheritance and callbacks._\n// A private flag used to initialize a new class instance without\n// initializing it's bindings.\nvar initializing = 0;\n\n//!steal-remove-start\nif(true) {\n\tvar namedCtor = (function(cache){\n\t\treturn function(name, fn) {\n\t\t\treturn ((name in cache) ? cache[name] : cache[name] = new Function(\n\t\t\t\t\"__\", \"function \"+name+\"(){return __.apply(this,arguments)};return \"+name\n\t\t\t))( fn );\n\t\t};\n\t}({}));\n}\n//!steal-remove-end\n\n/**\n * @add can-construct\n */\nvar Construct = function () {\n\tif (arguments.length) {\n\t\treturn Construct.extend.apply(Construct, arguments);\n\t}\n};\n\nvar canGetDescriptor;\ntry {\n\tObject.getOwnPropertyDescriptor({});\n\tcanGetDescriptor = true;\n} catch(e) {\n\tcanGetDescriptor = false;\n}\n\nvar getDescriptor = function(newProps, name) {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(newProps, name);\n\t\tif(descriptor && (descriptor.get || descriptor.set)) {\n\t\t\treturn descriptor;\n\t\t}\n\t\treturn null;\n\t},\n\tinheritGetterSetter = function(newProps, oldProps, addTo) {\n\t\taddTo = addTo || newProps;\n\t\tvar descriptor;\n\n\t\tfor (var name in newProps) {\n\t\t\tif( (descriptor = getDescriptor(newProps, name)) ) {\n\t\t\t\tthis._defineProperty(addTo, oldProps, name, descriptor);\n\t\t\t} else {\n\t\t\t\tConstruct._overwrite(addTo, oldProps, name, newProps[name]);\n\t\t\t}\n\t\t}\n\t},\n\tsimpleInherit = function (newProps, oldProps, addTo) {\n\t\taddTo = addTo || newProps;\n\n\t\tfor (var name in newProps) {\n\t\t\tConstruct._overwrite(addTo, oldProps, name, newProps[name]);\n\t\t}\n\t},\n\tdefineNonEnumerable = function(obj, prop, value) {\n\t\tObject.defineProperty(obj, prop, {\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: value\n\t\t});\n\t};\n/**\n * @static\n */\ncanReflect.assignMap(Construct, {\n\t/**\n\t * @property {Boolean} can-construct.constructorExtends constructorExtends\n\t * @parent can-construct.static\n\t *\n\t * @description\n\t * Toggles the behavior of a constructor function called\n\t * without the `new` keyword to extend the constructor function or\n\t * create a new instance.\n\t *\n\t * ```js\n\t * var animal = Animal();\n\t * // vs\n\t * var animal = new Animal();\n\t * ```\n\t *\n\t * @body\n\t *\n\t * If `constructorExtends` is:\n\t *\n\t *  - `true` - the constructor extends\n\t *  - `false` - a new instance of the constructor is created\n\t *\n\t * This property defaults to false.\n\t *\n\t * Example of constructExtends as `true`:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   constructorExtends: true // the constructor extends\n\t * },{\n\t *   sayHi: function() {\n\t *     console.log(\"hai!\");\n\t *   }\n\t * });\n\t *\n\t * var Pony = Animal({\n\t *   gallop: function () {\n\t *      console.log(\"Galloping!!\");\n\t *   }\n\t * }); // Pony is now a constructor function extended from Animal\n\t *\n\t * var frank = new Animal(); // frank is a new instance of Animal\n\t *\n\t * var gertrude = new Pony(); // gertrude is a new instance of Pony\n\t * gertrude.sayHi(); // \"hai!\" - sayHi is \"inherited\" from Animal\n\t * gertrude.gallop(); // \"Galloping!!\" - gallop is unique to instances of Pony\n\t *```\n\t *\n\t * The default behavior is shown in the example below:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   constructorExtends: false // the constructor does NOT extend\n\t * },{\n\t *   sayHi: function() {\n\t *     console.log(\"hai!\");\n\t *   }\n\t * });\n\t *\n\t * var pony = Animal(); // pony is a new instance of Animal\n\t * var frank = new Animal(); // frank is a new instance of Animal\n\t *\n\t * pony.sayHi() // \"hai!\"\n\t * frank.sayHi() // \"hai!\"\n\t *```\n\t * By default to extend a constructor, you must use [can-construct.extend extend].\n\t */\n\tconstructorExtends: true,\n\t/**\n\t * @function can-construct.newInstance newInstance\n\t * @parent can-construct.static\n\t *\n\t * @description Returns an instance of `Construct`. This method\n\t * can be overridden to return a cached instance.\n\t *\n\t * @signature `Construct.newInstance([...args])`\n\t *\n\t * @param {*} [args] arguments that get passed to [can-construct::setup] and [can-construct::init]. Note\n\t * that if [can-construct::setup] returns an array, those arguments will be passed to [can-construct::init]\n\t * instead.\n\t * @return {class} instance of the class\n\t *\n\t * @body\n\t * Creates a new instance of the constructor function. This method is useful for creating new instances\n\t * with arbitrary parameters. Typically, however, you will simply want to call the constructor with the\n\t * __new__ operator.\n\t *\n\t * ## Example\n\t *\n\t * The following creates a `Person` Construct and overrides `newInstance` to cache all\n\t * instances of Person to prevent duplication. If the properties of a new Person match an existing one it\n\t * will return a reference to the previously created object, otherwise it returns a new object entirely.\n\t *\n\t * ```js\n\t * // define and create the Person constructor\n\t * var Person = Construct.extend({\n\t *   init : function(first, middle, last) {\n\t *     this.first = first;\n\t *     this.middle = middle;\n\t *     this.last = last;\n\t *   }\n\t * });\n\t *\n\t * // store a reference to the original newInstance function\n\t * var _newInstance = Person.newInstance;\n\t *\n\t * // override Person's newInstance function\n\t * Person.newInstance = function() {\n\t *   // if cache does not exist make it an new object\n\t *   this.__cache = this.__cache || {};\n\t *   // id is a stingified version of the passed arguments\n\t *   var id = JSON.stringify(arguments);\n\t *\n\t *   // look in the cache to see if the object already exists\n\t *   var cachedInst = this.__cache[id];\n\t *   if(cachedInst) {\n\t *     return cachedInst;\n\t *   }\n\t *\n\t *   //otherwise call the original newInstance function and return a new instance of Person.\n\t *   var newInst = _newInstance.apply(this, arguments);\n\t *   this.__cache[id] = newInst;\n\t *   return newInst;\n\t * };\n\t *\n\t * // create two instances with the same arguments\n\t * var justin = new Person('Justin', 'Barry', 'Meyer'),\n\t *\t\tbrian = new Person('Justin', 'Barry', 'Meyer');\n\t *\n\t * console.log(justin === brian); // true - both are references to the same instance\n\t * ```\n\t *\n\t */\n\tnewInstance: function () {\n\t\t// Get a raw instance object (`init` is not called).\n\t\tvar inst = this.instance(),\n\t\t\targs;\n\t\t// Call `setup` if there is a `setup`\n\t\tif (inst.setup) {\n\t\t\tObject.defineProperty(inst,\"__inSetup\",{\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: true,\n\t\t\t\twritable: true\n\t\t\t});\n\t\t\tObject.defineProperty(inst, inSetupSymbol, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: true,\n\t\t\t\twritable: true\n\t\t\t});\n\t\t\targs = inst.setup.apply(inst, arguments);\n\t\t\tif (args instanceof Construct.ReturnValue){\n\t\t\t\treturn args.value;\n\t\t\t}\n\t\t\tinst.__inSetup = false;\n\t\t\tinst[inSetupSymbol] = false;\n\t\t}\n\t\t// Call `init` if there is an `init`\n\t\t// If `setup` returned `args`, use those as the arguments\n\t\tif (inst.init) {\n\t\t\tinst.init.apply(inst, args || arguments);\n\t\t}\n\t\treturn inst;\n\t},\n\t// Overwrites an object with methods. Used in the `super` plugin.\n\t// `newProps` - New properties to add.\n\t// `oldProps` - Where the old properties might be (used with `super`).\n\t// `addTo` - What we are adding to.\n\t_inherit: canGetDescriptor ? inheritGetterSetter : simpleInherit,\n\n\t// Adds a `defineProperty` with the given name and descriptor\n\t// Will only ever be called if ES5 is supported\n\t_defineProperty: function(what, oldProps, propName, descriptor) {\n\t\tObject.defineProperty(what, propName, descriptor);\n\t},\n\n\t// used for overwriting a single property.\n\t// this should be used for patching other objects\n\t// the super plugin overwrites this\n\t_overwrite: function (what, oldProps, propName, val) {\n\t\tObject.defineProperty(what, propName, {value: val, configurable: true, enumerable: true, writable: true});\n\t},\n\t// Set `defaults` as the merger of the parent `defaults` and this\n\t// object's `defaults`. If you overwrite this method, make sure to\n\t// include option merging logic.\n\t/**\n\t * @function can-construct.setup setup\n\t * @parent can-construct.static\n\t *\n\t * @description Perform initialization logic for a constructor function.\n\t *\n\t * @signature `Construct.setup(base, fullName, staticProps, protoProps)`\n\t *\n\t * A static `setup` method provides inheritable setup functionality\n\t * for a Constructor function. The following example\n\t * creates a Group constructor function.  Any constructor\n\t * functions that inherit from Group will be added to\n\t * `Group.childGroups`.\n\t *\n\t * ```js\n\t * Group = Construct.extend({\n\t *   setup: function(Construct, fullName, staticProps, protoProps){\n\t *     this.childGroups = [];\n\t *     if(Construct !== Construct){\n\t *       this.childGroups.push(Construct)\n\t *     }\n\t *     Construct.setup.apply(this, arguments)\n\t *   }\n\t * },{})\n\t * var Flock = Group.extend(...)\n\t * Group.childGroups[0] //-> Flock\n\t * ```\n\t * @param {constructor} base The base constructor that is being inherited from.\n\t * @param {String} fullName The name of the new constructor.\n\t * @param {Object} staticProps The static properties of the new constructor.\n\t * @param {Object} protoProps The prototype properties of the new constructor.\n\t *\n\t * @body\n\t * The static `setup` method is called immediately after a constructor\n\t * function is created and\n\t * set to inherit from its base constructor. It is useful for setting up\n\t * additional inheritance work.\n\t * Do not confuse this with the prototype `[can-construct::setup]` method.\n\t *\n\t * ## Example\n\t *\n\t * This `Parent` class adds a reference to its base class to itself, and\n\t * so do all the classes that inherit from it.\n\t *\n\t * ```js\n\t * Parent = Construct.extend({\n\t *   setup : function(base, fullName, staticProps, protoProps){\n\t *     this.base = base;\n\t *\n\t *     // call base functionality\n\t *     Construct.setup.apply(this, arguments)\n\t *   }\n\t * },{});\n\t *\n\t * Parent.base; // Construct\n\t *\n\t * Child = Parent({});\n\t *\n\t * Child.base; // Parent\n\t * ```\n\t */\n\tsetup: function (base) {\n\t\tvar defaults = base.defaults ? canReflect.serialize(base.defaults) : {};\n\t\tthis.defaults = canReflect.assignDeepMap(defaults,this.defaults);\n\t},\n\t// Create's a new `class` instance without initializing by setting the\n\t// `initializing` flag.\n\tinstance: function () {\n\t\t// Prevents running `init`.\n\t\tinitializing = 1;\n\t\tvar inst = new this();\n\t\t// Allow running `init`.\n\t\tinitializing = 0;\n\t\treturn inst;\n\t},\n\t// Extends classes.\n\t/**\n\t * @function can-construct.extend extend\n\t * @parent can-construct.static\n\t *\n\t * @signature `Construct.extend([name,] [staticProperties,] instanceProperties)`\n\t *\n\t * Extends `Construct`, or constructor functions derived from `Construct`,\n\t * to create a new constructor function. Example:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   sayHi: function(){\n\t *     console.log(\"hi\")\n\t *   }\n\t * });\n\t *\n\t * var animal = new Animal()\n\t * animal.sayHi();\n\t * ```\n\t *\n\t * @param {String} [name] Adds a name to the constructor function so\n\t * it is nicely labeled in the developer tools. The following:\n\t *\n\t *     Construct.extend(\"ConstructorName\",{})\n\t *\n\t * returns a constructur function that will show up as `ConstructorName`\n\t * in the developer tools.\n\t * It also sets \"ConstructorName\" as [can-construct.shortName shortName].\n\t *\n\t * @param {Object} [staticProperties] Properties that are added the constructor\n\t * function directly. For example:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   findAll: function(){\n\t *     return can.ajax({url: \"/animals\"})\n\t *   }\n\t * },{}); // need to pass an empty instanceProperties object\n\t *\n\t * Animal.findAll().then(function(json){ ... })\n\t * ```\n\t *\n\t * The [can-construct.setup static setup] method can be used to\n\t * specify inheritable behavior when a Constructor function is created.\n\t *\n\t * @param {Object} instanceProperties Properties that belong to\n\t * instances made with the constructor. These properties are added to the\n\t * constructor's `prototype` object. Example:\n\t *\n\t *     var Animal = Construct.extend({\n\t *\t\t  findAll: function() {\n\t *\t\t\treturn can.ajax({url: \"/animals\"});\n\t *\t\t  }\n\t *     },{\n\t *       init: function(name) {\n\t *         this.name = name;\n\t *       },\n\t *       sayHi: function() {\n\t *         console.log(this.name,\" says hai!\");\n\t *       }\n\t *     })\n\t *     var pony = new Animal(\"Gertrude\");\n\t *     pony.sayHi(); // \"Gertrude says hai!\"\n\t *\n\t * The [can-construct::init init] and [can-construct::setup setup] properties\n\t * are used for initialization.\n\t *\n\t * @return {function} The constructor function.\n\t *\n\t * ```js\n\t *\tvar Animal = Construct.extend(...);\n\t *\tvar pony = new Animal(); // Animal is a constructor function\n\t * ```\n\t * @body\n\t * ## Inheritance\n\t * Creating \"subclasses\" with `Construct` is simple. All you need to do is call the base constructor\n\t * with the new function's static and instance properties. For example, we want our `Snake` to\n\t * be an `Animal`, but there are some differences:\n\t *\n\t *\n\t *     var Snake = Animal.extend({\n\t *         legs: 0\n\t *     }, {\n\t *         init: function() {\n\t *             Animal.prototype.init.call(this, 'ssssss');\n\t *         },\n\t *         slither: function() {\n\t *             console.log('slithering...');\n\t *         }\n\t *     });\n\t *\n\t *     var baslisk = new Snake();\n\t *     baslisk.speak();   // \"ssssss\"\n\t *     baslisk.slither(); // \"slithering...\"\n\t *     baslisk instanceof Snake;  // true\n\t *     baslisk instanceof Animal; // true\n\t *\n\t *\n\t * ## Static properties and inheritance\n\t *\n\t * If you pass all three arguments to Construct, the second one will be attached directy to the\n\t * constructor, allowing you to imitate static properties and functions. You can access these\n\t * properties through the `[can-construct::constructor this.constructor]` property.\n\t *\n\t * Static properties can get overridden through inheritance just like instance properties. In the example below,\n\t * we override both the legs static property as well as the the init function for each instance:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *     legs: 4\n\t * }, {\n\t *     init: function(sound) {\n\t *         this.sound = sound;\n\t *     },\n\t *     speak: function() {\n\t *         console.log(this.sound);\n\t *     }\n\t * });\n\t *\n\t * var Snake = Animal.extend({\n\t *     legs: 0\n\t * }, {\n\t *     init: function() {\n\t *         this.sound = 'ssssss';\n\t *     },\n\t *     slither: function() {\n\t *         console.log('slithering...');\n\t *     }\n\t * });\n\t *\n\t * Animal.legs; // 4\n\t * Snake.legs; // 0\n\t * var dog = new Animal('woof');\n\t * var blackMamba = new Snake();\n\t * dog.speak(); // 'woof'\n\t * blackMamba.speak(); // 'ssssss'\n\t * ```\n\t *\n\t * ## Alternative value for a new instance\n\t *\n\t * Sometimes you may want to return some custom value instead of a new object when creating an instance of your class.\n\t * For example, you want your class to act as a singleton, or check whether an item with the given id was already\n\t * created and return an existing one from your cache store (e.g. using [can-connect/constructor/store/store]).\n\t *\n\t * To achieve this you can return [can-construct.ReturnValue] from `setup` method of your class.\n\t *\n\t * Lets say you have `myStore` to cache all newly created instances. And if an item already exists you want to merge\n\t * the new data into the existing instance and return the updated instance.\n\t *\n\t * ```\n\t * var myStore = {};\n\t *\n\t * var Item = Construct.extend({\n\t *     setup: function(params){\n\t *         if (myStore[params.id]){\n\t *             var item = myStore[params.id];\n\t *\n\t *             // Merge new data to the existing instance:\n\t *             Object.assign(item, params);\n\t *\n\t *             // Return the updated item:\n\t *             return new Construct.ReturnValue( item );\n\t *         } else {\n\t *             // Save to cache store:\n\t *             myStore[this.id] = this;\n\t *\n\t *             return [params];\n\t *         }\n\t *     },\n\t *     init: function(params){\n\t *         Object.assign(this, params);\n\t *     }\n\t * });\n\t *\n\t * var item_1  = new Item( {id: 1, name: \"One\"} );\n\t * var item_1a = new Item( {id: 1, name: \"OnePlus\"} )\n\t * ```\n\t */\n\textend: function (name, staticProperties, instanceProperties) {\n\t\tvar shortName = name,\n\t\t\tklass = staticProperties,\n\t\t\tproto = instanceProperties;\n\n\t\t// Figure out what was passed and normalize it.\n\t\tif (typeof shortName !== 'string') {\n\t\t\tproto = klass;\n\t\t\tklass = shortName;\n\t\t\tshortName = null;\n\t\t}\n\t\tif (!proto) {\n\t\t\tproto = klass;\n\t\t\tklass = null;\n\t\t}\n\t\tproto = proto || {};\n\t\tvar _super_class = this,\n\t\t\t_super = this.prototype,\n\t\t\tConstructor, prototype;\n\t\t// Instantiate a base class (but only create the instance,\n\t\t// don't run the init constructor).\n\t\tprototype = this.instance();\n\t\t// Copy the properties over onto the new prototype.\n\t\tConstruct._inherit(proto, _super, prototype);\n\n\t\tif(shortName) {\n\n\t\t} else if(klass && klass.shortName) {\n\t\t\tshortName = klass.shortName;\n\t\t} else if(this.shortName) {\n\t\t\tshortName = this.shortName;\n\t\t}\n\t\t// We want constructor.name to be the same as shortName, within\n\t\t// the bounds of what the JS VM will allow (meaning no non-word characters).\n\t\t// new Function() is significantly faster than eval() here.\n\n\t\t// Strip semicolons\n\t\t//!steal-remove-start\n\t\t// wrapping this var will cause \"used out of scope.\" when linting\n\t\tvar constructorName = shortName ? shortName.replace(constructorNameRegex, '_') : 'Constructor';\n\t\tif(true) {\n\t\t\tif(reservedWords[constructorName]) {\n\t\t\t\tconstructorName = CanString.capitalize(constructorName);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\t// The dummy class constructor.\n\t\tfunction init() {\n\t\t\t/* jshint validthis: true */\n\t\t\t// All construction is actually done in the init method.\n\t\t\tif (!initializing) {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(true) {\n\t\t\t\t\tif(!this || (this.constructor !== Constructor) &&\n\t\t\t\t\t// We are being called without `new` or we are extending.\n\t\t\t\t\targuments.length && Constructor.constructorExtends) {\n\t\t\t\t\t\tdev.warn('can/construct/construct.js: extending a Construct without calling extend');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\treturn (!this || this.constructor !== Constructor) &&\n\t\t\t\t// We are being called without `new` or we are extending.\n\t\t\t\targuments.length && Constructor.constructorExtends ? Constructor.extend.apply(Constructor, arguments) :\n\t\t\t\t// We are being called with `new`.\n\t\t\t\tConstructor.newInstance.apply(Constructor, arguments);\n\t\t\t}\n\t\t}\n\t\tConstructor = typeof namedCtor === \"function\" ?\n\t\t\tnamedCtor( constructorName, init ) :\n\t\t\tfunction() { return init.apply(this, arguments); };\n\n\t\t// Copy old stuff onto class (can probably be merged w/ inherit)\n\t\tfor (var propName in _super_class) {\n\t\t\tif (_super_class.hasOwnProperty(propName)) {\n\t\t\t\tConstructor[propName] = _super_class[propName];\n\t\t\t}\n\t\t}\n\t\t// Copy new static properties on class.\n\t\tConstruct._inherit(klass, _super_class, Constructor);\n\n\t\t// Set things that shouldn't be overwritten.\n\t\tcanReflect.assignMap(Constructor, {\n\t\t\tconstructor: Constructor,\n\t\t\tprototype: prototype\n\t\t\t/**\n\t\t\t * @property {String} can-construct.shortName shortName\n\t\t\t * @parent can-construct.static\n\t\t\t *\n\t\t\t * If you pass a name when creating a Construct, the `shortName` property will be set to the\n\t\t\t * name.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * var MyConstructor = Construct.extend(\"MyConstructor\",{},{});\n\t\t\t * MyConstructor.shortName // \"MyConstructor\"\n\t\t\t * ```\n\t\t\t */\n\t\t});\n\n\t\tif (shortName !== undefined) {\n\t\t\tif (Object.getOwnPropertyDescriptor) {\n\t\t\t\tvar desc = Object.getOwnPropertyDescriptor(Constructor, 'name');\n\t\t\t\tif (!desc || desc.configurable) {\n\t\t\t\t\tObject.defineProperty(\n\t\t\t\t\t\tConstructor,\n\t\t\t\t\t\t'name',\n\t\t\t\t\t\t{ writable: true, value: shortName, configurable: true }\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tConstructor.shortName = shortName;\n\t\t}\n\t\t// Make sure our prototype looks nice.\n\t\tdefineNonEnumerable(Constructor.prototype, \"constructor\", Constructor);\n\t\t// Call the class `setup` and `init`\n\t\tvar t = [_super_class].concat(Array.prototype.slice.call(arguments)),\n\t\t\targs = Constructor.setup.apply(Constructor, t);\n\t\tif (Constructor.init) {\n\t\t\tConstructor.init.apply(Constructor, args || t);\n\t\t}\n\t\t/**\n\t\t * @prototype\n\t\t */\n\t\treturn Constructor; //\n\t\t/**\n\t\t * @property {Object} can-construct.prototype.constructor constructor\n\t\t * @parent can-construct.prototype\n\t\t *\n\t\t * A reference to the constructor function that created the instance. This allows you to access\n\t\t * the constructor's static properties from an instance.\n\t\t *\n\t\t * @body\n\t\t * ## Example\n\t\t *\n\t\t * This Construct has a static counter that counts how many instances have been created:\n\t\t *\n\t\t * ```js\n\t\t * var Counter = Construct.extend({\n\t\t *     count: 0\n\t\t * }, {\n\t\t *     init: function() {\n\t\t *         this.constructor.count++;\n\t\t *     }\n\t\t * });\n\t\t *\n\t\t * var childCounter = new Counter();\n\t\t * console.log(childCounter.constructor.count); // 1\n\t\t * console.log(Counter.count); // 1\n\t\t * ```\n\t\t */\n\t},\n\t/**\n\t * @function can-construct.ReturnValue ReturnValue\n\t * @parent can-construct.static\n\t *\n\t * Use to overwrite the return value of new Construct(...).\n\t *\n\t * @signature `new Construct.ReturnValue( value )`\n\t *\n\t *   This constructor function can be used for creating a return value of the `setup` method.\n\t *   [can-construct] will check if the return value is an instance of `Construct.ReturnValue`.\n\t *   If it is then its `value` will be used as the new instance.\n\t *\n\t *   @param {Object} value A value to be used for a new instance instead of a new object.\n\t *\n\t *   ```js\n\t *   var Student = function( name, school ){\n\t *       this.name = name;\n\t *       this.school = school;\n\t *   }\n\t *\n\t *   var Person = Construct.extend({\n\t *       setup: function( options ){\n\t *           if (options.school){\n\t *               return new Constructor.ReturnValue( new Student( options.name, options.school ) );\n\t *           } else {\n\t *               return [options];\n\t *           }\n\t *       }\n\t *   });\n\t *\n\t *   var myPerson = new Person( {name: \"Ilya\", school: \"PetrSU\"} );\n\t *\n\t *   myPerson instanceof Student // => true\n\t *   ```\n   */\n\tReturnValue: function(value){\n\t\tthis.value = value;\n\t}\n});\n/**\n * @function can-construct.prototype.setup setup\n * @parent can-construct.prototype\n *\n * @signature `construct.setup(...args)`\n *\n * A setup function for the instantiation of a constructor function.\n *\n * @param {*} args The arguments passed to the constructor.\n *\n * @return {Array|undefined|can-construct.ReturnValue} If an array is returned, the array's items are passed as\n * arguments to [can-construct::init init]. If a [can-construct.ReturnValue] instance is returned, the ReturnValue\n * instance's value will be returned as the result of calling new Construct(). The following example always makes\n * sure that init is called with a jQuery wrapped element:\n *\n * ```js\n * \tWidgetFactory = Construct.extend({\n * \t\t\tsetup: function(element){\n * \t\t\t\t\treturn [$(element)]\n * \t\t\t}\n * \t});\n *\n * \tMyWidget = WidgetFactory.extend({\n * \t\t\tinit: function($el){\n * \t\t\t\t\t$el.html(\"My Widget!!\")\n * \t\t\t}\n * \t});\n *  ```\n *\n * Otherwise, the arguments to the\n * constructor are passed to [can-construct::init] and the return value of `setup` is discarded.\n *\n * @body\n *\n * ## Deciding between `setup` and `init`\n *\n *\n * Usually, you should use [can-construct::init init] to do your constructor function's initialization.\n * You should, instead, use `setup` when:\n *\n *   - there is initialization code that you want to run before the inheriting constructor's\n *     `init` method is called.\n *   - there is initialization code that should run whether or not inheriting constructors\n *     call their base's `init` methods.\n *   - you want to modify the arguments that will get passed to `init`.\n *\n */\ndefineNonEnumerable(Construct.prototype, \"setup\", function () {});\n/**\n * @function can-construct.prototype.init init\n * @parent can-construct.prototype\n *\n * @description Called when a new instance of a Construct is created.\n *\n * @signature `construct.init(...args)`\n * @param {*} args the arguments passed to the constructor (or the items of the array returned from [can-construct::setup])\n *\n * @body\n * If a prototype `init` method is provided, `init` is called when a new Construct is created---\n * after [can-construct::setup]. The `init` method is where the bulk of your initialization code\n * should go. A common thing to do in `init` is save the arguments passed into the constructor.\n *\n * ## Examples\n *\n * First, we'll make a Person constructor that has a first and last name:\n *\n * ```js\n * var Person = Construct.extend({\n *     init: function(first, last) {\n *         this.first = first;\n *         this.last  = last;\n *     }\n * });\n *\n * var justin = new Person(\"Justin\", \"Meyer\");\n * justin.first; // \"Justin\"\n * justin.last; // \"Meyer\"\n * ```\n *\n * Then, we'll extend Person into Programmer, and add a favorite language:\n *\n * ```js\n * var Programmer = Person.extend({\n *     init: function(first, last, language) {\n *         // call base's init\n *         Person.prototype.init.apply(this, arguments);\n *\n *         // other initialization code\n *         this.language = language;\n *     },\n *     bio: function() {\n *         return \"Hi! I'm \" + this.first + \" \" + this.last +\n *             \" and I write \" + this.language + \".\";\n *     }\n * });\n *\n * var brian = new Programmer(\"Brian\", \"Moschel\", 'ECMAScript');\n * brian.bio(); // \"Hi! I'm Brian Moschel and I write ECMAScript.\";\n * ```\n *\n * ## Modified Arguments\n *\n * [can-construct::setup] is able to modify the arguments passed to `init`.\n * If you aren't receiving the arguments you passed to `new Construct(args)`,\n * check that they aren't being changed by `setup` along\n * the inheritance chain.\n */\ndefineNonEnumerable(Construct.prototype, \"init\", function () {});\n\nmodule.exports = namespace.Construct = Construct;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-construct/can-construct.js?");

/***/ }),

/***/ "../../../../node_modules/can-control/can-control.js":
/*!****************************************************************!*\
  !*** C:/Projects/game/node_modules/can-control/can-control.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// # can/control/control.js\n//\n// Create organized, memory-leak free, rapidly performing, stateful\n// controls with declarative eventing binding. Used when creating UI\n// controls with behaviors, bound to elements on the page.\n// ## helpers\n\nvar Construct = __webpack_require__(/*! can-construct */ \"../../../../node_modules/can-construct/can-construct.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../../../node_modules/can-namespace/can-namespace.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"../../../../node_modules/can-assign/can-assign.js\");\nvar observeReader = __webpack_require__(/*! can-stache-key */ \"../../../../node_modules/can-stache-key/can-stache-key.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../../../node_modules/can-reflect/can-reflect.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"../../../../node_modules/can-observation/can-observation.js\");\nvar canEvent = __webpack_require__(/*! can-event-queue/map/map */ \"../../../../node_modules/can-event-queue/map/map.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../../../node_modules/can-log/dev/dev.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../../../node_modules/can-queues/can-queues.js\");\n\nvar string = __webpack_require__(/*! can-string */ \"../../../../node_modules/can-string/can-string.js\");\nvar get = __webpack_require__(/*! can-key/get/get */ \"../../../../node_modules/can-key/get/get.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"../../../../node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../../../node_modules/can-symbol/can-symbol.js\");\n\nvar controlsSymbol = canSymbol.for(\"can.controls\");\n\n\nvar processors;\n\n\n// ### bind\n// this helper binds to one element and returns a function that unbinds from that element.\nvar bind = function (el, ev, callback, queue) {\n\n    canEvent.on.call(el, ev, callback, queue);\n\n\treturn function () {\n        canEvent.off.call(el, ev, callback, queue);\n\t};\n},\n\tslice = [].slice,\n\tparamReplacer = /\\{([^\\}]+)\\}/g,\n\n\t// ### delegate\n\t//\n\t// this helper binds to elements based on a selector and returns a\n\t// function that unbinds.\n\tdelegate = function (el, selector, ev, callback) {\n        canEvent.on.call(el, ev, selector, callback);\n\n\t\treturn function () {\n            canEvent.off.call(el, ev, selector, callback);\n\t\t};\n\t},\n\n\t// ### binder\n\t//\n\t// Calls bind or unbind depending if there is a selector.\n\tbinder = function (el, ev, callback, selector) {\n\t\treturn selector ?\n\t\t\tdelegate(el, selector.trim(), ev, callback) :\n\t\t\tbind(el, ev, callback);\n\t},\n\n\tbasicProcessor;\n\nvar Control = Construct.extend(\"Control\",\n\t// ## *static functions*\n\t/**\n\t * @static\n\t */\n\t{\n\t\t// ## can.Control.setup\n\t\t//\n\t\t// This function pre-processes which methods are event listeners and which are methods of\n\t\t// the control. It has a mechanism to allow controllers to inherit default values from super\n\t\t// classes, like `can.Construct`, and will cache functions that are action functions (see `_isAction`)\n\t\t// or functions with an underscored name.\n\t\tsetup: function () {\n\t\t\tConstruct.setup.apply(this, arguments);\n\n\t\t\tif (Control) {\n\t\t\t\tvar control = this,\n\t\t\t\t\tfuncName;\n\n\t\t\t\tcontrol.actions = {};\n\t\t\t\tfor (funcName in control.prototype) {\n\t\t\t\t\tif (control._isAction(funcName)) {\n\t\t\t\t\t\tcontrol.actions[funcName] = control._action(funcName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// ## can.Control._shifter\n\t\t//\n\t\t// Moves `this` to the first argument, wraps it with `jQuery` if it's\n\t\t// an element.\n\t\t_shifter: function (context, name) {\n\t\t\tvar method = typeof name === \"string\" ? context[name] : name;\n\n\t\t\tif (typeof method !== \"function\") {\n\t\t\t\tmethod = context[method];\n\t\t\t}\n            var Control = this;\n\t\t\tfunction controlMethod() {\n\t\t\t\tvar wrapped = Control.wrapElement(this);\n\t\t\t\tcontext.called = name;\n\t\t\t\treturn method.apply(context, [wrapped].concat(slice.call(arguments, 0)));\n\t\t\t}\n      //!steal-remove-start\n      if(true) {\n\t      Object.defineProperty(controlMethod, \"name\", {\n\t      \tvalue: canReflect.getName(this) + \"[\"+name+\"]\",\n\t      });\n\t     }\n      //!steal-remove-end\n      return controlMethod;\n\t\t},\n\n\t\t// ## can.Control._isAction\n\t\t//\n\t\t// Return `true` if `methodName` refers to an action. An action is a `methodName` value that\n\t\t// is not the constructor, and is either a function or string that refers to a function, or is\n\t\t// defined in `special`, `processors`. Detects whether `methodName` is also a valid method name.\n\t\t_isAction: function (methodName) {\n\t\t\tvar val = this.prototype[methodName],\n\t\t\t\ttype = typeof val;\n\n\t\t\treturn (methodName !== 'constructor') &&\n\t\t\t(type === \"function\" || (type === \"string\" && (typeof this.prototype[val] === \"function\") )) &&\n\t\t\t!! (Control.isSpecial(methodName) || processors[methodName] || /[^\\w]/.test(methodName));\n\t\t},\n\t\t// ## can.Control._action\n\t\t//\n\t\t// Takes a method name and the options passed to a control and tries to return the data\n\t\t// necessary to pass to a processor (something that binds things).\n\t\t//\n\t\t// For performance reasons, `_action` is called twice:\n\t\t// * It's called when the Control class is created. for templated method names (e.g., `{window} foo`), it returns null. For non-templated method names it returns the event binding data. That data is added to `this.actions`.\n\t\t// * It is called wehn a control instance is created, but only for templated actions.\n\t\t_action: function(methodName, options, controlInstance) {\n\t\t\tvar readyCompute,\n                unableToBind;\n\n\t\t\t// If we don't have options (a `control` instance), we'll run this later. If we have\n\t\t\t// options, run `can.sub` to replace the action template `{}` with values from the `options`\n\t\t\t// or `window`. If a `{}` template resolves to an object, `convertedName` will be an array.\n\t\t\t// In that case, the event name we want will be the last item in that array.\n\t\t\tparamReplacer.lastIndex = 0;\n\t\t\tif (options || !paramReplacer.test(methodName)) {\n                var controlActionData = function() {\n\t\t\t\t\tvar delegate;\n\n\t\t\t\t\t// Set the delegate target and get the name of the event we're listening to.\n\t\t\t\t\tvar name = methodName.replace(paramReplacer, function(matched, key) {\n\t\t\t\t\t\tvar value, parent;\n\n\t\t\t\t\t\t// If listening directly to a delegate target, set it\n\t\t\t\t\t\tif (this._isDelegate(options, key)) {\n\t\t\t\t\t\t\tdelegate = this._getDelegate(options, key);\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If key contains part of the lookup path, remove it.\n\t\t\t\t\t\t// This is needed for bindings like {viewModel.foo} in can-component's Control.\n\t\t\t\t\t\tkey = this._removeDelegateFromKey(key);\n\n\t\t\t\t\t\t// set the parent (where the key will be read from)\n\t\t\t\t\t\tparent = this._lookup(options)[0];\n\n\t\t\t\t\t\tvalue = observeReader.read(parent, observeReader.reads(key), {\n\t\t\t\t\t\t\t// if we find a compute, we should bind on that and not read it\n\t\t\t\t\t\t\treadCompute: false\n\t\t\t\t\t\t}).value;\n\n\t\t\t\t\t\t// If `value` is undefined try to get the value from the window.\n\t\t\t\t\t\tif (value === undefined && typeof window !== 'undefined') {\n\t\t\t\t\t\t\tvalue = get(window, key);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if the parent is not an observable and we don't have a value, show a warning\n\t\t\t\t\t\t// in this situation, it is not possible for the event handler to be triggered\n\t\t\t\t\t\tif (!parent || !(canReflect.isObservableLike(parent) && canReflect.isMapLike(parent)) && !value) {\n                            unableToBind = true;\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If `value` is a string we just return it, otherwise we set it as a delegate target.\n\t\t\t\t\t\tif (typeof value === \"string\") {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdelegate = value;\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}.bind(this));\n\n\t\t\t\t\t// removing spaces that get added when converting\n\t\t\t\t\t// `{element} click` -> ` click`\n\t\t\t\t\tname = name.trim();\n\n\t\t\t\t\t// Get the name of the `event` we're listening to.\n\t\t\t\t\tvar parts = name.split(/\\s+/g),\n\t\t\t\t\t\tevent = parts.pop();\n\n\t\t\t\t\t// Return everything needed to handle the event we're listening to.\n\t\t\t\t\treturn {\n\t\t\t\t\t\tprocessor: this.processors[event] || basicProcessor,\n\t\t\t\t\t\tparts: [name, parts.join(\" \"), event],\n\t\t\t\t\t\tdelegate: delegate || undefined\n\t\t\t\t\t};\n\t\t\t\t};\n\n        //!steal-remove-start\n        if(true) {\n\t\t    \tObject.defineProperty(controlActionData, \"name\", {\n\t\t      \tvalue: canReflect.getName(controlInstance || this.prototype) + \"[\"+methodName+\"].actionData\",\n\t\t      });\n\t      }\n        //!steal-remove-end\n\n\t\t\t\treadyCompute = new Observation(controlActionData, this);\n\n\n\t\t\t\tif (controlInstance) {\n\t\t\t\t\t// Create a handler function that we'll use to handle the `change` event on the `readyCompute`.\n\t\t\t\t\tvar handler = function(actionData) {\n\t\t\t\t\t\t// unbinds the old binding\n\t\t\t\t\t\tif(controlInstance._bindings.control[methodName]) {\n\t\t\t\t\t\t\tcontrolInstance._bindings.control[methodName](controlInstance.element);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// binds the new\n\t\t\t\t\t\tcontrolInstance._bindings.control[methodName] = actionData.processor(\n\t\t\t\t\t\t\tactionData.delegate || controlInstance.element,\n\t\t\t\t\t\t\tactionData.parts[2], actionData.parts[1], methodName, controlInstance);\n\t\t\t\t\t};\n\n          //!steal-remove-start\n          if(true) {\n          \tObject.defineProperty(handler, \"name\", {\n            \tvalue: canReflect.getName(controlInstance) + \"[\"+methodName+\"].handler\",\n            });\n          }\n\t\t\t\t\t//!steal-remove-end\n\n\n\t\t\t\t\tcanReflect.onValue(readyCompute, handler, \"mutate\");\n          //!steal-remove-start\n          if(true) {\n\t          if(unableToBind) {\n\t          \tdev.log('can-control: No property found for handling ' + methodName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\tcontrolInstance._bindings.readyComputes[methodName] = {\n\t\t\t\t\t\tcompute: readyCompute,\n\t\t\t\t\t\thandler: handler\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn readyCompute.get();\n\t\t\t}\n\t\t},\n\t\t// the lookup path - where templated keys will be looked up\n\t\t_lookup: function (options) {\n\t\t\treturn [options, window];\n\t\t},\n\t\t// strip strings that represent delegates from the key\n\t\t_removeDelegateFromKey: function (key) {\n\t\t\treturn key;\n\t\t},\n\t\t// return whether the key is a delegate\n\t\t_isDelegate: function(options, key) {\n\t\t\treturn key === 'element';\n\t\t},\n\t\t// return the delegate object for a given key\n\t\t_getDelegate: function(options, key) {\n\t\t\treturn undefined;\n\t\t},\n\t\t// ## can.Control.processors\n\t\t//\n\t\t// An object of `{eventName : function}` pairs that Control uses to\n\t\t// hook up events automatically.\n\t\tprocessors: {},\n\t\t// ## can.Control.defaults\n\t\t// A object of name-value pairs that act as default values for a control instance\n\t\tdefaults: {},\n        // should be used to overwrite to make nodeLists on this\n        convertElement: function(element) {\n            element = typeof element === \"string\" ?\n\t\t\t\t\t\t\tdocument.querySelector(element) : element;\n\n\t\t\t\t\t\treturn this.wrapElement(element);\n        },\n        wrapElement: function(el){\n            return el;\n        },\n        unwrapElement: function(el){\n            return el;\n        },\n        // should be overwritten to look in jquery special events\n        isSpecial: function(eventName){\n            return eventName === \"inserted\" || eventName === \"removed\";\n        }\n\t}, {\n\t\t// ## *prototype functions*\n\t\t/**\n\t\t * @prototype\n\t\t */\n\t\t// ## setup\n\t\t//\n\t\t// Setup is where most of the Control's magic happens. It performs several pre-initialization steps:\n\t\t// - Sets `this.element`\n\t\t// - Adds the Control's name to the element's className\n\t\t// - Saves the Control in `$.data`\n\t\t// - Merges Options\n\t\t// - Binds event handlers using `delegate`\n\t\t// The final step is to return pass the element and prepareed options, to be used in `init`.\n\t\tsetup: function (element, options) {\n\n\t\t\tvar cls = this.constructor,\n\t\t\t\tpluginname = cls.pluginName || cls.shortName,\n\t\t\t\tarr;\n\n\t\t\tif (!element) {\n\t\t\t\tthrow new Error('Creating an instance of a named control without passing an element');\n\t\t\t}\n\t\t\t// Retrieve the raw element, then set the plugin name as a class there.\n            this.element = cls.convertElement(element);\n\n\t\t\tif (pluginname && pluginname !== 'Control' && this.element.classList) {\n                this.element.classList.add(pluginname);\n\t\t\t}\n\n\t\t\t// Set up the 'controls' data on the element. If it does not exist, initialize\n\t\t\t// it to an empty array.\n\t\t\tarr = this.element[controlsSymbol];\n\t\t\tif (!arr) {\n\t\t\t\tarr = [];\n\t\t\t\tthis.element[controlsSymbol] = arr;\n\t\t\t}\n\t\t\tarr.push(this);\n\n\t\t\t// The `this.options` property is an Object that contains configuration data\n\t\t\t// passed to a control when it is created (`new can.Control(element, options)`)\n\t\t\t//\n\t\t\t// The `options` argument passed when creating the control is merged with `can.Control.defaults`\n\t\t\t// in [can.Control.prototype.setup setup].\n\t\t\t//\n\t\t\t// If no `options` value is used during creation, the value in `defaults` is used instead\n\t\t\tif (canReflect.isObservableLike(options) && canReflect.isMapLike(options)) {\n\t\t\t\tfor (var prop in cls.defaults) {\n\t\t\t\t\tif (!options.hasOwnProperty(prop)) {\n\t\t\t\t\t\tobserveReader.set(options, prop, cls.defaults[prop]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.options = options;\n\t\t\t} else {\n\t\t\t\tthis.options = assign( assign({}, cls.defaults), options);\n\t\t\t}\n\n\t\t\tthis.on();\n\n\t\t\treturn [this.element, this.options];\n\t\t},\n\t\t// ## on\n\t\t//\n\t\t// This binds an event handler for an event to a selector under the scope of `this.element`\n\t\t// If no options are specified, all events are rebound to their respective elements. The actions,\n\t\t// which were cached in `setup`, are used and all elements are bound using `delegate` from `this.element`.\n\t\ton: function (el, selector, eventName, func) {\n\t\t\tif (!el) {\n\t\t\t\tthis.off();\n\n\t\t\t\tvar cls = this.constructor,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tactions = cls.actions,\n\t\t\t\t\telement = this.constructor.unwrapElement(this.element),\n\t\t\t\t\tdestroyCB = Control._shifter(this, \"destroy\"),\n\t\t\t\t\tfuncName, ready;\n\n\t\t\t\tfor (funcName in actions) {\n\t\t\t\t\t// Only push if we have the action and no option is `undefined`\n\t\t\t\t\tif ( actions.hasOwnProperty(funcName) ) {\n\t\t\t\t\t\tready = actions[funcName] || cls._action(funcName, this.options, this);\n\t\t\t\t\t\tif( ready ) {\n\t\t\t\t\t\t\tbindings.control[funcName]  = ready.processor(ready.delegate || element,\n\t\t\t\t\t\t\t\tready.parts[2], ready.parts[1], funcName, this);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Set up the ability to `destroy` the control later.\n\t\t\t\tvar removalDisposal = domMutate.onNodeDisconnected(element, function () {\n\t\t\t\t\tvar doc = element.ownerDocument;\n\t\t\t\t\tvar ownerNode = doc.contains ? doc : doc.documentElement;\n\t\t\t\t\tif (!ownerNode || ownerNode.contains(element) === false) {\n\t\t\t\t\t\t// if the teardown is happening while the dom queue is flushing,\n\t\t\t\t\t\t// there may have been a rebinding of _action handlers queued\n\t\t\t\t\t\t// in the mutate queue already, so do the teardown later.\n\t\t\t\t\t\tif(queues.domQueue.isFlushing) {\n\t\t\t\t\t\t\tqueues.mutateQueue.enqueue(destroyCB);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdestroyCB();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbindings.user.push(function () {\n\t\t\t\t\tif (removalDisposal) {\n\t\t\t\t\t\tremovalDisposal();\n\t\t\t\t\t\tremovalDisposal = undefined;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn bindings.user.length;\n\t\t\t}\n\n\t\t\t// if `el` is a string, use that as `selector` and re-set it to this control's element...\n\t\t\tif (typeof el === 'string') {\n\t\t\t\tfunc = eventName;\n\t\t\t\teventName = selector;\n\t\t\t\tselector = el;\n\t\t\t\tel = this.element;\n\t\t\t}\n\n\t\t\t// ...otherwise, set `selector` to null\n\t\t\tif (func === undefined) {\n\t\t\t\tfunc = eventName;\n\t\t\t\teventName = selector;\n\t\t\t\tselector = null;\n\t\t\t}\n\n\t\t\tif (typeof func === 'string') {\n\t\t\t\tfunc = Control._shifter(this, func);\n\t\t\t}\n\n\t\t\tthis._bindings.user.push(binder(el, eventName, func, selector));\n\n\t\t\treturn this._bindings.user.length;\n\t\t},\n\t\t// ## off\n\t\t//\n\t\t// Unbinds all event handlers on the controller.\n\t\t// This should _only_ be called in combination with .on()\n\t\toff: function () {\n\t\t\tvar el = this.constructor.unwrapElement(this.element),\n\t\t\t\tbindings = this._bindings;\n\t\t\tif( bindings ) {\n\t\t\t\t(bindings.user || []).forEach(function (value) {\n\t\t\t\t\tvalue(el);\n\t\t\t\t});\n\t\t\t\tcanReflect.eachKey(bindings.control || {}, function (value) {\n\t\t\t\t\tvalue(el);\n\t\t\t\t});\n\t\t\t\tcanReflect.eachKey(bindings.readyComputes || {}, function(value) {\n\t\t\t\t\tcanReflect.offValue(value.compute, value.handler, \"mutate\");\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Adds bindings.\n\t\t\tthis._bindings = {user: [], control: {}, readyComputes: {}};\n\t\t},\n\t\t// ## destroy\n\t\t//\n\t\t// Prepares a `control` for garbage collection.\n\t\t// First checks if it has already been removed. Then, removes all the bindings, data, and\n\t\t// the element from the Control instance.\n\t\tdestroy: function () {\n\t\t\tif (this.element === null) {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(true) {\n\t\t\t\t\tdev.warn(\"can-control: Control already destroyed\");\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar Class = this.constructor,\n\t\t\t\tpluginName = Class.pluginName || (Class.shortName && string.underscore(Class.shortName)),\n\t\t\t\tcontrols;\n\n\t\t\tthis.off();\n\n\t\t\tif (pluginName && pluginName !== 'can_control' && this.element.classList) {\n                this.element.classList.remove(pluginName);\n\t\t\t}\n\n\t\t\tcontrols = this.element[controlsSymbol];\n\t\t\tif (controls) {\n\t\t\t\tcontrols.splice(controls.indexOf(this), 1);\n\t\t\t}\n\n\t\t\t//canEvent.dispatch.call(this, \"destroyed\");\n\n\t\t\tthis.element = null;\n\t\t}\n\t});\n\n// ## Processors\n//\n// Processors do the binding. This basic processor binds events. Each returns a function that unbinds\n// when called.\nprocessors = Control.processors;\nbasicProcessor = function (el, event, selector, methodName, control) {\n\treturn binder(el, event, Control._shifter(control, methodName), selector);\n};\n\n// Set common events to be processed as a `basicProcessor`\n[\"beforeremove\", \"change\", \"click\", \"contextmenu\", \"dblclick\", \"keydown\", \"keyup\",\n\t\"keypress\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\",\n\t\"mouseup\", \"reset\", \"resize\", \"scroll\", \"select\", \"submit\", \"focusin\",\n\t\"focusout\", \"mouseenter\", \"mouseleave\",\n\t\"touchstart\", \"touchmove\", \"touchcancel\", \"touchend\", \"touchleave\",\n\t\"inserted\",\"removed\",\n\t\"dragstart\", \"dragenter\", \"dragover\", \"dragleave\", \"drag\", \"drop\", \"dragend\"\n].forEach(function (v) {\n\tprocessors[v] = basicProcessor;\n});\n\nmodule.exports = namespace.Control = Control;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-control/can-control.js?");

/***/ }),

/***/ "../../../../node_modules/can-define-lazy-value/define-lazy-value.js":
/*!********************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-define-lazy-value/define-lazy-value.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module {function} can-define-lazy-value\n * @parent can-js-utilities\n * @collection can-infrastructure\n * @package ./package.json\n * @signature `defineLazyValue(obj, prop, fn, writable)`\n *\n * Use Object.defineProperty to define properties whose values will be created lazily when they are first read.\n *\n * ```js\n * var _id = 1;\n * function getId() {\n *     return _id++;\n * }\n *\n * function MyObj(name) {\n *     this.name = name;\n * }\n *\n * defineLazyValue(MyObj.prototype, 'id', getId);\n *\n * var obj1 = new MyObj('obj1');\n * var obj2 = new MyObj('obj2');\n *\n * console.log( obj2 ); // -> { name: \"obj2\" }\n * console.log( obj1 ); // -> { name: \"obj1\" }\n *\n * // the first `id` read will get id `1`\n * console( obj2.id ); // -> 1\n * console( obj1.id ); // -> 2\n *\n * console.log( obj2 ); // -> { name: \"obj2\", id: 1 }\n * console.log( obj1 ); // -> { name: \"obj1\", id: 2 }\n *\n * ```\n *\n * @param {Object} object The object to add the property to.\n * @param {String} prop   The name of the property.\n * @param {Function} fn   A function to get the value the property should be set to.\n * @param {boolean} writable   Whether the field should be writable (false by default).\n */\nmodule.exports = function defineLazyValue(obj, prop, initializer, writable) {\n\tObject.defineProperty(obj, prop, {\n\t\tconfigurable: true,\n\t\tget: function() {\n\t\t\t// make the property writable\n\t\t\tObject.defineProperty(this, prop, {\n\t\t\t\tvalue: undefined,\n\t\t\t\twritable: true\n\t\t\t});\n\n\t\t\t// get the value from the initializer function\n\t\t\tvar value = initializer.call(this, obj, prop);\n\n\t\t\t// redefine the property to the value property\n\t\t\t// and reset the writable flag\n\t\t\tObject.defineProperty(this, prop, {\n\t\t\t\tvalue: value,\n\t\t\t\twritable: !!writable\n\t\t\t});\n\n\t\t\t// return the value\n\t\t\treturn value;\n\t\t},\n\t\tset: function(value){\n\t\t\tObject.defineProperty(this, prop, {\n\t\t\t\tvalue: value,\n\t\t\t\twritable: !!writable\n\t\t\t});\n\n\t\t\treturn value;\n\t\t}\n\t});\n};\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-define-lazy-value/define-lazy-value.js?");

/***/ }),

/***/ "../../../../node_modules/can-dom-events/can-dom-events.js":
/*!**********************************************************************!*\
  !*** C:/Projects/game/node_modules/can-dom-events/can-dom-events.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../../../node_modules/can-namespace/can-namespace.js\");\nvar util = __webpack_require__(/*! ./helpers/util */ \"../../../../node_modules/can-dom-events/helpers/util.js\");\nvar makeEventRegistry = __webpack_require__(/*! ./helpers/make-event-registry */ \"../../../../node_modules/can-dom-events/helpers/make-event-registry.js\");\nvar makeDelegateEventTree = __webpack_require__(/*! ./helpers/-make-delegate-event-tree */ \"../../../../node_modules/can-dom-events/helpers/-make-delegate-event-tree.js\");\n\n\nvar domEvents = {\n\t_eventRegistry: makeEventRegistry(),\n\n\t/**\n\t* @function can-dom-events.addEvent addEvent\n\t* @parent can-dom-events.static\n\t*\n\t* Add a custom event to the global event registry.\n\t*\n\t* @signature `addEvent( event [, eventType ] )`\n\t*\n\t* ```js\n\t* var removeReturnEvent = domEvents.addEvent(enterEvent, \"return\");\n\t* ```\n\t*\n\t* @param {can-dom-events/EventDefinition} event The custom event definition.\n\t* @param {String} eventType The event type to associated with the custom event.\n\t* @return {function} The callback to remove the custom event from the registry.\n\t*/\n\taddEvent: function(event, eventType) {\n\t\treturn this._eventRegistry.add(event, eventType);\n\t},\n\n\t/**\n\t* @function can-dom-events.addEventListener addEventListener\n\t*\n\t* Add an event listener for eventType to the target.\n\t*\n\t* @signature `addEventListener( target, eventType, ...eventArgs )`\n\t* @parent can-dom-events.static\n\t* @param {DomEventTarget} target The object to which to add the listener.\n\t* @param {String} eventType The event type with which to register.\n\t* @param {*} eventArgs The arguments which configure the associated event's behavior. This is usually a\n\t* function event handler.\n\t*/\n\taddEventListener: function(target, eventType) {\n\t\tvar hasCustomEvent = domEvents._eventRegistry.has(eventType);\n\t\tif (hasCustomEvent) {\n\t\t\tvar event = domEvents._eventRegistry.get(eventType);\n\t\t\treturn event.addEventListener.apply(domEvents, arguments);\n\t\t}\n\n\t\tvar eventArgs = Array.prototype.slice.call(arguments, 1);\n\t\treturn target.addEventListener.apply(target, eventArgs);\n\t},\n\n\t/**\n\t* @function can-dom-events.removeEventListener removeEventListener\n\t*\n\t* Remove an event listener for eventType from the target.\n\t*\n\t* @signature `removeEventListener( target, eventType, ...eventArgs )`\n\t* @parent can-dom-events.static\n\t* @param {DomEventTarget} target The object from which to remove the listener.\n\t* @param {String} eventType The event type with which to unregister.\n\t* @param {*} eventArgs The arguments which configure the associated event's behavior. This is usually a\n\t* function event handler.\n\t*/\n\tremoveEventListener: function(target, eventType) {\n\t\tvar hasCustomEvent = domEvents._eventRegistry.has(eventType);\n\t\tif (hasCustomEvent) {\n\t\t\tvar event = domEvents._eventRegistry.get(eventType);\n\t\t\treturn event.removeEventListener.apply(domEvents, arguments);\n\t\t}\n\n\t\tvar eventArgs = Array.prototype.slice.call(arguments, 1);\n\t\treturn target.removeEventListener.apply(target, eventArgs);\n\t},\n\n\t/**\n\t* @function can-dom-events.addDelegateListener addDelegateListener\n\t*\n\t* Attach a handler for an event for all elements that match the selector,\n\t* now or in the future, based on a root element.\n\t*\n\t* @signature `addDelegateListener( target, eventType, selector, handler )`\n\t*\n\t* ```js\n\t* // Prevents all anchor elements from changing the page\n\t* domEvents.addDelegateListener(document.body,\"click\", \"a\", function(event){\n\t*   event.preventDefault();\n\t* })\n\t* ```\n\t* @parent can-dom-events.static\n\t* @param {DomEventTarget} root The html element to listen to events that match selector within.\n\t* @param {String} eventType The event name to listen to.\n\t* @param {String} selector A selector to filter the elements that trigger the event.\n\t* @param {function} handler A function to execute at the time the event is triggered.\n\t*/\n\taddDelegateListener: function(root, eventType, selector, handler) {\n\t\tdomEvents._eventTree.add([root, eventType, selector, handler]);\n\t},\n\t/**\n\t* @function can-dom-events.removeDelegateListener removeDelegateListener\n\t*\n\t* Remove a handler for an event for all elements that match the selector.\n\t*\n\t* @signature `removeDelegateListener( target, eventType, selector, handler )`\n\t*\n\t* ```js\n\t* // Prevents all anchor elements from changing the page\n\t* function handler(event) {\n\t*   event.preventDefault();\n\t* }\n\t* domEvents.addDelegateListener(document.body,\"click\", \"a\", handler);\n\t*\n\t* domEvents.removeDelegateListener(document.body,\"click\", \"a\", handler);\n\t* ```\n\t* @parent can-dom-events.static\n\t* @param {DomEventTarget} root The html element to listen to events that match selector within.\n\t* @param {String} eventType The event name to listen to.\n\t* @param {String} selector A selector to filter the elements that trigger the event.\n\t* @param {function} handler A function that was previously passed to `addDelegateListener`.\n\t*/\n\tremoveDelegateListener: function(target, eventType, selector, handler) {\n\t\tdomEvents._eventTree.delete([target, eventType, selector, handler]);\n\t},\n\n\t/**\n\t* @function can-dom-events.dispatch dispatch\n\t*\n\t* Create and dispatch a configured event on the target.\n\t*\n\t* @signature `dispatch( target, eventData [, bubbles ][, cancelable ] )`\n\t* @parent can-dom-events.static\n\t* @param {DomEventTarget} target The object on which to dispatch the event.\n\t* @param {Object | String} eventData The data to be assigned to the event. If it is a string, that will be the event type.\n\t* @param {Boolean} bubbles Whether the event should bubble; defaults to true.\n\t* @param {Boolean} cancelable Whether the event can be cancelled; defaults to false.\n\t* @return {Boolean} notCancelled Whether the event dispatched without being cancelled.\n\t*/\n\tdispatch: function(target, eventData, bubbles, cancelable) {\n\t\tvar event = util.createEvent(target, eventData, bubbles, cancelable);\n\t\tvar enableForDispatch = util.forceEnabledForDispatch(target, event);\n\t\tif(enableForDispatch) {\n\t\t\ttarget.disabled = false;\n\t\t}\n\n\t\tvar ret = target.dispatchEvent(event);\n\t\tif(enableForDispatch) {\n\t\t\ttarget.disabled = true;\n\t\t}\n\n\t\treturn ret;\n\t}\n};\n\ndomEvents._eventTree = makeDelegateEventTree(domEvents);\n\n\n\n\n\nmodule.exports = namespace.domEvents = domEvents;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-dom-events/can-dom-events.js?");

/***/ }),

/***/ "../../../../node_modules/can-dom-events/helpers/-make-delegate-event-tree.js":
/*!*****************************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-dom-events/helpers/-make-delegate-event-tree.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar KeyTree = __webpack_require__(/*! can-key-tree */ \"../../../../node_modules/can-key-tree/can-key-tree.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../../../node_modules/can-reflect/can-reflect.js\");\n\n// Some events do not bubble, so delegating them requires registering the handler in the\n// capturing phase.\n// http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html\nvar useCapture = function(eventType) {\n\treturn eventType === 'focus' || eventType === 'blur';\n};\n\nfunction makeDelegator (domEvents) {\n\tvar Delegator = function Delegator (parentKey){\n\t\tthis.element = parentKey; // HTMLElement\n\t\tthis.events = {}; // {[eventType: string]: Array<(event) -> void>}\n\t\tthis.delegated = {}; // {[eventType: string]: (event) -> void}\n\t};\n\n\tcanReflect.assignSymbols( Delegator.prototype, {\n\t\t\"can.setKeyValue\": function(eventType, handlersBySelector){\n\t\t\tvar handler = this.delegated[eventType] = function(ev){\n\t\t\t\tvar cur = ev.target;\n\t\t\t\tvar propagate = true;\n\t\t\t\tvar origStopPropagation = ev.stopPropagation;\n\t\t\t\tev.stopPropagation = function() {\n\t\t\t\t\torigStopPropagation.apply(this, arguments);\n\t\t\t\t\tpropagate = false;\n\t\t\t\t};\n\t\t\t\tvar origStopImmediatePropagation = ev.stopImmediatePropagation;\n\t\t\t\tev.stopImmediatePropagation = function() {\n\t\t\t\t\torigStopImmediatePropagation.apply(this, arguments);\n\t\t\t\t\tpropagate = false;\n\t\t\t\t};\n\t\t\t\tdo {\n\t\t\t\t\t// document does not implement `.matches` but documentElement does\n\t\t\t\t\tvar el = cur === document ? document.documentElement : cur;\n\t\t\t\t\tvar matches = el.matches || el.msMatchesSelector;\n\n\t\t\t\t\tcanReflect.each(handlersBySelector, function(handlers, selector){\n\t\t\t\t\t\t// Text and comment nodes may be included in mutation event targets\n\t\t\t\t\t\t//  but will never match selectors (and do not implement matches)\n\t\t\t\t\t\tif (matches && matches.call(el, selector)) {\n\t\t\t\t\t\t\thandlers.forEach(function(handler){\n\t\t\t\t\t\t\t\thandler.call(el, ev);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t// since `el` points to `documentElement` when `cur` === document,\n\t\t\t\t\t// we need to continue using `cur` as the loop pointer, otherwhise\n\t\t\t\t\t// it will never end as documentElement.parentNode === document\n\t\t\t\t\tcur = cur.parentNode;\n\t\t\t\t} while ((cur && cur !== ev.currentTarget) && propagate);\n\t\t\t};\n\t\t\tthis.events[eventType] = handlersBySelector;\n\t\t\tdomEvents.addEventListener(this.element, eventType, handler, useCapture(eventType));\n\t\t},\n\t\t\"can.getKeyValue\": function(eventType) {\n\t\t\treturn this.events[eventType];\n\t\t},\n\t\t\"can.deleteKeyValue\": function(eventType) {\n\t\t\tdomEvents.removeEventListener(this.element, eventType, this.delegated[eventType], useCapture(eventType));\n\t\t\tdelete this.delegated[eventType];\n\t\t\tdelete this.events[eventType];\n\t\t},\n\t\t\"can.getOwnEnumerableKeys\": function() {\n\t\t\treturn Object.keys(this.events);\n\t\t}\n\t});\n\n\treturn Delegator;\n}\n\nmodule.exports = function makeDelegateEventTree (domEvents) {\n\tvar Delegator = makeDelegator(domEvents);\n\treturn new KeyTree([Map, Delegator, Object, Array]);\n};\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-dom-events/helpers/-make-delegate-event-tree.js?");

/***/ }),

/***/ "../../../../node_modules/can-dom-events/helpers/make-event-registry.js":
/*!***********************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-dom-events/helpers/make-event-registry.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction EventRegistry () {\n\tthis._registry = {};\n}\n\n/**\n * @module can-dom-events/helpers/make-event-registry\n * @parent can-dom-events.helpers\n * @description Create an event registry.\n * @signature `makeEventRegistry()`\n *   @return {can-dom-events/EventRegistry}\n * @hide\n * \n * @body\n *\n * ```js\n * var makeEventRegistry = require('can-dom-events/helpers/make-event-registry');\n * var registry = makeEventRegistry();\n *\n * var radioChange = require('can-events-dom-radiochange');\n * var removeRadioChange = registry.add(radioChange);\n *\n * registry.has('radiochange'); // => true\n * registry.get('radiochange'); // => radioChange\n *\n * removeRadioChange();\n * ```\n */\nmodule.exports = function makeEventRegistry () {\n\treturn new EventRegistry();\n};\n\n/**\n * @function make-event-registry.has eventRegistry.has\n *\n * Check whether an event type has already been registered.\n *\n * @signature `eventRegistry.has( eventType )`\n * @parent can-dom-events/EventRegistry\n * @param {String} eventType The event type for which to check.\n * @return {Boolean} Whether the event type is registered.\n*/\nEventRegistry.prototype.has = function (eventType) {\n\treturn !!this._registry[eventType];\n};\n\n/**\n * @function make-event-registry.get eventRegistry.get\n *\n * Retrieve an event type which has already been registered.\n *\n * @signature `eventRegistry.get( eventType )`\n * @parent can-dom-events/EventRegistry\n * @param {String} eventType The event type for which to retrieve.\n * @return {EventDefinition} The registered event definition, or undefined if unregistered.\n*/\nEventRegistry.prototype.get = function (eventType) {\n\treturn this._registry[eventType];\n};\n\n/**\n * @function make-event-registry.add eventRegistry.add\n *\n * Add an event to the registry.\n *\n * @signature `eventRegistry.add( event [, eventType ] )`\n * @parent can-dom-events/EventRegistry\n * @param {EventDefinition} event The event definition to register.\n * @param {String} eventType The event type with which to register the event.\n * @return {function} The callback to remove the event from the registry.\n*/\nEventRegistry.prototype.add = function (event, eventType) {\n\tif (!event) {\n\t\tthrow new Error('An EventDefinition must be provided');\n\t}\n\tif (typeof event.addEventListener !== 'function') {\n\t\tthrow new TypeError('EventDefinition addEventListener must be a function');\n\t}\n\tif (typeof event.removeEventListener !== 'function') {\n\t\tthrow new TypeError('EventDefinition removeEventListener must be a function');\n\t}\n\n\teventType = eventType || event.defaultEventType;\n\tif (typeof eventType !== 'string') {\n\t\tthrow new TypeError('Event type must be a string, not ' + eventType);\n\t}\n\n\tif (this.has(eventType)) {\n\t\tthrow new Error('Event \"' + eventType + '\" is already registered');\n\t}\n\n\tthis._registry[eventType] = event;\n\tvar self = this;\n\treturn function remove () {\n\t\tself._registry[eventType] = undefined;\n\t};\n};\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-dom-events/helpers/make-event-registry.js?");

/***/ }),

/***/ "../../../../node_modules/can-dom-events/helpers/util.js":
/*!********************************************************************!*\
  !*** C:/Projects/game/node_modules/can-dom-events/helpers/util.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar getCurrentDocument = __webpack_require__(/*! can-globals/document/document */ \"../../../../node_modules/can-globals/document/document.js\");\nvar isBrowserWindow = __webpack_require__(/*! can-globals/is-browser-window/is-browser-window */ \"../../../../node_modules/can-globals/is-browser-window/is-browser-window.js\");\n\nfunction getTargetDocument (target) {\n\treturn target.ownerDocument || getCurrentDocument();\n}\n\nfunction createEvent (target, eventData, bubbles, cancelable) {\n\tvar doc = getTargetDocument(target);\n\tvar event = doc.createEvent('HTMLEvents');\n\tvar eventType;\n\tif (typeof eventData === 'string') {\n\t\teventType = eventData;\n\t} else {\n\t\teventType = eventData.type;\n\t\tfor (var prop in eventData) {\n\t\t\tif (event[prop] === undefined) {\n\t\t\t\tevent[prop] = eventData[prop];\n\t\t\t}\n\t\t}\n\t}\n\tif (bubbles === undefined) {\n\t\tbubbles = true;\n\t}\n\tevent.initEvent(eventType, bubbles, cancelable);\n\treturn event;\n}\n\n// We do not account for all EventTarget classes,\n// only EventTarget DOM nodes, fragments, and the window.\nfunction isDomEventTarget (obj) {\n\tif (!(obj && obj.nodeName)) {\n\t\treturn obj === window;\n\t}\n\tvar nodeType = obj.nodeType;\n\treturn (\n\t\tnodeType === 1 || // Node.ELEMENT_NODE\n\t\tnodeType === 9 || // Node.DOCUMENT_NODE\n\t\tnodeType === 11 // Node.DOCUMENT_FRAGMENT_NODE\n\t);\n}\n\nfunction addDomContext (context, args) {\n\tif (isDomEventTarget(context)) {\n\t\targs = Array.prototype.slice.call(args, 0);\n\t\targs.unshift(context);\n\t}\n\treturn args;\n}\n\nfunction removeDomContext (context, args) {\n\tif (!isDomEventTarget(context)) {\n\t\targs = Array.prototype.slice.call(args, 0);\n\t\tcontext = args.shift();\n\t}\n\treturn {\n\t\tcontext: context,\n\t\targs: args\n\t};\n}\n\nvar fixSyntheticEventsOnDisabled = false;\n// In FireFox, dispatching a synthetic event on a disabled element throws an error.\n// Other browsers, like IE 10 do not dispatch synthetic events on disabled elements at all.\n// This determines if we have to work around that when dispatching events.\n// https://bugzilla.mozilla.org/show_bug.cgi?id=329509\n(function() {\n\tif(!isBrowserWindow()) {\n\t\treturn;\n\t}\n\n\tvar testEventName = 'fix_synthetic_events_on_disabled_test';\n\tvar input = document.createElement(\"input\");\n\tinput.disabled = true;\n\tvar timer = setTimeout(function() {\n\t\tfixSyntheticEventsOnDisabled = true;\n\t}, 50);\n\tvar onTest = function onTest (){\n\t\tclearTimeout(timer);\n\t\tinput.removeEventListener(testEventName, onTest);\n\t};\n\tinput.addEventListener(testEventName, onTest);\n\ttry {\n\t\tvar event = document.create('HTMLEvents');\n\t\tevent.initEvent(testEventName, false);\n\t\tinput.dispatchEvent(event);\n\t} catch(e) {\n\t\tonTest();\n\t\tfixSyntheticEventsOnDisabled = true;\n\t}\n})();\n\nfunction isDispatchingOnDisabled(element, event) {\n\tvar eventType = event.type;\n\tvar isInsertedOrRemoved = eventType === 'inserted' || eventType === 'removed';\n\tvar isDisabled = !!element.disabled;\n\treturn isInsertedOrRemoved && isDisabled;\n}\n\nfunction forceEnabledForDispatch (element, event) {\n\treturn fixSyntheticEventsOnDisabled && isDispatchingOnDisabled(element, event);\n}\n\nmodule.exports = {\n\tcreateEvent: createEvent,\n\taddDomContext: addDomContext,\n\tremoveDomContext: removeDomContext,\n\tisDomEventTarget: isDomEventTarget,\n\tgetTargetDocument: getTargetDocument,\n\tforceEnabledForDispatch: forceEnabledForDispatch\n};\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-dom-events/helpers/util.js?");

/***/ }),

/***/ "../../../../node_modules/can-dom-mutate/-is-connected.js":
/*!*********************************************************************!*\
  !*** C:/Projects/game/node_modules/can-dom-mutate/-is-connected.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var globals = __webpack_require__(/*! can-globals */ \"../../../../node_modules/can-globals/can-globals.js\");\nvar util = __webpack_require__(/*! ./-util */ \"../../../../node_modules/can-dom-mutate/-util.js\");\nvar contains = util.contains;\nvar mutate = {};\nvar isConnected;\nfunction getIsConnectedFromNode(node) {\n\treturn node.isConnected;\n}\nfunction getIsConnectedFromDocument(node) {\n\tvar doc = node.ownerDocument;\n\t// if node *is* the document, ownerDocument is null\n\t// However, CanSimpleDom implements this incorrectly, and a document's ownerDocument is itself,\n\t//   so make both checks\n\treturn doc === null || doc === node || contains(doc, node);\n}\n\nfunction setIsConnected(doc) {\n\tif(doc) {\n\t\tvar node = doc.createTextNode(\"\");\n\t\tisConnected = 'isConnected' in node.constructor.prototype ?\n\t\t\tgetIsConnectedFromNode :\n\t\t\tgetIsConnectedFromDocument;\n\t\tif(mutate) {\n\t\t\tmutate.isConnected = isConnected;\n\t\t}\n\t} else {\n\t\tmutate.isConnected = getIsConnectedFromNode;\n\t}\n}\nsetIsConnected(globals.getKeyValue(\"document\"));\nglobals.onKeyValue(\"document\", setIsConnected);\n\nmodule.exports = mutate;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-dom-mutate/-is-connected.js?");

/***/ }),

/***/ "../../../../node_modules/can-dom-mutate/-util.js":
/*!*************************************************************!*\
  !*** C:/Projects/game/node_modules/can-dom-mutate/-util.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"../../../../node_modules/can-globals/document/document.js\");\n\nfunction eliminate(array, item) {\n\tvar index = array.indexOf(item);\n\tif (index >= 0) {\n\t\tarray.splice(index, 1);\n\t}\n}\nfunction wasNotInSet(item, set) {\n\tvar inSet = set.has(item);\n\tif(inSet === false) {\n\t\tset.add(item);\n\t}\n\treturn !inSet;\n}\n\n\nfunction contains(parent, child){\n\tif(child && child.nodeType === Node.TEXT_NODE) {\n\t\treturn contains(parent, child.parentNode);\n\t}\n\tif(parent.contains) {\n\t\treturn parent.contains(child);\n\t}\n\tif(parent.nodeType === Node.DOCUMENT_NODE && parent.documentElement) {\n\t\treturn contains(parent.documentElement, child);\n\t} else {\n\t\tchild = child.parentNode;\n\t\tif(child === parent) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nfunction isDocumentElement (node) {\n\treturn getDocument().documentElement === node;\n}\n\nfunction isFragment (node) {\n\treturn !!(node && node.nodeType === 11);\n}\n\nfunction isElementNode (node) {\n\treturn !!(node && node.nodeType === 1);\n}\n\nfunction getChildren (parentNode) {\n\tvar nodes = [];\n\tvar node = parentNode.firstChild;\n\twhile (node) {\n\t\tnodes.push(node);\n\t\tnode = node.nextSibling;\n\t}\n\treturn nodes;\n}\n\nfunction getParents (node) {\n\tvar nodes;\n\tif (isFragment(node)) {\n\t\tnodes = getChildren(node);\n\t} else {\n\t\tnodes = [node];\n\t}\n\treturn nodes;\n}\n\n\nfunction getNodesLegacyB(node) {\n\tvar skip, tmp;\n\n\tvar depth = 0;\n\n\tvar items = isFragment(node) ? [] : [node];\n\tif(node.firstChild == null) {\n\t\treturn items;\n\t}\n\n\t// Always start with the initial element.\n\tdo {\n\t\tif ( !skip && (tmp = node.firstChild) ) {\n\t\t\tdepth++;\n\t\t\titems.push(tmp);\n\t\t} else if ( tmp = node.nextSibling ) {\n\t\t\tskip = false;\n\t\t\titems.push(tmp);\n\t\t} else {\n\t\t\t// Skipped or no first child and no next sibling, so traverse upwards,\n\t\t\ttmp = node.parentNode;\n\t\t\t// and decrement the depth.\n\t\t\tdepth--;\n\t\t\t// Enable skipping, so that in the next loop iteration, the children of\n\t\t\t// the now-current node (parent node) aren't processed again.\n\t\t\tskip = true;\n\t\t}\n\n\t\t// Instead of setting node explicitly in each conditional block, use the\n\t\t// tmp var and set it here.\n\t\tnode = tmp;\n\n\t\t// Stop if depth comes back to 0 (or goes below zero, in conditions where\n\t\t// the passed node has neither children nore next siblings).\n\t} while ( depth > 0 );\n\n\treturn items;\n}\n\n// IE11 requires a filter parameter for createTreeWalker\n// it also must be an object with an `acceptNode` property\nfunction treeWalkerFilterFunction() {\n\treturn NodeFilter.FILTER_ACCEPT;\n}\nvar treeWalkerFilter = treeWalkerFilterFunction;\ntreeWalkerFilter.acceptNode = treeWalkerFilterFunction;\n\nfunction getNodesWithTreeWalker(rootNode) {\n\tvar result = isFragment(rootNode) ? [] : [rootNode];\n\n\t// IE11 throws if createTreeWalker is called on a non-ElementNode\n\tvar walker = isElementNode(rootNode) && getDocument().createTreeWalker(\n\t\trootNode,\n\t\tNodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT,\n\t\ttreeWalkerFilter,\n\t\tfalse\n\t);\n\n\tvar node;\n\twhile(node = walker && walker.nextNode()) {\n\t\tresult.push(node);\n\t}\n\treturn result;\n}\n\nfunction getAllNodes (node) {\n\tif( getDocument().createTreeWalker !== undefined ) {\n\t\treturn getNodesWithTreeWalker(node);\n\t} else {\n\t\treturn getNodesLegacyB(node);\n\t}\n}\n\nfunction subscription (fn) {\n\treturn function _subscription () {\n\t\tvar disposal = fn.apply(this, arguments);\n\t\tvar isDisposed = false;\n\t\treturn function _disposal () {\n\t\t\tif (isDisposed) {\n\t\t\t\tvar fnName = fn.name || fn.displayName || 'an anonymous function';\n\t\t\t\tvar message = 'Disposal function returned by ' + fnName + ' called more than once.';\n\t\t\t\tthrow new Error(message);\n\t\t\t}\n\t\t\tdisposal.apply(this, arguments);\n\t\t\tisDisposed = true;\n\t\t};\n\t};\n}\n\nmodule.exports = {\n\teliminate: eliminate,\n\tgetDocument: getDocument,\n\tisDocumentElement: isDocumentElement,\n\tisFragment: isFragment,\n\tgetParents: getParents,\n\tgetAllNodes: getAllNodes,\n\tgetChildren: getChildren,\n\tsubscription: subscription,\n\twasNotInSet: wasNotInSet,\n\tcontains: contains\n};\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-dom-mutate/-util.js?");

/***/ }),

/***/ "../../../../node_modules/can-dom-mutate/can-dom-mutate.js":
/*!**********************************************************************!*\
  !*** C:/Projects/game/node_modules/can-dom-mutate/can-dom-mutate.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar globals = __webpack_require__(/*! can-globals */ \"../../../../node_modules/can-globals/can-globals.js\");\nvar getRoot = __webpack_require__(/*! can-globals/global/global */ \"../../../../node_modules/can-globals/global/global.js\");\nvar getMutationObserver = __webpack_require__(/*! can-globals/mutation-observer/mutation-observer */ \"../../../../node_modules/can-globals/mutation-observer/mutation-observer.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../../../node_modules/can-namespace/can-namespace.js\");\nvar DOCUMENT = __webpack_require__(/*! can-globals/document/document */ \"../../../../node_modules/can-globals/document/document.js\");\n\nvar util = __webpack_require__(/*! ./-util */ \"../../../../node_modules/can-dom-mutate/-util.js\");\nvar eliminate = util.eliminate;\nvar subscription = util.subscription;\nvar isDocumentElement = util.isDocumentElement;\nvar getAllNodes = util.getAllNodes;\n\nvar domMutate,\n\tdispatchNodeInserted,\n\tdispatchNodeConnected,\n\tdispatchGlobalConnected,\n\tdispatchNodeRemoved,\n\tdispatchNodeDisconnected,\n\tdispatchGlobalDisconnected,\n\tdispatchAttributeChange,\n\tdispatchGlobalAttributeChange;\n\nvar dataStore = new WeakMap();\nvar isConnected = __webpack_require__(/*! ./-is-connected */ \"../../../../node_modules/can-dom-mutate/-is-connected.js\");\n\nvar queue;\n\nfunction getRelatedData(node, key) {\n\tvar data = dataStore.get(node);\n\tif (data) {\n\t\treturn data[key];\n\t}\n}\n\nfunction setRelatedData(node, key, targetListenersMap) {\n\tvar data = dataStore.get(node);\n\tif (!data) {\n\t\tdata = {};\n\t\tdataStore.set(node, data);\n\t}\n\tdata[key] = targetListenersMap;\n}\n\nfunction deleteRelatedData(node, key) {\n\tvar data = dataStore.get(node);\n\treturn delete data[key];\n}\n\nfunction toMutationEvent(node, mutation) {\n\treturn {target: node, sourceMutation: mutation};\n}\n\nfunction getDocumentListeners (target, key) {\n\t// TODO: it's odd these functions read DOCUMENT() instead of\n\t// target.ownerDocument.  To change to ownerDocument, we might need a \"is document\"\n\t// check.\n\tvar doc = DOCUMENT();\n\tvar data = getRelatedData(doc, key);\n\tif (data) {\n\t\treturn data.listeners;\n\t}\n}\n\nfunction getTargetListeners (target, key) {\n\tvar doc = DOCUMENT();\n\tvar targetListenersMap = getRelatedData(doc, key);\n\tif (!targetListenersMap) {\n\t\treturn;\n\t}\n\n\treturn targetListenersMap.get(target);\n}\n\nfunction addTargetListener (target, key, listener) {\n\tvar doc = DOCUMENT();\n\tvar targetListenersMap = getRelatedData(doc, key);\n\tif (!targetListenersMap) {\n\t\ttargetListenersMap = new WeakMap();\n\t\tsetRelatedData(doc, key, targetListenersMap);\n\t}\n\tvar targetListeners = targetListenersMap.get(target);\n\tif (!targetListeners) {\n\t\ttargetListeners = [];\n\t\ttargetListenersMap.set(target, targetListeners);\n\t}\n\ttargetListeners.push(listener);\n}\n\nfunction removeTargetListener (target, key, listener) {\n\tvar doc = DOCUMENT();\n\tvar targetListenersMap = getRelatedData(doc, key);\n\tif (!targetListenersMap) {\n\t\treturn;\n\t}\n\tvar targetListeners = targetListenersMap.get(target);\n\tif (!targetListeners) {\n\t\treturn;\n\t}\n\teliminate(targetListeners, listener);\n\tif (targetListeners.length === 0) {\n\t\ttargetListenersMap['delete'](target);\n\t\tif (targetListenersMap.size === 0) {\n\t\t\tdeleteRelatedData(doc, key);\n\t\t}\n\t}\n}\n\nvar promise = Promise.resolve();\nfunction nextTick(handler) {\n\tpromise.then(handler);\n}\n\n//var recordsAndCallbacks = null;\n\nfunction flushCallbacks(callbacks, arg){\n\tvar callbacksCount = callbacks.length;\n\tvar safeCallbacks = callbacks.slice(0);\n\tfor(var c = 0; c < callbacksCount; c++){\n\t\tsafeCallbacks[c](arg);\n\t}\n}\n\nfunction dispatch(getListeners, targetKey) {\n\n\treturn function dispatchEvents(event) {\n\t\tvar targetListeners = getListeners(event.target, targetKey);\n\n\t\tif (targetListeners) {\n\t\t\tflushCallbacks(targetListeners, event);\n\t\t}\n\t};\n}\n\nvar count = 0;\n\nfunction observeMutations(target, observerKey, config, handler) {\n\n\tvar observerData = getRelatedData(target, observerKey);\n\tif (!observerData) {\n\t\tobserverData = {\n\t\t\tobservingCount: 0\n\t\t};\n\t\tsetRelatedData(target, observerKey, observerData);\n\t}\n\n\tvar setupObserver = function () {\n\t\t// disconnect the old one\n\t\tif (observerData.observer) {\n\t\t\tobserverData.observer.disconnect();\n\t\t\tobserverData.observer = null;\n\t\t}\n\n\t\tvar MutationObserver = getMutationObserver();\n\t\tif (MutationObserver) {\n\t\t\tvar Node = getRoot().Node;\n\t\t\tvar isRealNode = !!(Node && target instanceof Node);\n\t\t\tif (isRealNode) {\n\t\t\t\tvar targetObserver = new MutationObserver(handler);\n\t\t\t\ttargetObserver.id = count++;\n\t\t\t\ttargetObserver.observe(target, config);\n\t\t\t\tobserverData.observer = targetObserver;\n\t\t\t}\n\t\t}\n\t};\n\n\tif (observerData.observingCount === 0) {\n\t\tglobals.onKeyValue('MutationObserver', setupObserver);\n\t\tsetupObserver();\n\t}\n\n\tobserverData.observingCount++;\n\treturn function stopObservingMutations() {\n\t\tvar observerData = getRelatedData(target, observerKey);\n\t\tif (observerData) {\n\t\t\tobserverData.observingCount--;\n\t\t\tif (observerData.observingCount <= 0) {\n\t\t\t\tif (observerData.observer) {\n\t\t\t\t\tobserverData.observer.disconnect();\n\t\t\t\t}\n\t\t\t\tdeleteRelatedData(target, observerKey);\n\t\t\t\tglobals.offKeyValue('MutationObserver', setupObserver);\n\t\t\t}\n\t\t}\n\t};\n}\n\nvar treeMutationConfig = {\n\tsubtree: true,\n\tchildList: true\n};\n\nvar attributeMutationConfig = {\n\tattributes: true,\n\tattributeOldValue: true\n};\n\nfunction addNodeListener(listenerKey, observerKey, isAttributes) {\n\treturn subscription(function _addNodeListener(target, listener) {\n\t\t// DocumentFragment\n\t\tif(target.nodeType === 11) {\n\t\t\t// This returns a noop without actually doing anything.\n\t\t\t// We should probably warn about passing a DocumentFragment here,\n\t\t\t// but since can-stache does so currently we are ignoring until that is\n\t\t\t// fixed.\n\t\t\treturn Function.prototype;\n\t\t}\n\n\t\tvar stopObserving;\n\t\tif (isAttributes) {\n\t\t\tstopObserving = observeMutations(target, observerKey, attributeMutationConfig, queue.enqueueAndFlushMutations);\n\t\t} else {\n\t\t\tstopObserving = observeMutations(DOCUMENT(), observerKey, treeMutationConfig, queue.enqueueAndFlushMutations);\n\t\t}\n\n\t\taddTargetListener(target, listenerKey, listener);\n\t\treturn function removeNodeListener() {\n\t\t\tif(stopObserving) {\n\t\t\t\tstopObserving();\n\t\t\t}\n\n\t\t\tremoveTargetListener(target, listenerKey, listener);\n\t\t};\n\t});\n}\n\nfunction addGlobalListener(globalDataKey, addNodeListener) {\n\treturn subscription(function addGlobalGroupListener(documentElement, listener) {\n\t\tif (!isDocumentElement(documentElement)) {\n\t\t\tthrow new Error('Global mutation listeners must pass a documentElement');\n\t\t}\n\n\t\tvar doc = DOCUMENT();\n\t\tvar documentData = getRelatedData(doc, globalDataKey);\n\t\tif (!documentData) {\n\t\t\tdocumentData = {listeners: []};\n\t\t\tsetRelatedData(doc, globalDataKey, documentData);\n\t\t}\n\n\t\tvar listeners = documentData.listeners;\n\t\tif (listeners.length === 0) {\n\t\t\t// We need at least on listener for mutation events to propagate\n\t\t\tdocumentData.removeListener = addNodeListener(doc, function () {});\n\t\t}\n\n\t\tlisteners.push(listener);\n\n\t\treturn function removeGlobalGroupListener() {\n\t\t\tvar documentData = getRelatedData(doc, globalDataKey);\n\t\t\tif (!documentData) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar listeners = documentData.listeners;\n\t\t\teliminate(listeners, listener);\n\t\t\tif (listeners.length === 0) {\n\t\t\t\tdocumentData.removeListener();\n\t\t\t\tdeleteRelatedData(doc, globalDataKey);\n\t\t\t}\n\t\t};\n\t});\n}\n\n\n\nvar domMutationPrefix = 'domMutation';\n\n// target listener keys\nvar connectedDataKey = domMutationPrefix + 'ConnectedData';\nvar disconnectedDataKey = domMutationPrefix + 'DisconnectedData';\nvar insertedDataKey = domMutationPrefix + 'InsertedData';\nvar removedDataKey = domMutationPrefix + 'RemovedData';\nvar attributeChangeDataKey = domMutationPrefix + 'AttributeChangeData';\n\n// document listener keys\nvar documentConnectedDataKey = domMutationPrefix + 'DocumentConnectedData';\nvar documentDisconnectedDataKey = domMutationPrefix + 'DocumentDisconnectedData';\nvar documentAttributeChangeDataKey = domMutationPrefix + 'DocumentAttributeChangeData';\n\n// observer keys\nvar treeDataKey = domMutationPrefix + 'TreeData';\nvar attributeDataKey = domMutationPrefix + 'AttributeData';\n\ndispatchNodeInserted = dispatch(getTargetListeners, insertedDataKey);\ndispatchNodeConnected = dispatch(getTargetListeners, connectedDataKey);\ndispatchGlobalConnected = dispatch(getDocumentListeners, documentConnectedDataKey);\n\ndispatchNodeRemoved = dispatch(getTargetListeners, removedDataKey);\ndispatchNodeDisconnected = dispatch(getTargetListeners, disconnectedDataKey);\ndispatchGlobalDisconnected = dispatch(getDocumentListeners, documentDisconnectedDataKey);\n\ndispatchAttributeChange = dispatch(getTargetListeners, attributeChangeDataKey);\ndispatchGlobalAttributeChange = dispatch(getDocumentListeners, documentAttributeChangeDataKey);\n\n// node listeners\nvar addNodeConnectedListener = addNodeListener(connectedDataKey, treeDataKey);\nvar addNodeDisconnectedListener = addNodeListener(disconnectedDataKey, treeDataKey);\nvar addNodeInsertedListener = addNodeListener(insertedDataKey, treeDataKey);\nvar addNodeRemovedListener = addNodeListener(removedDataKey, treeDataKey);\nvar addNodeAttributeChangeListener = addNodeListener(attributeChangeDataKey, attributeDataKey, true);\n\n// global listeners\nvar addConnectedListener = addGlobalListener(\n\tdocumentConnectedDataKey,\n\taddNodeConnectedListener\n);\nvar addDisconnectedListener = addGlobalListener(\n\tdocumentDisconnectedDataKey,\n\taddNodeDisconnectedListener\n);\nvar addAttributeChangeListener = addGlobalListener(\n\tdocumentAttributeChangeDataKey,\n\taddNodeAttributeChangeListener\n);\n\n// ==========================================\nfunction dispatchTreeMutation(mutation, processedState) {\n\t// was the mutation connected\n\tvar wasConnected = mutation.isConnected === true || mutation.isConnected === undefined;\n\n\t// there are\n\t// - the global connected\n\t// - individual connected\n\t// - individual inserted\n\tvar removedCount = mutation.removedNodes.length;\n\tfor (var r = 0; r < removedCount; r++) {\n\t\t// get what already isn't in `removed`\n\n\t\t// see if \"removed\"\n\t\t// if wasConnected .. dispatch disconnected\n\t\tvar removedNodes = getAllNodes(mutation.removedNodes[r]);\n\t\tremovedNodes.forEach(function(node){\n\t\t\tvar event = toMutationEvent(node, mutation);\n\n\t\t\tif( util.wasNotInSet(node, processedState.removed) ) {\n\t\t\t\tdispatchNodeRemoved( event );\n\t\t\t}\n\t\t\tif(wasConnected && util.wasNotInSet(node, processedState.disconnected) ) {\n\t\t\t\tdispatchNodeDisconnected( event );\n\t\t\t\tdispatchGlobalDisconnected( event );\n\t\t\t}\n\t\t});\n\t}\n\n\tvar addedCount = mutation.addedNodes.length;\n\tfor (var a = 0; a < addedCount; a++) {\n\t\tvar insertedNodes = getAllNodes(mutation.addedNodes[a]);\n\t\tinsertedNodes.forEach(function(node){\n\t\t\tvar event = toMutationEvent(node, mutation);\n\n\t\t\tif(util.wasNotInSet(node, processedState.inserted)) {\n\t\t\t\tdispatchNodeInserted( event );\n\t\t\t}\n\t\t\tif(wasConnected && util.wasNotInSet(node, processedState.connected) ) {\n\t\t\t\tdispatchNodeConnected( event );\n\t\t\t\tdispatchGlobalConnected( event );\n\t\t\t}\n\t\t});\n\t}\n\t// run mutation\n}\n\n\nvar FLUSHING_MUTATIONS = [];\nvar IS_FLUSHING = false;\n\nvar IS_FLUSH_PENDING = false;\nvar ENQUEUED_MUTATIONS = [];\n\nqueue = {\n\t// This is used to dispatch mutations immediately.\n\t// This is usually called by the result of a mutation observer.\n\tenqueueAndFlushMutations: function(mutations) {\n\t\tif(IS_FLUSH_PENDING) {\n\t\t\tFLUSHING_MUTATIONS.push.apply(FLUSHING_MUTATIONS, ENQUEUED_MUTATIONS);\n\t\t\tIS_FLUSH_PENDING = false;\n\t\t\tENQUEUED_MUTATIONS = [];\n\t\t}\n\n\t\tFLUSHING_MUTATIONS.push.apply(FLUSHING_MUTATIONS, mutations);\n\t\tif(IS_FLUSHING) {\n\t\t\treturn;\n\t\t}\n\n\t\tIS_FLUSHING = true;\n\n\t\tvar index = 0;\n\n\t\tvar processedState = {\n\t\t\tconnected: new Set(),\n\t\t\tdisconnected: new Set(),\n\t\t\tinserted: new Set(),\n\t\t\tremoved: new Set()\n\t\t};\n\n\t\twhile(index < FLUSHING_MUTATIONS.length) {\n\t\t\tvar mutation = FLUSHING_MUTATIONS[index];\n\t\t\t// process mutation\n\t\t\tif(mutation.type === \"childList\") {\n\t\t\t\tdispatchTreeMutation(mutation, processedState);\n\t\t\t} else if(mutation.type === \"attributes\") {\n\t\t\t\tdispatchAttributeChange(mutation);\n\t\t\t}\n\t\t\tindex++;\n\n\t\t}\n\t\tFLUSHING_MUTATIONS = [];\n\t\tIS_FLUSHING = false;\n\t},\n\t// called to dipatch later unless we are already dispatching.\n\tenqueueMutationsAndFlushAsync: function(mutations){\n\t\tENQUEUED_MUTATIONS.push.apply(ENQUEUED_MUTATIONS, mutations);\n\n\t\t// if there are currently dispatching mutations, this should happen sometime after\n\t\tif(!IS_FLUSH_PENDING) {\n\t\t\tIS_FLUSH_PENDING = true;\n\t\t\tnextTick(function(){\n\t\t\t\tif(IS_FLUSH_PENDING) {\n\t\t\t\t\tIS_FLUSH_PENDING = false;\n\t\t\t\t\tvar pending = ENQUEUED_MUTATIONS;\n\t\t\t\t\tENQUEUED_MUTATIONS = [];\n\t\t\t\t\tqueue.enqueueAndFlushMutations(pending);\n\t\t\t\t} else {\n\t\t\t\t\t// Someone called enqueueAndFlushMutations before this finished.\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n};\n\n\n// ==========================================\n\n\ndomMutate = {\n\t/**\n\t* @function can-dom-mutate.dispatchNodeInsertion dispatchNodeInsertion\n\t* @hide\n\t*\n\t* Dispatch an insertion mutation on the given node.\n\t*\n\t* @signature `dispatchNodeInsertion( node [, callback ] )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} node The node on which to dispatch an insertion mutation.\n\t*/\n\tdispatchNodeInsertion: function (node, target) {\n\t\tqueue.enqueueMutationsAndFlushAsync(\n\t\t\t[{\n\t\t\t\ttype: \"childList\",\n\t\t\t\ttarget: target,\n\t\t\t\taddedNodes: [node],\n\t\t\t\tisConnected: isConnected.isConnected(target),\n\t\t\t\tremovedNodes: []\n\t\t\t}]\n\t\t);\n\t\t/*\n\t\tvar nodes = new Set();\n\t\tutil.addToSet( getAllNodes(node), nodes);\n\t\tvar events = toMutationEvents( canReflect.toArray(nodes) );\n\t\t// this is basically an array of every single child of node including node\n\t\tdispatchInsertion(events, callback, dispatchConnected, flushAsync);*/\n\t},\n\n\t/**\n\t* @function can-dom-mutate.dispatchNodeRemoval dispatchNodeRemoval\n\t* @hide\n\t*\n\t* Dispatch a removal mutation on the given node.\n\t*\n\t* @signature `dispatchNodeRemoval( node [, callback ] )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} node The node on which to dispatch a removal mutation.\n\t* @param {function} callback The optional callback called after the mutation is dispatched.\n\t*/\n\tdispatchNodeRemoval: function (node, target) {\n\t\tqueue.enqueueMutationsAndFlushAsync(\n\t\t\t[{\n\t\t\t\ttype: \"childList\",\n\t\t\t\ttarget: target,\n\t\t\t\taddedNodes: [],\n\t\t\t\tremovedNodes: [node],\n\t\t\t\tisConnected: isConnected.isConnected(target)\n\t\t\t}]\n\t\t);\n\t\t/*\n\t\tvar nodes = new Set();\n\t\tutil.addToSet( getAllNodes(node), nodes);\n\t\tvar events = toMutationEvents( canReflect.toArray(nodes) );\n\t\tdispatchRemoval(events, callback, dispatchConnected, flushAsync);*/\n\t},\n\n\t/**\n\t* @function can-dom-mutate.dispatchNodeAttributeChange dispatchNodeAttributeChange\n\t* @parent can-dom-mutate.static\n\t* @hide\n\t*\n\t* Dispatch an attribute change mutation on the given node.\n\t*\n\t* @signature `dispatchNodeAttributeChange( node, attributeName, oldValue [, callback ] )`\n\t*\n\t* ```\n\t* input.setAttribute(\"value\", \"newValue\")\n\t* domMutate.dispatchNodeAttributeChange(input, \"value\",\"oldValue\")\n\t* ```\n\t*\n\t*\n\t* @param {Node} target The node on which to dispatch an attribute change mutation.\n\t* @param {String} attributeName The attribute name whose value has changed.\n\t* @param {String} oldValue The attribute value before the change.\n\t*/\n\tdispatchNodeAttributeChange: function (target, attributeName, oldValue) {\n\t\tqueue.enqueueMutationsAndFlushAsync(\n\t\t\t[{\n\t\t\t\ttype: \"attributes\",\n\t\t\t\ttarget: target,\n\t\t\t\tattributeName: attributeName,\n\t\t\t\toldValue: oldValue\n\t\t\t}]\n\t\t);\n\t},\n\n\t/**\n\t* @function can-dom-mutate.onNodeConnected onNodeConnected\n\t*\n\t* Listen for insertion mutations on the given node.\n\t*\n\t* @signature `onNodeConnected( node, callback )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} node The node on which to listen for insertion mutations.\n\t* @param {function} callback The callback called when an insertion mutation is dispatched.\n\t* @return {function} The callback to remove the mutation listener.\n\t*/\n\tonNodeConnected: addNodeConnectedListener,\n\tonNodeInsertion: function(){\n\t\t// TODO: remove in prod\n\t\tconsole.warn(\"can-dom-mutate: Use onNodeConnected instead of onNodeInsertion\");\n\t\treturn addNodeConnectedListener.apply(this, arguments);\n\t},\n\t/**\n\t* @function can-dom-mutate.onNodeDisconnected onNodeDisconnected\n\t*\n\t* Listen for removal mutations on the given node.\n\t*\n\t* @signature `onNodeDisconnected( node, callback )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} node The node on which to listen for removal mutations.\n\t* @param {function} callback The callback called when a removal mutation is dispatched.\n\t* @return {function} The callback to remove the mutation listener.\n\t*/\n\tonNodeDisconnected: addNodeDisconnectedListener,\n\tonNodeRemoval: function(){\n\t\t// TODO: remove in prod\n\t\tconsole.warn(\"can-dom-mutate: Use onNodeDisconnected instead of onNodeRemoval\");\n\t\treturn addNodeDisconnectedListener.apply(this, arguments);\n\t},\n\t/**\n\t* @function can-dom-mutate.onNodeAttributeChange onNodeAttributeChange\n\t*\n\t* Listen for attribute change mutations on the given node.\n\t*\n\t* @signature `onNodeAttributeChange( node, callback )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} node The node on which to listen for attribute change mutations.\n\t* @param {function} callback The callback called when an attribute change mutation is dispatched.\n\t* @return {function} The callback to remove the mutation listener.\n\t*/\n\tonNodeAttributeChange: addNodeAttributeChangeListener,\n\n\t/**\n\t* @function can-dom-mutate.onDisconnected onDisconnected\n\t*\n\t* Listen for removal mutations on any node within the documentElement.\n\t*\n\t* @signature `onDisconnected( documentElement, callback )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} documentElement The documentElement on which to listen for removal mutations.\n\t* @param {function} callback The callback called when a removal mutation is dispatched.\n\t* @return {function} The callback to remove the mutation listener.\n\t*/\n\tonDisconnected: addDisconnectedListener,\n\tonRemoval: function(){\n\t\t// TODO: remove in prod\n\t\tconsole.warn(\"can-dom-mutate: Use onDisconnected instead of onRemoval\");\n\t\treturn addDisconnectedListener.apply(this, arguments);\n\t},\n\t/**\n\t* @function can-dom-mutate.onConnected onConnected\n\t*\n\t* Listen for insertion mutations on any node within the documentElement.\n\t*\n\t* @signature `onConnected( documentElement, callback )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} documentElement The documentElement on which to listen for removal mutations.\n\t* @param {function} callback The callback called when a insertion mutation is dispatched.\n\t* @return {function} The callback to remove the mutation listener.\n\t*/\n\tonConnected: addConnectedListener,\n\tonInsertion: function(){\n\t\t// TODO: remove in prod\n\t\tconsole.warn(\"can-dom-mutate: Use onConnected instead of onInsertion\");\n\t\treturn addConnectedListener.apply(this, arguments);\n\t},\n\t/**\n\t* @function can-dom-mutate.onAttributeChange onAttributeChange\n\t*\n\t* Listen for attribute change mutations on any node within the documentElement.\n\t*\n\t* @signature `onAttributeChange( documentElement, callback )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} documentElement The documentElement on which to listen for removal mutations.\n\t* @param {function} callback The callback called when an attribute change mutation is dispatched.\n\t* @return {function} The callback to remove the mutation listener.\n\t*/\n\tonAttributeChange: addAttributeChangeListener,\n\n\tflushRecords: function(doc){\n\t\tdoc = doc || DOCUMENT();\n\t\tvar data = dataStore.get(doc),\n\t\t\trecords = [];\n\t\tif(data) {\n\t\t\tif(data.domMutationTreeData && data.domMutationTreeData.observer) {\n\t\t\t\trecords = data.domMutationTreeData.observer.takeRecords();\n\t\t\t}\n\t\t}\n\t\tqueue.enqueueAndFlushMutations(records);\n\t},\n\tonNodeInserted: addNodeInsertedListener,\n\tonNodeRemoved: addNodeRemovedListener\n};\n\n//!steal-remove-start\nif(true) {\n\tdomMutate.dataStore = dataStore;\n}\n//!steal-remove-end\n\nmodule.exports = namespace.domMutate = domMutate;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-dom-mutate/can-dom-mutate.js?");

/***/ }),

/***/ "../../../../node_modules/can-event-queue/dependency-record/merge.js":
/*!********************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-event-queue/dependency-record/merge.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../../../node_modules/can-reflect/can-reflect.js\");\n\nvar mergeValueDependencies = function mergeValueDependencies(obj, source) {\n\tvar sourceValueDeps = source.valueDependencies;\n\n\tif (sourceValueDeps) {\n\t\tvar destValueDeps = obj.valueDependencies;\n\n\t\t// make sure there is a valueDependencies Set\n\t\t// in the [obj] dependency record\n\t\tif (!destValueDeps) {\n\t\t\tdestValueDeps = new Set();\n\t\t\tobj.valueDependencies = destValueDeps;\n\t\t}\n\n\t\tcanReflect.eachIndex(sourceValueDeps, function(dep) {\n\t\t\tdestValueDeps.add(dep);\n\t\t});\n\t}\n};\n\nvar mergeKeyDependencies = function mergeKeyDependencies(obj, source) {\n\tvar sourcekeyDeps = source.keyDependencies;\n\n\tif (sourcekeyDeps) {\n\t\tvar destKeyDeps = obj.keyDependencies;\n\n\t\t// make sure there is a keyDependencies Map\n\t\t// in the [obj] dependency record\n\t\tif (!destKeyDeps) {\n\t\t\tdestKeyDeps = new Map();\n\t\t\tobj.keyDependencies = destKeyDeps;\n\t\t}\n\n\t\tcanReflect.eachKey(sourcekeyDeps, function(keys, obj) {\n\t\t\tvar entry = destKeyDeps.get(obj);\n\n\t\t\tif (!entry) {\n\t\t\t\tentry = new Set();\n\t\t\t\tdestKeyDeps.set(obj, entry);\n\t\t\t}\n\n\t\t\tcanReflect.eachIndex(keys, function(key) {\n\t\t\t\tentry.add(key);\n\t\t\t});\n\t\t});\n\t}\n};\n\n// Merges the key and value dependencies of the source object into the\n// destination object\nmodule.exports = function mergeDependencyRecords(object, source) {\n\tmergeKeyDependencies(object, source);\n\tmergeValueDependencies(object, source);\n\treturn object;\n};\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-event-queue/dependency-record/merge.js?");

/***/ }),

/***/ "../../../../node_modules/can-event-queue/map/map.js":
/*!****************************************************************!*\
  !*** C:/Projects/game/node_modules/can-event-queue/map/map.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module {function} can-event-queue/map/map\n * @parent can-event-queue\n * @templateRender true\n *\n * @description Mixin methods and symbols to make this object or prototype object\n * behave like a key-value observable.\n *\n * @signature `mixinMapBindings( obj )`\n *\n * Adds symbols and methods that make `obj` or instances having `obj` on their prototype\n * behave like key-value observables.\n *\n * When `mixinMapBindings` is called on an `obj` like:\n *\n * ```js\n * var mixinMapBindings = require(\"can-event-queue/map/map\");\n *\n * var observable = mixinValueBindings({});\n *\n * observable.on(\"prop\",function(ev, newVal, oldVal){\n *   console.log(newVal);\n * });\n *\n * observable[canSymbol.for(\"can.dispatch\")](\"prop\",[2,1]);\n * // Logs: 2\n * ```\n *\n * `mixinMapBindings` adds the following properties and symbols to the object:\n *\n * {{#each (getChildren [can-event-queue/map/map])}}\n * - [{{name}}] - {{description}}{{/each}}\n *\n * Furthermore, `mixinMapBindings` looks for the following symbols on the object's `.constructor`\n * property:\n *\n * - `@can.dispatchInstanceBoundChange` - Called when the bind status of an instance changes.\n * - `@can.dispatchInstanceOnPatches` - Called if [can-event-queue/map/map.dispatch] is called with `event.patches` as an array of\n *   patches.\n */\nvar canDev = __webpack_require__(/*! can-log/dev/dev */ \"../../../../node_modules/can-log/dev/dev.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../../../node_modules/can-queues/can-queues.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../../../node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../../../node_modules/can-symbol/can-symbol.js\");\nvar KeyTree = __webpack_require__(/*! can-key-tree */ \"../../../../node_modules/can-key-tree/can-key-tree.js\");\n\nvar domEvents = __webpack_require__(/*! can-dom-events */ \"../../../../node_modules/can-dom-events/can-dom-events.js\");\nvar isDomEventTarget = __webpack_require__(/*! can-dom-events/helpers/util */ \"../../../../node_modules/can-dom-events/helpers/util.js\").isDomEventTarget;\n\nvar mergeDependencyRecords = __webpack_require__(/*! ../dependency-record/merge */ \"../../../../node_modules/can-event-queue/dependency-record/merge.js\");\n\nvar metaSymbol = canSymbol.for(\"can.meta\"),\n\tdispatchBoundChangeSymbol = canSymbol.for(\"can.dispatchInstanceBoundChange\"),\n\tdispatchInstanceOnPatchesSymbol = canSymbol.for(\"can.dispatchInstanceOnPatches\"),\n\tonKeyValueSymbol = canSymbol.for(\"can.onKeyValue\"),\n\toffKeyValueSymbol = canSymbol.for(\"can.offKeyValue\"),\n\tonEventSymbol = canSymbol.for(\"can.onEvent\"),\n\toffEventSymbol = canSymbol.for(\"can.offEvent\"),\n\tonValueSymbol = canSymbol.for(\"can.onValue\"),\n\toffValueSymbol = canSymbol.for(\"can.offValue\"),\n\tinSetupSymbol = canSymbol.for(\"can.initializing\");\n\nvar legacyMapBindings;\n\nfunction addHandlers(obj, meta) {\n\tif (!meta.handlers) {\n\t\t// Handlers are organized by:\n\t\t// event name - the type of event bound to\n\t\t// binding type - \"event\" for things that expect an event object (legacy), \"onKeyValue\" for reflective bindings.\n\t\t// queue name - mutate, queue, etc\n\t\t// handlers - the handlers.\n\t\tmeta.handlers = new KeyTree([Object, Object, Object, Array], {\n\t\t\tonFirst: function() {\n\t\t\t\tif (obj._eventSetup !== undefined) {\n\t\t\t\t\tobj._eventSetup();\n\t\t\t\t}\n\t\t\t\tvar constructor = obj.constructor;\n\t\t\t\tif(constructor[dispatchBoundChangeSymbol] !== undefined && obj instanceof constructor) {\n\t\t\t\t\tconstructor[dispatchBoundChangeSymbol](obj, true);\n\t\t\t\t}\n\t\t\t\t//queues.enqueueByQueue(getLifecycleHandlers(obj).getNode([]), obj, [true]);\n\t\t\t},\n\t\t\tonEmpty: function() {\n\t\t\t\tif (obj._eventTeardown !== undefined) {\n\t\t\t\t\tobj._eventTeardown();\n\t\t\t\t}\n\t\t\t\tvar constructor = obj.constructor;\n\t\t\t\tif(constructor[dispatchBoundChangeSymbol] !== undefined && obj instanceof constructor) {\n\t\t\t\t\tconstructor[dispatchBoundChangeSymbol](obj, false);\n\t\t\t\t}\n\t\t\t\t//queues.enqueueByQueue(getLifecycleHandlers(obj).getNode([]), obj, [false]);\n\t\t\t}\n\t\t});\n\t}\n\n\tif (!meta.listenHandlers) {\n\t\t// context, eventName (might be undefined), queue, handlers\n\t\tmeta.listenHandlers = new KeyTree([Map, Map, Object, Array]);\n\t}\n}\n\n\n// getHandlers returns a KeyTree used for event handling.\n// `handlers` will be on the `can.meta` symbol on the object.\n// Ensure the \"obj\" passed as an argument has an object on @@can.meta\nvar ensureMeta = function ensureMeta(obj) {\n\tvar meta = obj[metaSymbol];\n\n\tif (!meta) {\n\t\tmeta = {};\n\t\tcanReflect.setKeyValue(obj, metaSymbol, meta);\n\t}\n\taddHandlers(obj, meta);\n\n\treturn meta;\n};\n\nfunction stopListeningArgumentsToKeys(bindTarget, event, handler, queueName) {\n\tif(arguments.length && canReflect.isPrimitive(bindTarget)) {\n\t\tqueueName = handler;\n\t\thandler = event;\n\t\tevent = bindTarget;\n\t\tbindTarget = this.context;\n\t}\n\tif(typeof event === \"function\") {\n\t\tqueueName = handler;\n\t\thandler = event;\n\t\tevent = undefined;\n\t}\n\tif(typeof handler === \"string\") {\n\t\tqueueName = handler;\n\t\thandler = undefined;\n\t}\n\tvar keys = [];\n\tif(bindTarget) {\n\t\tkeys.push(bindTarget);\n\t\tif(event || handler || queueName) {\n\t\t\tkeys.push(event);\n\t\t\tif(queueName || handler) {\n\t\t\t\tkeys.push(queueName || this.defaultQueue);\n\t\t\t\tif(handler) {\n\t\t\t\t\tkeys.push(handler);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn keys;\n}\n\n\n// These are the properties we are going to add to objects\nvar props = {\n\t/**\n\t * @function can-event-queue/map/map.dispatch dispatch\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Dispatch event and key binding handlers.\n\t *\n\t * @signature `obj.dispatch(event, [args])`\n\t *\n\t * Dispatches registered [can-event-queue/map/map.addEventListener] and\n\t * [can-event-queue/map/map.can.onKeyValue] value binding handlers.\n\t *\n\t * The following shows dispatching the `property` event and\n\t * `keyValue` handlers:\n\t *\n\t *\n\t * ```js\n\t * var mixinMapBindings = require(\"can-event-queue/map/map\");\n\t *\n\t * var obj = mixinMapBindings({});\n\t *\n\t * obj.addEventListener(\"property\", function(event, newVal){\n\t *   event.type //-> \"property\"\n\t *   newVal     //-> 5\n\t * });\n\t *\n\t * canReflect.onKeyValue(\"property\", function(newVal){\n\t *   newVal     //-> 5\n\t * })\n\t *\n\t * obj.dispatch(\"property\", [5]);\n\t * ```\n\t *\n\t * > NOTE: Event handlers have an additional `event` argument.\n\t *\n\t * @param {String|Object} event The event to dispatch. If a string is passed,\n\t *   it will be used as the `type` of the event that will be dispatched and dispatch matching\n\t *   [can-event-queue/map/map.can.onKeyValue] bindings:\n\t *\n\t *   ```js\n\t *   obs.dispatch(\"key\")\n\t *   ```\n\t *\n\t *   If `event` is an object, it __MUST__ have a `type` property. The If a string is passed,\n\t *   it will be used as the `type` of the event that will be dispatched and dispatch matching\n\t *   [can-event-queue/map/map.can.onKeyValue] bindings:\n\t *\n\t *   ```js\n\t *   obs.dispatch({type: \"key\"})\n\t *   ```\n\t *\n\t *   The `event` object can also have the following properties and values:\n\t *   - __reasonLog__ `{Array}` - The reason this event happened. This will be passed to\n\t *     [can-queues.enqueueByQueue] for debugging purposes.\n\t *   - __makeMeta__ `{function}` - Details about the handler being called. This will be passed to\n\t *     [can-queues.enqueueByQueue] for debugging purposes.\n\t *   - __patches__ `{Array<Patch>}` - The patch objects this event represents.  The `.patches` value will be\n\t *     passed to the object's `.constructor`'s `@can.dispatchInstanceOnPatches` method.\n\t *\n\t * @param {Array} [args] Additional arguments to pass to event handlers.\n\t * @return {Object} event The resulting event object.\n\t */\n\tdispatch: function(event, args) {\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tif (arguments.length > 4) {\n\t\t\t\tcanDev.warn('Arguments to dispatch should be an array, not multiple arguments.');\n\t\t\t\targs = Array.prototype.slice.call(arguments, 1);\n\t\t\t}\n\n\t\t\tif (args && !Array.isArray(args)) {\n\t\t\t\tcanDev.warn('Arguments to dispatch should be an array.');\n\t\t\t\targs = [args];\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\t// Don't send events if initalizing.\n\t\tif (this.__inSetup !== true && this[inSetupSymbol] !== true) {\n\t\t\tif (typeof event === 'string') {\n\t\t\t\tevent = {\n\t\t\t\t\ttype: event\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar meta = ensureMeta(this);\n\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tif (!event.reasonLog) {\n\t\t\t\t\tevent.reasonLog = [canReflect.getName(this), \"dispatched\", '\"' + event.type + '\"', \"with\"].concat(args);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeof meta._log === \"function\") {\n\t\t\t\tmeta._log.call(this, event, args);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tvar handlers = meta.handlers;\n\t\t\tvar handlersByType = event.type !== undefined && handlers.getNode([event.type]);\n\t\t\tvar dispatchConstructorPatches = event.patches && this.constructor[dispatchInstanceOnPatchesSymbol];\n\t\t\tvar patchesNode = event.patches !== undefined && handlers.getNode([\"can.patches\",\"onKeyValue\"]);\n\t\t\tvar keysNode = event.keyChanged !== undefined && handlers.getNode([\"can.keys\",\"onKeyValue\"]);\n\t\t\tvar batch = dispatchConstructorPatches || handlersByType || patchesNode || keysNode;\n\t\t\tif ( batch ) {\n\t\t\t\tqueues.batch.start();\n\t\t\t}\n\t\t\tif(handlersByType) {\n\t\t\t\tif (handlersByType.onKeyValue) {\n\t\t\t\t\tqueues.enqueueByQueue(handlersByType.onKeyValue, this, args, event.makeMeta, event.reasonLog);\n\t\t\t\t}\n\t\t\t\tif (handlersByType.event) {\n\t\t\t\t\tevent.batchNum = queues.batch.number();\n\t\t\t\t\tvar eventAndArgs = [event].concat(args);\n\t\t\t\t\tqueues.enqueueByQueue(handlersByType.event, this, eventAndArgs, event.makeMeta, event.reasonLog);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(keysNode) {\n\t\t\t\tqueues.enqueueByQueue(keysNode, this, [event.keyChanged], event.makeMeta, event.reasonLog);\n\t\t\t}\n\t\t\tif(patchesNode) {\n\t\t\t\tqueues.enqueueByQueue(patchesNode, this, [event.patches], event.makeMeta, event.reasonLog);\n\t\t\t}\n\t\t\tif(dispatchConstructorPatches) {\n\t\t\t\tthis.constructor[dispatchInstanceOnPatchesSymbol](this, event.patches);\n\t\t\t}\n\t\t\tif ( batch ) {\n\t\t\t\tqueues.batch.stop();\n\t\t\t}\n\t\t}\n\t\treturn event;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.addEventListener addEventListener\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Register an event handler to be called when an event is dispatched.\n\t *\n\t * @signature `obj.addEventListener(eventName, handler(event, ...) [,queueName] )`\n\t *\n\t * Add a event listener to an object.  Handlers attached by `.addEventListener` get\n\t * called back with the [can-event-queue/map/map.dispatch]\n\t * `event` object and any arguments used to dispatch. [can-event-queue/map/map.can.onKeyValue] bindings do\n\t * not get the event object.\n\t *\n\t * ```js\n\t * var mixinMapBindings = require(\"can-event-queue/map/map\");\n\t *\n\t * var obj = mixinMapBindings({});\n\t *\n\t * obj.addEventListener(\"foo\", function(event){ ... });\n\t * ```\n\t *\n\t * @param {String} eventName The name of the event to listen for.\n\t * @param {Function} handler(event,arg...) The handler that will be executed to handle the event.  The handler will be called\n\t *   with the dispatched `event` and `args`.\n\t * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler will called\n\t *   back within. Defaults to `\"mutate\"`.\n\t * @return {Object} Returns the object `.addEventListener` was called on.\n\t *\n\t */\n\taddEventListener: function(key, handler, queueName) {\n\t\tensureMeta(this).handlers.add([key, \"event\", queueName || \"mutate\", handler]);\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.removeEventListener removeEventListener\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Unregister an event handler to be called when an event is dispatched.\n\t *\n\t * @signature `obj.removeEventListener(eventName, [handler [,queueName]] )`\n\t *\n\t * Removes one or more handlers from being called when `eventName`\n\t * is [can-event-queue/map/map.dispatch]ed.\n\t *\n\t * ```js\n\t * // Removes `handler` if it is in the notify queue.\n\t * obj.removeEventListener(\"closed\", handler, \"notify\")\n\t *\n\t * // Removes `handler` if it is in the mutate queue.\n\t * obj.removeEventListener(\"closed\", handler)\n\t *\n\t * // Removes all \"closed\" handlers.\n\t * obj.removeEventListener(\"closed\")\n\t * ```\n\t *\n\t * @param {String} eventName The name of the event to remove. If not specified, all events are removed.\n\t * @param {Function} [handler] The handler that will be removed from the event. If not specified, all handlers for the event are removed.\n\t * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler was registered on. Defaults to `\"mutate\"`.\n\t * @return {Object} Returns the object `.removeEventListener` was called on.\n\t */\n\tremoveEventListener: function(key, handler, queueName) {\n\t\tif(key === undefined) {\n\t\t\t// This isn't super fast, but this pattern isn't used much.\n\t\t\t// We could re-arrange the tree so it would be faster.\n\t\t\tvar handlers = ensureMeta(this).handlers;\n\t\t\tvar keyHandlers = handlers.getNode([]);\n\t\t\tObject.keys(keyHandlers).forEach(function(key){\n\t\t\t\thandlers.delete([key,\"event\"]);\n\t\t\t});\n\t\t} else if (!handler && !queueName) {\n\t\t\tensureMeta(this).handlers.delete([key, \"event\"]);\n\t\t} else if (!handler) {\n\t\t\tensureMeta(this).handlers.delete([key, \"event\", queueName || \"mutate\"]);\n\t\t} else {\n\t\t\tensureMeta(this).handlers.delete([key, \"event\", queueName || \"mutate\", handler]);\n\t\t}\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.one one\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Register an event handler that gets called only once.\n\t *\n\t * @signature `obj.one(event, handler(event, args...) )`\n\t *\n\t * Adds a basic event listener that listens to an event once and only once.\n\t *\n\t * ```js\n\t * obj.one(\"prop\", function(){\n\t *   console.log(\"prop dispatched\");\n\t * })\n\t *\n\t * obj[canSymbol.for(\"prop\")](\"prop\") //-> logs \"prop dispatched\"\n\t * obj[canSymbol.for(\"prop\")](\"prop\")\n\t * ```\n\t *\n\t * @param {String} eventName The name of the event to listen to.\n\t * @param {Function} handler(event, args...) The handler that will be run when the\n\t *   event is dispached.\n\t * @return {Object} this\n\t */\n\tone: function(event, handler) {\n\t\t// Unbind the listener after it has been executed\n\t\tvar one = function() {\n\t\t\tlegacyMapBindings.off.call(this, event, one);\n\t\t\treturn handler.apply(this, arguments);\n\t\t};\n\n\t\t// Bind the altered listener\n\t\tlegacyMapBindings.on.call(this, event, one);\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.listenTo listenTo\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Listen to an event and register the binding for simplified unbinding.\n\t *\n\t * @signature `obj.listenTo([bindTarget,] event, handler)`\n\t *\n\t * `.listenTo` is useful for creating bindings that can can be torn down with\n\t * [can-event-queue/map/map.stopListening].  This is useful when creating\n\t * rich behaviors that can't be accomplished using computed values, or if you are trying to\n\t * avoid streams.\n\t *\n\t * For example, the following creates an observable that counts how many times its\n\t * `name` property has changed:\n\t *\n\t * ```js\n\t * class Person {\n\t *   constructor(){\n\t *     this.nameChanged = 0;\n\t *     this.listenTo(\"name\", function(){\n\t *       this.nameChanged++;\n\t *     })\n\t *   },\n\t *   setName(newVal) {\n\t *     this.name = newVal;\n\t *     this.dispatch(\"name\",[newVal])\n\t *   }\n\t * }\n\t * mixinMapBindings(Person.prototype);\n\t *\n\t * var person = new Person();\n\t * person.setName(\"Justin\");\n\t * person.setName(\"Ramiya\");\n\t * person.nameChanged //-> 2\n\t * ```\n\t *\n\t * `.listenTo` event bindings are stored on an observable and MUST be unbound using\n\t * [can-event-queue/map/map.stopListening]. `.stopListening` make it easy to unbind\n\t * all of the `.listenTo` event bindings when the observable is no longer needed:\n\t *\n\t * ```js\n\t * person.stopListening();\n\t * ```\n\t *\n\t * If no `bindTarget` is passed, `.listenTo` binds to the current\n\t * observable.\n\t *\n\t * [can-component]'s `connectedCallback` lifecyle hook is often used to call\n\t * `.listenTo` to setup bindings that update viewmodel properties.\n\t *\n\t *\n\t * @param {Object} [bindTarget] The object to listen for events on.  If `bindTarget` is not provided,\n\t * the observable `.listenTo` was called on will be the `bindTarget`.\n\t * @param {String} event The name of the event to listen for.\n\t * @param {Function} handler The handler that will be executed to handle the event.\n\t * @return {Object} this\n\t */\n\tlistenTo: function (bindTarget, event, handler, queueName) {\n\n\t\tif(canReflect.isPrimitive(bindTarget)) {\n\t\t\tqueueName = handler;\n\t\t\thandler = event;\n\t\t\tevent = bindTarget;\n\t\t\tbindTarget = this;\n\t\t}\n\n\t\tif(typeof event === \"function\") {\n\t\t\tqueueName = handler;\n\t\t\thandler = event;\n\t\t\tevent = undefined;\n\t\t}\n\n\t\t// Initialize event cache\n\t\tensureMeta(this).listenHandlers.add([bindTarget, event, queueName || \"mutate\", handler]);\n\n\t\tlegacyMapBindings.on.call(bindTarget, event, handler, queueName || \"mutate\");\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.stopListening stopListening\n\t * @parent can-event-queue/map/map\n\t * @description Stops listening for registered event handlers.\n\t *\n\t * @signature `obj.stopListening( [bindTarget], [event,] handler]] )`\n\t *\n\t * `.stopListening` unbinds on event handlers registered through\n\t * [can-event-queue/map/map.listenTo]. All event handlers\n\t * that match the arguments will be unbound. For example:\n\t *\n\t * ```js\n\t * // Unbinds all .listenTo registered handlers\n\t * obj.stopListening()\n\t *\n\t * // Unbinds all .listenTo registered with `bindTarget`\n\t * obj.stopListening(bindTarget)\n\t *\n\t * // Unbinds all .listenTo registered with `bindTarget`, `event`\n\t * obj.stopListening(bindTarget, event)\n\t *\n\t * // Unbinds the handler registered with `bindTarget`, `event`, `handler`\n\t * obj.stopListening(bindTarget, event, handler)\n\t * ```\n\t *\n\t * `.listenTo` is often returned by [can-component]'s `connectedCallback` lifecyle hook.\n\t *\n\t * @param {Object} [bindTarget] The object we will stop listening to event on. If `bindTarget` is\n\t * not provided, the observable `.stopListening` was called on will be the `bindTarget`.\n\t * @param {String} [event] The name of the event to listen for.\n\t * @param {Function} [handler] The handler that will be executed to handle the event.\n\t * @return {Object} this\n\t *\n\t */\n\tstopListening: function () {\n\t\tvar keys = stopListeningArgumentsToKeys.apply({context: this, defaultQueue: \"mutate\"}, arguments);\n\n\t\tvar listenHandlers = ensureMeta(this).listenHandlers;\n\n\t\tfunction deleteHandler(bindTarget, event, queue, handler){\n\t\t\tlegacyMapBindings.off.call(bindTarget, event, handler, queue);\n\t\t}\n\t\tlistenHandlers.delete(keys, deleteHandler);\n\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.on on\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description A shorthand method for listening to event.\n\t *\n\t * @signature `obj.on( event, handler [, queue] )`\n\t *\n\t * Listen to when `obj` dispatches an event, a [can-reflect/observe.onKeyValue]\n\t * change, or a [can-reflect/observe.onValue] change in that order.\n\t *\n\t * As this is the __legacy__ `.on`, it will look for an `.addEventListener`\n\t * method on the `obj` first, before looking for the [can-symbol/symbols/onKeyValue]\n\t * and then [can-symbol/symbols/onValue] symbol.\n\t *\n\t * @param {String} eventName\n\t * @param {Function} handler\n\t * @param {String} [queue]\n\t * @return {Any} The object `on` was called on.\n\t */\n\ton: function(eventName, handler, queue) {\n\t\tvar listenWithDOM = isDomEventTarget(this);\n\t\tif (listenWithDOM) {\n\t\t\tif (typeof handler === 'string') {\n\t\t\t\tdomEvents.addDelegateListener(this, eventName, handler, queue);\n\t\t\t} else {\n\t\t\t\tdomEvents.addEventListener(this, eventName, handler, queue);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this[onEventSymbol]) {\n\t\t\t\tthis[onEventSymbol](eventName, handler, queue);\n\t\t\t} else if (\"addEventListener\" in this) {\n\t\t\t\tthis.addEventListener(eventName, handler, queue);\n\t\t\t} else if (this[onKeyValueSymbol]) {\n\t\t\t\tcanReflect.onKeyValue(this, eventName, handler, queue);\n\t\t\t} else {\n\t\t\t\tif (!eventName && this[onValueSymbol]) {\n\t\t\t\t\tcanReflect.onValue(this, handler, queue);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"can-event-queue: Unable to bind \" + eventName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.off off\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description A shorthand method for unbinding an event.\n\t *\n\t * @signature `obj.on( event, handler [, queue] )`\n\t *\n\t * Listen to when `obj` dispatches an event, a [can-reflect/observe.onKeyValue]\n\t * change, or a [can-reflect/observe.onValue] change in that order.\n\t *\n\t * As this is the __legacy__ `.on`, it will look for an `.addEventListener`\n\t * method on the `obj` first, before looking for the [can-symbol/symbols/onKeyValue]\n\t * and then [can-symbol/symbols/onValue] symbol.\n\t *\n\t * @param {String} eventName\n\t * @param {Function} handler\n\t * @param {String} [queue]\n\t * @return {Any} The object `on` was called on.\n\t */\n\toff: function(eventName, handler, queue) {\n\t\tvar listenWithDOM = isDomEventTarget(this);\n\t\tif (listenWithDOM) {\n\t\t\tif (typeof handler === 'string') {\n\t\t\t\tdomEvents.removeDelegateListener(this, eventName, handler, queue);\n\t\t\t} else {\n\t\t\t\tdomEvents.removeEventListener(this, eventName, handler, queue);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this[offEventSymbol]) {\n\t\t\t\tthis[offEventSymbol](eventName, handler, queue);\n\t\t\t} else if (\"removeEventListener\" in this) {\n\t\t\t\tthis.removeEventListener(eventName, handler, queue);\n\t\t\t} else if (this[offKeyValueSymbol]) {\n\t\t\t\tcanReflect.offKeyValue(this, eventName, handler, queue);\n\t\t\t} else {\n\t\t\t\tif (!eventName && this[offValueSymbol]) {\n\t\t\t\t\tcanReflect.offValue(this, handler, queue);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"can-event-queue: Unable to unbind \" + eventName);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n};\n\n// The symbols we'll add to objects\nvar symbols = {\n\t/**\n\t * @function can-event-queue/map/map.can.onKeyValue @can.onKeyValue\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Register an event handler to be called when a key value changes.\n\t *\n\t * @signature `canReflect.onKeyValue( obj, key, handler(newVal) [,queueName] )`\n\t *\n\t * Add a key change handler to an object.  Handlers attached by `.onKeyValue` get\n\t * called back with the new value of the `key`. Handlers attached with [can-event-queue/map/map.can.addEventListener]\n\t * get the event object.\n\t *\n\t * ```js\n\t * var mixinMapBindings = require(\"can-event-queue/map/map\");\n\t *\n\t * var obj = mixinMapBindings({});\n\t *\n\t * canReflect.onKeyValue( obj, \"prop\", function(newPropValue){ ... });\n\t * ```\n\t *\n\t * @param {String} key The name of property to listen to changes in values.\n\t * @param {Function} handler(newVal, oldValue) The handler that will be called\n\t *   back with the new and old value of the key.\n\t * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler will called\n\t *   back within. Defaults to `\"mutate\"`.\n\t */\n\t\"can.onKeyValue\": function(key, handler, queueName) {\n\t\tensureMeta(this).handlers.add([key, \"onKeyValue\", queueName || \"mutate\", handler]);\n\t},\n\t/**\n\t * @function can-event-queue/map/map.can.offKeyValue @can.offKeyValue\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Unregister an event handler to be called when an event is dispatched.\n\t *\n\t * @signature `canReflect.offKeyValue( obj, key, handler, queueName )`\n\t *\n\t * Removes a handlers from being called when `key` changes are\n\t * [can-event-queue/map/map.dispatch]ed.\n\t *\n\t * ```js\n\t * // Removes `handler` if it is in the notify queue.\n\t * canReflect.offKeyValue( obj, \"prop\", handler, \"notify\" )\n\t * ```\n\t *\n\t * @param {String} eventName The name of the event to remove. If not specified, all events are removed.\n\t * @param {Function} [handler] The handler that will be removed from the event. If not specified, all handlers for the event are removed.\n\t * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler was registered on. Defaults to `\"mutate\"`.\n\t */\n\t\"can.offKeyValue\": function(key, handler, queueName) {\n\t\tensureMeta(this).handlers.delete([key, \"onKeyValue\", queueName || \"mutate\", handler]);\n\t},\n\t/**\n\t * @function can-event-queue/map/map.can.isBound @can.isBound\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Return if the observable is bound to.\n\t *\n\t * @signature `canReflect.isBound(obj)`\n\t *\n\t * The `@can.isBound` symbol is added to make [can-reflect/observe.isBound]\n\t * return if `obj` is bound or not.\n\t *\n\t * @return {Boolean} True if the observable has been bound to with `.onKeyValue` or `.addEventListener`.\n\t */\n\t\"can.isBound\": function() {\n\t\treturn !ensureMeta(this).handlers.isEmpty();\n\t},\n\t/**\n\t * @function can-event-queue/map/map.can.getWhatIChange @can.getWhatIChange\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Return observables whose values are affected by attached event handlers\n\t * @signature `@can.getWhatIChange(key)`\n\t *\n\t * The `@@can.getWhatIChange` symbol is added to make sure [can-debug] can report\n\t * all the observables whose values are set by a given observable's key.\n\t *\n\t * This function iterates over the event handlers attached to a given `key` and\n\t * collects the result of calling `@@can.getChangesDependencyRecord` on each handler;\n\t * this symbol allows the caller to tell what observables are being mutated by\n\t * the event handler when it is executed.\n\t *\n\t * In the following example a [can-simple-map] instance named `me` is created\n\t * and when its `age` property changes, the value of a [can-simple-observable]\n\t * instance is set. The event handler that causes the mutation is then decatorated\n\t * with `@@can.getChangesDependencyRecord` to register the mutation dependency.\n\t *\n\t * ```js\n\t * var obs = new SimpleObservable(\"a\");\n\t * var me = new SimpleMap({ age: 30 });\n\t * var canReflect = require(\"can-reflect\");\n\t *\n\t * var onAgeChange = function onAgeChange() {\n\t *\tcanReflect.setValue(obs, \"b\");\n\t * };\n\t *\n\t * onAgeChange[canSymbol.for(\"can.getChangesDependencyRecord\")] = function() {\n\t *\treturn {\n\t *\t\tvalueDependencies: new Set([ obs ]);\n\t *\t}\n\t * };\n\t *\n\t * canReflect.onKeyValue(me, \"age\", onAgeChange);\n\t * me[canSymbol.for(\"can.getWhatIChange\")](\"age\");\n\t * ```\n\t *\n\t * The dependency records collected from the event handlers are divided into\n\t * two categories:\n\t *\n\t * - mutate: Handlers in the mutate/domUI queues\n\t * - derive: Handlers in the notify queue\n\t *\n\t * Since event handlers are added by default to the \"mutate\" queue, calling\n\t * `@@can.getWhatIChange` on the `me` instance returns an object with a mutate\n\t * property and the `valueDependencies` Set registered on the `onAgeChange`\n\t * handler.\n\t *\n\t * Please check out the [can-reflect-dependencies] docs to learn more about\n\t * how this symbol is used to keep track of custom observable dependencies.\n\t */\n\t\"can.getWhatIChange\": function getWhatIChange(key) {\n\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\tvar whatIChange = {};\n\t\t\tvar meta = ensureMeta(this);\n\n\t\t\tvar notifyHandlers = [].concat(\n\t\t\t\tmeta.handlers.get([key, \"event\", \"notify\"]),\n\t\t\t\tmeta.handlers.get([key, \"onKeyValue\", \"notify\"])\n\t\t\t);\n\n\t\t\tvar mutateHandlers = [].concat(\n\t\t\t\tmeta.handlers.get([key, \"event\", \"mutate\"]),\n\t\t\t\tmeta.handlers.get([key, \"event\", \"domUI\"]),\n\t\t\t\tmeta.handlers.get([key, \"onKeyValue\", \"mutate\"]),\n\t\t\t\tmeta.handlers.get([key, \"onKeyValue\", \"domUI\"])\n\t\t\t);\n\n\t\t\tif (notifyHandlers.length) {\n\t\t\t\tnotifyHandlers.forEach(function(handler) {\n\t\t\t\t\tvar changes = canReflect.getChangesDependencyRecord(handler);\n\n\t\t\t\t\tif (changes) {\n\t\t\t\t\t\tvar record = whatIChange.derive;\n\t\t\t\t\t\tif (!record) {\n\t\t\t\t\t\t\trecord = (whatIChange.derive = {});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeDependencyRecords(record, changes);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (mutateHandlers.length) {\n\t\t\t\tmutateHandlers.forEach(function(handler) {\n\t\t\t\t\tvar changes = canReflect.getChangesDependencyRecord(handler);\n\n\t\t\t\t\tif (changes) {\n\t\t\t\t\t\tvar record = whatIChange.mutate;\n\t\t\t\t\t\tif (!record) {\n\t\t\t\t\t\t\trecord = (whatIChange.mutate = {});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeDependencyRecords(record, changes);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn Object.keys(whatIChange).length ? whatIChange : undefined;\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\t\"can.onPatches\": function(handler, queue) {\n\t\tvar handlers = ensureMeta(this).handlers;\n\t\thandlers.add([\"can.patches\", \"onKeyValue\", queue || \"notify\", handler]);\n\t},\n\t\"can.offPatches\": function(handler, queue) {\n\t\tvar handlers = ensureMeta(this).handlers;\n\t\thandlers.delete([\"can.patches\", \"onKeyValue\", queue || \"notify\", handler]);\n\t}\n};\n\n// This can be removed in a future version.\nfunction defineNonEnumerable(obj, prop, value) {\n\tObject.defineProperty(obj, prop, {\n\t\tenumerable: false,\n\t\tvalue: value\n\t});\n}\n\n// The actual legacyMapBindings mixin function\nlegacyMapBindings = function(obj) {\n\t// add properties\n\tcanReflect.assignMap(obj, props);\n\t// add symbols\n\treturn canReflect.assignSymbols(obj, symbols);\n};\n\ndefineNonEnumerable(legacyMapBindings, \"addHandlers\", addHandlers);\ndefineNonEnumerable(legacyMapBindings, \"stopListeningArgumentsToKeys\", stopListeningArgumentsToKeys);\n\n\n\n// ## LEGACY\n// The following is for compatability with the old can-event\nprops.bind = props.addEventListener;\nprops.unbind = props.removeEventListener;\n\n\n\n// Adds methods directly to method so it can be used like `can-event` used to be used.\ncanReflect.assignMap(legacyMapBindings, props);\ncanReflect.assignSymbols(legacyMapBindings, symbols);\n\ndefineNonEnumerable(legacyMapBindings, \"start\", function() {\n\tconsole.warn(\"use can-queues.batch.start()\");\n\tqueues.batch.start();\n});\ndefineNonEnumerable(legacyMapBindings, \"stop\", function() {\n\tconsole.warn(\"use can-queues.batch.stop()\");\n\tqueues.batch.stop();\n});\ndefineNonEnumerable(legacyMapBindings, \"flush\", function() {\n\tconsole.warn(\"use can-queues.flush()\");\n\tqueues.flush();\n});\n\ndefineNonEnumerable(legacyMapBindings, \"afterPreviousEvents\", function(handler) {\n\tconsole.warn(\"don't use afterPreviousEvents\");\n\tqueues.mutateQueue.enqueue(function afterPreviousEvents() {\n\t\tqueues.mutateQueue.enqueue(handler);\n\t});\n\tqueues.flush();\n});\n\ndefineNonEnumerable(legacyMapBindings, \"after\", function(handler) {\n\tconsole.warn(\"don't use after\");\n\tqueues.mutateQueue.enqueue(handler);\n\tqueues.flush();\n});\n\nmodule.exports = legacyMapBindings;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-event-queue/map/map.js?");

/***/ }),

/***/ "../../../../node_modules/can-event-queue/value/value.js":
/*!********************************************************************!*\
  !*** C:/Projects/game/node_modules/can-event-queue/value/value.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar queues = __webpack_require__(/*! can-queues */ \"../../../../node_modules/can-queues/can-queues.js\");\nvar KeyTree = __webpack_require__(/*! can-key-tree */ \"../../../../node_modules/can-key-tree/can-key-tree.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../../../node_modules/can-reflect/can-reflect.js\");\nvar defineLazyValue = __webpack_require__(/*! can-define-lazy-value */ \"../../../../node_modules/can-define-lazy-value/define-lazy-value.js\");\nvar mergeDependencyRecords = __webpack_require__(/*! ../dependency-record/merge */ \"../../../../node_modules/can-event-queue/dependency-record/merge.js\");\n\nvar properties = {\n\t/**\n\t * @function can-event-queue/value/value.on on\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Listen to changes in the observable's value.\n\t *\n\t * @signature `.on( handler[, queue='mutate'] )`\n\t *\n\t * This adds an event handler in the observable's [can-event-queue/value/value.handlers]\n\t * tree. If this is the first handler, the observable's [can-event-queue/value/value.onBound] method is called.\n\t *\n\t * ```js\n\t * observable.on(function(newVal){ ... });\n\t * observable.on(function(newVal){ ... }, \"notify\");\n\t * ```\n\t *\n\t * @param {function(*)} handler(newValue,oldValue) A handler that will be called with the new value of the\n\t * observable and optionally the old value of the observable.\n\t * @param {String} [queue] The [can-queues] queue this event handler should be bound to.  By default the handler will\n\t * be called within the `mutate` queue.\n\t */\n\ton: function(handler, queue) {\n\t\tthis.handlers.add([queue || \"mutate\", handler]);\n\t},\n\t/**\n\t * @function can-event-queue/value/value.off off\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Stop listening to changes in the observable's value.\n\t *\n\t * @signature `.off( [handler [, queue='mutate']] )`\n\t *\n\t * Removes one or more event handler in the observable's [can-event-queue/value/value.handlers]\n\t * tree. If the las handler is removed, the observable's [can-event-queue/value/value.onUnbound] method is called.\n\t *\n\t * ```js\n\t * observable.off(function(newVal){ ... });\n\t * observable.off(function(newVal){ ... }, \"notify\");\n\t * observable.off();\n\t * observable.off(undefined, \"mutate\");\n\t * ```\n\t *\n\t * @param {function(*)} handler(newValue,oldValue) The handler to be removed.  If no handler is provided and no\n\t * `queue` is provided, all handlers will be removed.\n\t * @param {String} [queue] The [can-queues] queue this event handler should be removed from.\n\t *\n\t *  If a `handler` is\n\t *  provided and no `queue` is provided, the `queue` will default to `\"mutate\"`.\n\t *\n\t *   If a `handler` is not provided, but a `queue` is provided, all handlers for the provided queue will be\n\t *   removed.\n\t */\n\toff: function(handler, queueName) {\n\t\tif (handler === undefined) {\n\t\t\tif (queueName === undefined) {\n\t\t\t\tthis.handlers.delete([]);\n\t\t\t} else {\n\t\t\t\tthis.handlers.delete([queueName]);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.handlers.delete([queueName || \"mutate\", handler]);\n\t\t}\n\t}\n};\n\nvar symbols = {\n\t/**\n\t * @function can-event-queue/value/value.can.onValue @can.onValue\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Listen to changes in this observable value.\n\t *\n\t * This is an alias for [can-event-queue/value/value.on].  It satisfies [can-reflect].[can-reflect/observe.onValue].\n\t */\n\t\"can.onValue\": properties.on,\n\t/**\n\t * @function can-event-queue/value/value.can.offValue @can.offValue\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Stop listening to changes in this observable value.\n\t *\n\t * This is an alias for [can-event-queue/value/value.off].  It satisfies [can-reflect].[can-reflect/observe.offValue].\n\t */\n\t\"can.offValue\": properties.off,\n\t/**\n\t * @function can-event-queue/value/value.can.dispatch @can.dispatch\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Dispatch all event handlers within their appropriate queues.\n\t *\n\t * @signature `@can.dispatch(newValue, oldValue)`\n\t *\n\t * This is a helper method that will dispatch all [can-event-queue/value/value.handlers] within\n\t * their appropriate [can-queues] queue.\n\t *\n\t * Furthermore, it will make sure the handlers include useful meta data for debugging.\n\t *\n\t * ```js\n\t * var observable = mixinValueBindings({});\n\t * observable[canSymbol.for(\"can.dispatch\")]( 2, 1 );\n\t * ```\n\t *\n\t * @param {Any} newValue The new value of the observable.\n\t * @param {Any} oldValue The old value of the observable.\n\t */\n\t\"can.dispatch\": function(value, old) {\n\t\tvar queuesArgs = [];\n\t\tqueuesArgs = [\n\t\t\tthis.handlers.getNode([]),\n\t\t\tthis,\n\t\t\t[value, old]\n\t\t];\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tqueuesArgs = [\n\t\t\t\tthis.handlers.getNode([]),\n\t\t\t\tthis,\n\t\t\t\t[value, old]\n\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\t, null\n\t\t\t\t, [canReflect.getName(this), \"changed to\", value, \"from\", old]\n\t\t\t\t/* jshint laxcomma: false */\n\t\t\t];\n\t\t}\n\t\t//!steal-remove-end\n\t\tqueues.enqueueByQueue.apply(queues, queuesArgs);\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tif (typeof this._log === \"function\") {\n\t\t\t\tthis._log(old, value);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\t/**\n\t * @function can-event-queue/value/value.can.getWhatIChange @can.getWhatIChange\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Return observables whose values are affected by attached event handlers\n\t * @signature `@can.getWhatIChange()`\n\t *\n\t * The `@@can.getWhatIChange` symbol is added to make sure [can-debug] can report\n\t * all the observables whose values are set by value-like observables.\n\t *\n\t * This function iterates over the event handlers attached to  the observable's value\n\t * event and collects the result of calling `@@can.getChangesDependencyRecord` on each\n\t * handler; this symbol allows the caller to tell what observables are being mutated\n\t * by the event handler when it is executed.\n\t *\n\t * In the following example a [can-simple-observable] instance named `month` is\n\t * created and when its value changes the `age` property of the `map` [can-simple-map]\n\t * instance is set. The event handler that causes the mutation is then decatorated with\n\t * `@@can.getChangesDependencyRecord` to register the mutation dependency.\n\t *\n\t * ```js\n\t * var month = new SimpleObservable(11);\n\t * var map = new SimpleMap({ age: 30 });\n\t * var canReflect = require(\"can-reflect\");\n\t *\n\t * var onValueChange = function onValueChange() {\n\t *\tmap.set(\"age\", 31);\n\t * };\n\t *\n\t * onValueChange[canSymbol.for(\"can.getChangesDependencyRecord\")] = function() {\n\t *\treturn {\n\t *\t\tkeyDependencies: new Map([ [map, new Set([\"age\"])] ])\n\t *\t}\n\t * };\n\t *\n\t * canReflect.onValue(month, onValueChange);\n\t * month[canSymbol.for(\"can.getWhatIChange\")]();\n\t * ```\n\t *\n\t * The dependency records collected from the event handlers are divided into\n\t * two categories:\n\t *\n\t * - mutate: Handlers in the mutate/domUI queues\n\t * - derive: Handlers in the notify queue\n\t *\n\t * Since event handlers are added by default to the \"mutate\" queue, calling\n\t * `@@can.getWhatIChange` on the `month` instance returns an object with a mutate\n\t * property and the `keyDependencies` Map registered on the `onValueChange` handler.\n\t *\n\t * If multiple event handlers were attached to `month`, the dependency records\n\t * of each handler are merged by `@@can.getWhatIChange`. Please check out the\n\t * [can-reflect-dependencies] docs to learn more about how this symbol is used\n\t * to keep track of custom observable dependencies.\n\t */\n\t\"can.getWhatIChange\": function getWhatIChange() {\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tvar whatIChange = {};\n\n\t\t\tvar notifyHandlers = this.handlers.get([\"notify\"]);\n\t\t\tvar mutateHandlers = [].concat(\n\t\t\t\tthis.handlers.get([\"mutate\"]),\n\t\t\t\tthis.handlers.get([\"domUI\"]),\n\t\t\t\tthis.handlers.get([\"dom\"])\n\t\t\t);\n\n\t\t\tif (notifyHandlers.length) {\n\t\t\t\tnotifyHandlers.forEach(function(handler) {\n\t\t\t\t\tvar changes = canReflect.getChangesDependencyRecord(handler);\n\n\t\t\t\t\tif (changes) {\n\t\t\t\t\t\tvar record = whatIChange.derive;\n\t\t\t\t\t\tif (!record) {\n\t\t\t\t\t\t\trecord = (whatIChange.derive = {});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeDependencyRecords(record, changes);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (mutateHandlers.length) {\n\t\t\t\tmutateHandlers.forEach(function(handler) {\n\t\t\t\t\tvar changes = canReflect.getChangesDependencyRecord(handler);\n\n\t\t\t\t\tif (changes) {\n\t\t\t\t\t\tvar record = whatIChange.mutate;\n\t\t\t\t\t\tif (!record) {\n\t\t\t\t\t\t\trecord = (whatIChange.mutate = {});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeDependencyRecords(record, changes);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn Object.keys(whatIChange).length ? whatIChange : undefined;\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\n\t/**\n\t * @function can-event-queue/value/value.can.isBound @can.isBound\n\t * @parent can-event-queue/value/value\n\t */\n\t\"can.isBound\": function isBound() {\n\t\treturn !this.handlers.isEmpty();\n\t}\n};\n\n/**\n * @property {can-key-tree} can-event-queue/value/value.handlers handlers\n * @parent can-event-queue/value/value\n *\n * @description Access the handlers tree directly.\n *\n * @type {can-key-tree}\n *\n *  The handlers property is a [can-define-lazy-value lazily] defined property containing\n *  all handlers bound with [can-event-queue/value/value.on] and\n *  [can-event-queue/value/value.can.onValue].  It is a [can-key-tree] defined like:\n *\n *  ```js\n *  this.handlers = new KeyTree([Object, Array])\n *  ```\n *\n *  It is configured to call [can-event-queue/value/value.onBound] and\n *  [can-event-queue/value/value.onUnbound] on the instances when the first item is\n *  added to the tree and when the tree is emptied.\n */\nfunction defineLazyHandlers(){\n\treturn new KeyTree([Object, Array], {\n\t\tonFirst: this.onBound !== undefined && this.onBound.bind(this),\n\t\tonEmpty: this.onUnbound !== undefined && this.onUnbound.bind(this)\n\t});\n}\n\n/**\n * @function can-event-queue/value/value.onBound onBound\n * @parent can-event-queue/value/value\n *\n * @description Perform operations when an observable is gains its first event handler.\n *\n * @signature `.onBound()`\n *\n * This method is not implemented by `can-event-queue/value/value`. Instead, the object\n * should implement it if it wants to perform some actions when it becomes bound.\n *\n * ```js\n * var mixinValueBindings = require(\"can-event-queue/value/value\");\n *\n * var observable = mixinValueBindings({\n *   onBound: function(){\n *     console.log(\"I AM BOUND!\");\n *   }\n * });\n *\n * observable.on(function(){});\n * // Logs: \"I AM BOUND!\"\n * ```\n *\n */\n\n/**\n * @function can-event-queue/value/value.onUnbound onUnbound\n * @parent can-event-queue/value/value\n *\n * @description Perform operations when an observable loses all of its event handlers.\n *\n * @signature `.onBound()`\n *\n * This method is not implemented by `can-event-queue/value/value`. Instead, the object\n * should implement it if it wants to perform some actions when it becomes unbound.\n *\n * ```js\n * var mixinValueBindings = require(\"can-event-queue/value/value\");\n *\n * var observable = mixinValueBindings({\n *   onUnbound: function(){\n *     console.log(\"I AM UNBOUND!\");\n *   }\n * });\n * var handler = function(){}\n * observable.on(function(){});\n * observable.off(function(){});\n * // Logs: \"I AM UNBOUND!\"\n * ```\n */\n\n/**\n * @module {function} can-event-queue/value/value\n * @parent can-event-queue\n *\n * @description Mixin methods and symbols to make this object or prototype object\n * behave like a single-value observable.\n *\n * @signature `mixinValueBindings( obj )`\n *\n * Adds symbols and methods that make `obj` or instances having `obj` on their prototype\n * behave like single-value observables.\n *\n * When `mixinValueBindings` is called on an `obj` like:\n *\n * ```js\n * var mixinValueBindings = require(\"can-event-queue/value/value\");\n *\n * var observable = mixinValueBindings({});\n *\n * observable.on(function(newVal, oldVal){\n *   console.log(newVal);\n * });\n *\n * observable[canSymbol.for(\"can.dispatch\")](2,1);\n * // Logs: 2\n * ```\n *\n * `mixinValueBindings` adds the following properties and symbols to the object:\n *\n * - [can-event-queue/value/value.on]\n * - [can-event-queue/value/value.off]\n * - [can-event-queue/value/value.can.dispatch]\n * - [can-event-queue/value/value.can.getWhatIChange]\n * - [can-event-queue/value/value.handlers]\n *\n * When the object is bound to for the first time with `.on` or `@can.onValue`, it will look for an [can-event-queue/value/value.onBound]\n * function on the object and call it.\n *\n * When the object is has no more handlers, it will look for an [can-event-queue/value/value.onUnbound]\n * function on the object and call it.\n */\nvar mixinValueEventBindings = function(obj) {\n\tcanReflect.assign(obj, properties);\n\tcanReflect.assignSymbols(obj, symbols);\n\tdefineLazyValue(obj,\"handlers\",defineLazyHandlers, true);\n\treturn obj;\n};\n\n// callbacks is optional\nmixinValueEventBindings.addHandlers = function(obj, callbacks) {\n\tconsole.warn(\"can-event-queue/value: Avoid using addHandlers. Add onBound and onUnbound methods instead.\");\n\tobj.handlers = new KeyTree([Object, Array], callbacks);\n\treturn obj;\n};\n\nmodule.exports = mixinValueEventBindings;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-event-queue/value/value.js?");

/***/ }),

/***/ "../../../../node_modules/can-globals/can-globals-instance.js":
/*!*************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-globals/can-globals-instance.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../../../node_modules/can-namespace/can-namespace.js\");\nvar Globals = __webpack_require__(/*! ./can-globals-proto */ \"../../../../node_modules/can-globals/can-globals-proto.js\");\nvar globals = new Globals();\n\nif (namespace.globals) {\n\tthrow new Error(\"You can't have two versions of can-globals, check your dependencies\");\n} else {\n\tmodule.exports = namespace.globals = globals;\n}\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-globals/can-globals-instance.js?");

/***/ }),

/***/ "../../../../node_modules/can-globals/can-globals-proto.js":
/*!**********************************************************************!*\
  !*** C:/Projects/game/node_modules/can-globals/can-globals-proto.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../../../node_modules/can-reflect/can-reflect.js\");\n\nfunction dispatch(key) {\n\t// jshint -W040\n\tvar handlers = this.eventHandlers[key];\n\tif (handlers) {\n\t\tvar handlersCopy = handlers.slice();\n\t\tvar value = this.getKeyValue(key);\n\t\tfor (var i = 0; i < handlersCopy.length; i++) {\n\t\t\thandlersCopy[i](value);\n\t\t}\n\t}\n}\n\nfunction Globals() {\n\tthis.eventHandlers = {};\n\tthis.properties = {};\n}\n\n/**\n * @function define \n * @parent can-globals/methods\n * \n * Create a new global environment variable.\n * \n * @signature `globals.define(key, value[, cache])`\n * \n * Defines a new global called `key`, who's value defaults to `value`.\n * \n * The following example defines the `global` key's default value to the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window) object:\n * ```javascript\n * globals.define('global', window);\n * globals.getKeyValue('window') //-> window\n * ```\n * \n * If a function is provided and `cache` is falsy, that function is run every time the key value is read:\n * ```javascript\n * globals.define('isBrowserWindow', function() {\n *   console.log('EVALUATING')\n *   return typeof window !== 'undefined' &&\n *     typeof document !== 'undefined' && typeof SimpleDOM === 'undefined'\n * }, false);\n * globals.get('isBrowserWindow') // logs 'EVALUATING'\n *                                // -> true\n * globals.get('isBrowserWindow') // logs 'EVALUATING' again\n *                                // -> true\n * ```\n * \n * If a function is provided and `cache` is truthy, that function is run only the first time the value is read:\n * ```javascript\n * globals.define('isWebkit', function() {\n *   console.log('EVALUATING')\n *   var div = document.createElement('div')\n *   return 'WebkitTransition' in div.style\n * })\n * globals.getKeyValue('isWebkit') // logs 'EVALUATING'\n * \t\t\t\t\t\t\t\t   // -> true\n * globals.getKeyValue('isWebkit') // Does NOT log again!\n * \t\t\t\t\t\t\t\t   // -> true\n * ```\n * \n * @param {String} key\n * The key value to create.\n * \n * @param {*} value\n * The default value. If this is a function, its return value will be used.\n * \n * @param {Boolean} [cache=true]\n * Enable cache. If false the `value` function is run every time the key value is read.\n * \n * @return {can-globals}\n * Returns the instance of `can-globals` for chaining.\n */\nGlobals.prototype.define = function (key, value, enableCache) {\n\tif (enableCache === undefined) {\n\t\tenableCache = true;\n\t}\n\tif (!this.properties[key]) {\n\t\tthis.properties[key] = {\n\t\t\tdefault: value,\n\t\t\tvalue: value,\n\t\t\tenableCache: enableCache\n\t\t};\n\t}\n\treturn this;\n};\n\n/**\n * @function getKeyValue \n * @parent can-globals/methods\n * \n * Get a global environment variable by name.\n * \n * @signature `globals.getKeyValue(key)`\n * \n * Returns the current value at `key`. If no value has been set, it will return the default value (if it is not a function). If the default value is a function, it will return the output of the function. This execution is cached if the cache flag was set on initialization.\n * \n * ```javascript\n * globals.define('foo', 'bar');\n * globals.getKeyValue('foo'); //-> 'bar'\n * ```\n * \n * @param {String} key\n * The key value to access.\n * \n * @return {*}\n * Returns the value of a given key.\n */\nGlobals.prototype.getKeyValue = function (key) {\n\tvar property = this.properties[key];\n\tif (property) {\n\t\tif (typeof property.value === 'function') {\n\t\t\tif (property.cachedValue) {\n\t\t\t\treturn property.cachedValue;\n\t\t\t}\n\t\t\tif (property.enableCache) {\n\t\t\t\tproperty.cachedValue = property.value();\n\t\t\t\treturn property.cachedValue;\n\t\t\t} else {\n\t\t\t\treturn property.value();\n\t\t\t}\n\t\t}\n\t\treturn property.value;\n\t}\n};\n\nGlobals.prototype.makeExport = function (key) {\n\treturn function (value) {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.getKeyValue(key);\n\t\t}\n\n\t\tif (typeof value === 'undefined' || value === null) {\n\t\t\tthis.deleteKeyValue(key);\n\t\t} else {\n\t\t\tif (typeof value === 'function') {\n\t\t\t\tthis.setKeyValue(key, function () {\n\t\t\t\t\treturn value;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.setKeyValue(key, value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}.bind(this);\n};\n\n/**\n * @function offKeyValue \n * @parent can-globals/methods\n * \n * Remove handler from event queue.\n * \n * @signature `globals.offKeyValue(key, handler)`\n * \n * Removes `handler` from future change events for `key`.\n * \n * \n * ```javascript\n * var handler = (value) => {\n *   value === 'baz' //-> true\n * };\n * globals.define('foo', 'bar');\n * globals.onKeyValue('foo', handler);\n * globals.setKeyValue('foo', 'baz');\n * globals.offKeyValue('foo', handler);\n * ```\n * \n * @param {String} key\n * The key value to observe.\n * \n * @param {Function} handler([value])\n * The observer callback.\n * \n * @return {can-globals}\n * Returns the instance of `can-globals` for chaining.\n */\nGlobals.prototype.offKeyValue = function (key, handler) {\n\tif (this.properties[key]) {\n\t\tvar handlers = this.eventHandlers[key];\n\t\tif (handlers) {\n\t\t\tvar i = handlers.indexOf(handler);\n\t\t\thandlers.splice(i, 1);\n\t\t}\n\t}\n\treturn this;\n};\n\n/**\n * @function onKeyValue \n * @parent can-globals/methods\n * \n * Add handler to event queue.\n * \n * @signature `globals.onKeyValue(key, handler)`\n * \n * Calls `handler` each time the value of `key` is set or reset.\n * \n * ```javascript\n * globals.define('foo', 'bar');\n * globals.onKeyValue('foo', (value) => {\n *   value === 'baz' //-> true\n * });\n * globals.setKeyValue('foo', 'baz');\n * ```\n * \n * @param {String} key\n * The key value to observe.\n * \n * @param {function(*)} handler([value])\n * The observer callback.\n * \n * @return {can-globals}\n * Returns the instance of `can-globals` for chaining.\n */\nGlobals.prototype.onKeyValue = function (key, handler) {\n\tif (this.properties[key]) {\n\t\tif (!this.eventHandlers[key]) {\n\t\t\tthis.eventHandlers[key] = [];\n\t\t}\n\t\tthis.eventHandlers[key].push(handler);\n\t}\n\treturn this;\n};\n\n/**\n * @function deleteKeyValue \n * @parent can-globals/methods\n * \n * Reset global environment variable.\n * \n * @signature `globals.deleteKeyValue(key)`\n * \n * Deletes the current value at `key`. Future `get`s will use the default value.\n * \n * ```javascript\n * globals.define('global', window);\n * globals.setKeyValue('global', {});\n * globals.deleteKeyValue('global');\n * globals.getKeyValue('global') === window; //-> true\n * ```\n * \n * @param {String} key\n * The key value to access.\n * \n * @return {can-globals}\n * Returns the instance of `can-globals` for chaining.\n */\nGlobals.prototype.deleteKeyValue = function (key) {\n\tvar property = this.properties[key];\n\tif (property !== undefined) {\n\t\tproperty.value = property.default;\n\t\tproperty.cachedValue = undefined;\n\t\tdispatch.call(this, key);\n\t}\n\treturn this;\n};\n\n/**\n * @function setKeyValue \n * @parent can-globals/methods\n * \n * Overwrite an existing global environment variable.\n * \n * @signature `globals.setKeyValue(key, value)`\n * \n * ```javascript\n * globals.define('foo', 'bar');\n * globals.setKeyValue('foo', 'baz');\n * globals.getKeyValue('foo'); //-> 'baz'\n * ```\n * \n * Sets the new value at `key`. Will override previously set values, but preserves the default (see `deleteKeyValue`).\n * \n * Setting a key which was not previously defined will call `define` with the key and value.\n * \n * @param {String} key\n * The key value to access.\n * \n * @param {*} value\n * The new value.\n * \n * @return {can-globals}\n * Returns the instance of `can-globals` for chaining.\n */\nGlobals.prototype.setKeyValue = function (key, value) {\n\tif (!this.properties[key]) {\n\t\treturn this.define(key, value);\n\t}\n\tvar property = this.properties[key];\n\tproperty.value = value;\n\tproperty.cachedValue = undefined;\n\tdispatch.call(this, key);\n\treturn this;\n};\n\n/**\n * @function reset \n * @parent can-globals/methods\n * \n * Reset all keys to their default value and clear their caches.\n * \n * @signature `globals.setKeyValue(key, value)`\n * \n * ```javascript\n * globals.define('foo', 'bar');\n * globals.setKeyValue('foo', 'baz');\n * globals.getKeyValue('foo'); //-> 'baz'\n * globals.reset();\n * globals.getKeyValue('foo'); //-> 'bar'\n * ```\n * \n * @return {can-globals}\n * Returns the instance of `can-globals` for chaining.\n */\nGlobals.prototype.reset = function () {\n\tfor (var key in this.properties) {\n\t\tif (this.properties.hasOwnProperty(key)) {\n\t\t\tthis.properties[key].value = this.properties[key].default;\n\t\t\tthis.properties[key].cachedValue = undefined;\n\t\t\tdispatch.call(this, key);\n\t\t}\n\t}\n\treturn this;\n};\n\ncanReflect.assignSymbols(Globals.prototype, {\n\t'can.getKeyValue': Globals.prototype.getKeyValue,\n\t'can.setKeyValue': Globals.prototype.setKeyValue,\n\t'can.deleteKeyValue': Globals.prototype.deleteKeyValue,\n\t'can.onKeyValue': Globals.prototype.onKeyValue,\n\t'can.offKeyValue': Globals.prototype.offKeyValue\n});\n\nmodule.exports = Globals;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-globals/can-globals-proto.js?");

/***/ }),

/***/ "../../../../node_modules/can-globals/can-globals.js":
/*!****************************************************************!*\
  !*** C:/Projects/game/node_modules/can-globals/can-globals.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"../../../../node_modules/can-globals/can-globals-instance.js\");\n\n__webpack_require__(/*! ./global/global */ \"../../../../node_modules/can-globals/global/global.js\");\n__webpack_require__(/*! ./document/document */ \"../../../../node_modules/can-globals/document/document.js\");\n__webpack_require__(/*! ./location/location */ \"../../../../node_modules/can-globals/location/location.js\");\n__webpack_require__(/*! ./mutation-observer/mutation-observer */ \"../../../../node_modules/can-globals/mutation-observer/mutation-observer.js\");\n__webpack_require__(/*! ./is-browser-window/is-browser-window */ \"../../../../node_modules/can-globals/is-browser-window/is-browser-window.js\");\n__webpack_require__(/*! ./is-node/is-node */ \"../../../../node_modules/can-globals/is-node/is-node.js\");\n__webpack_require__(/*! ./custom-elements/custom-elements */ \"../../../../node_modules/can-globals/custom-elements/custom-elements.js\");\n\nmodule.exports = globals;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-globals/can-globals.js?");

/***/ }),

/***/ "../../../../node_modules/can-globals/custom-elements/custom-elements.js":
/*!************************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-globals/custom-elements/custom-elements.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! can-globals/global/global */ \"../../../../node_modules/can-globals/global/global.js\");\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"../../../../node_modules/can-globals/can-globals-instance.js\");\n\n/**\n * @module {function} can-globals/custom-elements/custom-elements custom-elements\n * @parent can-globals/modules\n *\n * Get the global [`customElements`](https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements) object for the current context.\n *\n * @signature `CUSTOMELEMENTS([newCustomElements])`\n *\n * Optionally sets, and returns, the [`customElements`](https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements) object for the context.\n *\n * ```js\n * var customElementsShim = require('some-custom-elements-shim');\n * CUSTOMELEMENTS(customElementsShim);\n * CUSTOMELEMENTS() //-> customElementsShim\n * ```\n *\n * @param {Object} customElements An optional CustomElementRegistry-like object to set as the context's customElements\n *\n * @return {Object} The customElements object for this JavaScript environment.\n */\n\nglobals.define('customElements', function(){\n\tvar GLOBAL = globals.getKeyValue('global');\n\treturn GLOBAL.customElements;\n});\n\nmodule.exports = globals.makeExport('customElements');\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-globals/custom-elements/custom-elements.js?");

/***/ }),

/***/ "../../../../node_modules/can-globals/document/document.js":
/*!**********************************************************************!*\
  !*** C:/Projects/game/node_modules/can-globals/document/document.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! can-globals/global/global */ \"../../../../node_modules/can-globals/global/global.js\");\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"../../../../node_modules/can-globals/can-globals-instance.js\");\n\n/**\n * @module {function} can-globals/document/document document\n * @parent can-globals/modules\n * \n * Get the global [`document`](https://developer.mozilla.org/en-US/docs/Web/API/document) object for the current context.\n * \n * @signature `DOCUMENT([newDocument])`\n * \n * Optionally sets, and returns, the [`document`](https://developer.mozilla.org/en-US/docs/Web/API/document) object for the context.\n * \n * ```js\n * var documentShim = { getElementById() {...} };\n * var DOCUMENT = require('can-globals/document/document');\n * DOCUMENT(documentShim); //-> document\n * DOCUMENT().getElementById('foo');\n * ```\n *\n * @param {Object} [newDocument] An optional document-like object to set as the context's document \n * \n * @return {Object} The window object for this JavaScript environment.\n */\nglobals.define('document', function(){\n\treturn globals.getKeyValue('global').document;\n});\n\nmodule.exports = globals.makeExport('document');\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-globals/document/document.js?");

/***/ }),

/***/ "../../../../node_modules/can-globals/global/global.js":
/*!******************************************************************!*\
  !*** C:/Projects/game/node_modules/can-globals/global/global.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, global) {\n\n/* global self */\n/* global WorkerGlobalScope */\n\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"../../../../node_modules/can-globals/can-globals-instance.js\");\n\n/**\n * @module {function} can-globals/global/global global\n * @parent can-globals/modules\n * \n * Get the global object for the current context.\n * \n * @signature `GLOBAL([newGlobal])`\n *\n * Optionally sets, and returns the global that this environment provides. It will be one of:\n * \n * ```js\n * var GLOBAL = require('can-globals/global/global');\n * var g = GLOBAL();\n * // In a browser\n * console.log(g === window); // -> true\n * ```\n *\n * - **Browser**: [`window`](https://developer.mozilla.org/en-US/docs/Web/API/window)\n * - **Web Worker**: [`self`](https://developer.mozilla.org/en-US/docs/Web/API/Window/self)\n * - **Node.js**: [`global`](https://nodejs.org/api/globals.html#globals_global)\n * \n * @param {Object} [newGlobal] An optional global-like object to set as the context's global \n *\n * @return {Object} The global object for this JavaScript environment.\n */\nglobals.define('global', function(){\n\t// Web Worker\n\treturn (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) ? self :\n\n\t\t// Node.js\n\t\ttypeof process === 'object' &&\n\t\t{}.toString.call(process) === '[object process]' ? global :\n\n\t\t// Browser window\n\t\twindow;\n});\n\nmodule.exports = globals.makeExport('global');\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"../../../../node_modules/process/browser.js\"), __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"../../../../node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-globals/global/global.js?");

/***/ }),

/***/ "../../../../node_modules/can-globals/is-browser-window/is-browser-window.js":
/*!****************************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-globals/is-browser-window/is-browser-window.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"../../../../node_modules/can-globals/can-globals-instance.js\");\n\n// This module depends on isNode being defined\n__webpack_require__(/*! ../is-node/is-node */ \"../../../../node_modules/can-globals/is-node/is-node.js\");\n\n/**\n * @module {function} can-globals/is-browser-window/is-browser-window is-browser-window\n * @parent can-globals/modules\n * @signature `isBrowserWindow()`\n *\n * Returns `true` if the code is running within a Browser window. Use this function if you need special code paths for when running in a Browser window, a Web Worker, or another environment (such as Node.js).\n *\n * ```js\n * var isBrowserWindow = require(\"can-globals/is-browser-window/is-browser-window\");\n * var GLOBAL = require(\"can-globals/global/global\");\n *\n * if(isBrowserWindow()) {\n *   console.log(GLOBAL() === window); // -> true\n * }\n * ```\n *\n * @return {Boolean} True if the environment is a Browser window.\n */\n\nglobals.define('isBrowserWindow', function(){\n\tvar isNode = globals.getKeyValue('isNode');\n\treturn typeof window !== \"undefined\" &&\n\t\ttypeof document !== \"undefined\" &&\n\t\tisNode === false;\n});\n\nmodule.exports = globals.makeExport('isBrowserWindow');\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-globals/is-browser-window/is-browser-window.js?");

/***/ }),

/***/ "../../../../node_modules/can-globals/is-node/is-node.js":
/*!********************************************************************!*\
  !*** C:/Projects/game/node_modules/can-globals/is-node/is-node.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"../../../../node_modules/can-globals/can-globals-instance.js\");\n\n/**\n * @module {function} can-globals/is-node/is-node is-node\n * @parent can-globals/modules\n * @description Determines if your code is running in [Node.js](https://nodejs.org).\n * @signature `isNode()`\n *\n * ```js\n * var isNode = require(\"can-globals/is-node/is-node\");\n * var GLOBAL = require(\"can-globals/global/global\");\n *\n * if(isNode()) {\n *   console.log(GLOBAL() === global); // -> true\n * }\n * ```\n *\n * @return {Boolean} True if running in Node.js\n */\n\nglobals.define('isNode', function(){\n\treturn typeof process === \"object\" &&\n\t\t{}.toString.call(process) === \"[object process]\";\n});\n\nmodule.exports = globals.makeExport('isNode');\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"../../../../node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-globals/is-node/is-node.js?");

/***/ }),

/***/ "../../../../node_modules/can-globals/location/location.js":
/*!**********************************************************************!*\
  !*** C:/Projects/game/node_modules/can-globals/location/location.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! can-globals/global/global */ \"../../../../node_modules/can-globals/global/global.js\");\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"../../../../node_modules/can-globals/can-globals-instance.js\");\n\n/**\n * @module {function} can-globals/location/location location\n * @parent can-globals/modules\n * \n * Get the global [`location`](https://developer.mozilla.org/en-US/docs/Web/API/Window/location) object for the current context.\n * \n * @signature `LOCATION([newLocation])`\n * \n * Optionally sets, and returns, the [`location`](https://developer.mozilla.org/en-US/docs/Web/API/Window/location) object for the context.\n * \n * ```js\n * var locationShim = { path: '/' };\n * var LOCATION = require('can-globals/location/location');\n * LOCATION(locationShim);\n * LOCATION().path; // -> '/'\n * ```\n *\n * @param {Object} location An optional location-like object to set as the context's location\n *\n * @return {Object} The location object for this JavaScript environment.\n */\nglobals.define('location', function(){\n\treturn globals.getKeyValue('global').location;\n});\n\nmodule.exports = globals.makeExport('location');\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-globals/location/location.js?");

/***/ }),

/***/ "../../../../node_modules/can-globals/mutation-observer/mutation-observer.js":
/*!****************************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-globals/mutation-observer/mutation-observer.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! can-globals/global/global */ \"../../../../node_modules/can-globals/global/global.js\");\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"../../../../node_modules/can-globals/can-globals-instance.js\");\n\n/**\n * @module {function} can-globals/mutation-observer/mutation-observer mutation-observer\n * @parent can-globals/modules\n * \n * Get the global [`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) object for the current context.\n * \n * @signature `MUTATIONOBSERVER([newMutationObserver])`\n * \n * Optionally sets, and returns, the [`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) object for the context.\n * \n * ```js\n * var mutationObserverShim = require('can-globals/mutation-observer/mutation-observer');\n * MUTATIONOBSERVER(mutationObserverShim);\n * MUTATIONOBSERVER() //-> MutationObserver\n * ```\n *\n * @param {Object} MutationObserver An optional MutationObserver-like object to set as the context's MutationObserver\n *\n * @return {Object} The MutationObserver object for this JavaScript environment.\n */\n\nglobals.define('MutationObserver', function(){\n\tvar GLOBAL = globals.getKeyValue('global');\n\treturn GLOBAL.MutationObserver || GLOBAL.WebKitMutationObserver || GLOBAL.MozMutationObserver;\n});\n\nmodule.exports = globals.makeExport('MutationObserver');\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-globals/mutation-observer/mutation-observer.js?");

/***/ }),

/***/ "../../../../node_modules/can-key-tree/can-key-tree.js":
/*!******************************************************************!*\
  !*** C:/Projects/game/node_modules/can-key-tree/can-key-tree.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar reflect = __webpack_require__( /*! can-reflect */ \"../../../../node_modules/can-reflect/can-reflect.js\" );\n\n// ## Helpers\n// The following implement helper functions useful to `can-key-tree`'s main methods.\n\n// ### isBuiltInPrototype\n// Returns if `obj` is the prototype of a built-in JS type like `Map`.\n// Built in types' `toString` returns `[object TYPENAME]`.\nfunction isBuiltInPrototype ( obj ) {\n\tif ( obj === Object.prototype ) {\n\t\treturn true;\n\t}\n\tvar protoString = Object.prototype.toString.call( obj );\n\tvar isNotObjObj = protoString !== '[object Object]';\n\tvar isObjSomething = protoString.indexOf( '[object ' ) !== -1;\n\treturn isNotObjObj && isObjSomething;\n}\n\n// ### getDeepSize\n// Recursively returns the number of leaf values below `root` node.\nfunction getDeepSize ( root, level ) {\n\tif ( level === 0 ) {\n\t\treturn reflect.size( root );\n\t} else if ( reflect.size( root ) === 0 ) {\n\t\treturn 0;\n\t} else {\n\t\tvar count = 0;\n\t\treflect.each( root, function ( value ) {\n\t\t\tcount += getDeepSize( value, level - 1 );\n\t\t});\n\t\treturn count;\n\t}\n}\n\n// ### getDeep\n// Adds all leaf values under `node` to `items`.\n// `depth` is how deep `node` is in the tree.\n// `maxDepth` is the total depth of the tree structure.\nfunction getDeep ( node, items, depth, maxDepth ) {\n\tif ( !node ) {\n\t\treturn;\n\t}\n\tif ( maxDepth === depth ) {\n\t\tif ( reflect.isMoreListLikeThanMapLike( node ) ) {\n\t\t\treflect.addValues( items, reflect.toArray( node ) );\n\t\t} else {\n\t\t\tthrow new Error( \"can-key-tree: Map-type leaf containers are not supported yet.\" );\n\t\t}\n\t} else {\n\t\treflect.each( node, function ( value ) {\n\t\t\tgetDeep( value, items, depth + 1, maxDepth );\n\t\t});\n\t}\n}\n\n// ### clearDeep\n// Recursively removes value from all child nodes of `node`.\nfunction clearDeep ( node, keys, maxDepth, deleteHandler ) {\n\tif ( maxDepth === keys.length ) {\n\t\tif ( reflect.isMoreListLikeThanMapLike( node ) ) {\n\t\t\tvar valuesToRemove = reflect.toArray( node );\n\t\t\tif(deleteHandler) {\n\t\t\t\tvaluesToRemove.forEach(function(value){\n\t\t\t\t\tdeleteHandler.apply(null, keys.concat(value));\n\t\t\t\t});\n\t\t\t}\n\t\t\treflect.removeValues( node, valuesToRemove );\n\t\t} else {\n\t\t\tthrow new Error( \"can-key-tree: Map-type leaf containers are not supported yet.\" );\n\t\t}\n\t} else {\n\t\treflect.each( node, function ( value, key ) {\n\t\t\tclearDeep( value, keys.concat(key), maxDepth, deleteHandler );\n\t\t\treflect.deleteKeyValue( node, key );\n\t\t});\n\t}\n}\n\n// ## KeyTree\n// Creates an instance of the KeyTree.\nvar KeyTree = function ( treeStructure, callbacks ) {\n\tvar FirstConstructor = treeStructure[0];\n\tif ( reflect.isConstructorLike( FirstConstructor ) ) {\n\t\tthis.root = new FirstConstructor();\n\t} else {\n\t\tthis.root = FirstConstructor;\n\t}\n\tthis.callbacks = callbacks || {};\n\tthis.treeStructure = treeStructure;\n\t// An extra bit of state held for performance\n\tthis.empty = true;\n};\n\n// ## Methods\nreflect.assign(KeyTree.prototype,{\n    // ### Add\n    add: function ( keys ) {\n    \tif ( keys.length > this.treeStructure.length ) {\n    \t\tthrow new Error( \"can-key-tree: Can not add path deeper than tree.\" );\n    \t}\n        // The place we will add the final leaf value.\n    \tvar place = this.root;\n\n        // Record if the root was empty so we know to call `onFirst`.\n    \tvar rootWasEmpty = this.empty === true;\n\n        // For each key, try to get the corresponding childNode.\n        for ( var i = 0; i < keys.length - 1; i++ ) {\n    \t\tvar key = keys[i];\n    \t\tvar childNode = reflect.getKeyValue( place, key );\n    \t\tif ( !childNode ) {\n                // If there is no childNode, create it and add it to the parent node.\n    \t\t\tvar Constructor = this.treeStructure[i + 1];\n    \t\t\tif ( isBuiltInPrototype( Constructor.prototype ) ) {\n    \t\t\t\tchildNode = new Constructor();\n    \t\t\t} else {\n    \t\t\t\tchildNode = new Constructor( key );\n    \t\t\t}\n    \t\t\treflect.setKeyValue( place, key, childNode );\n    \t\t}\n    \t\tplace = childNode;\n    \t}\n\n        // Add the final leaf value in the tree.\n    \tif ( reflect.isMoreListLikeThanMapLike( place ) ) {\n    \t\treflect.addValues( place, [keys[keys.length - 1]] );\n    \t} else {\n    \t\tthrow new Error( \"can-key-tree: Map types are not supported yet.\" );\n    \t}\n\n        // Callback `onFirst` if appropriate.\n    \tif ( rootWasEmpty ) {\n\t\t\tthis.empty = false;\n\t\t\tif(this.callbacks.onFirst) {\n\t\t\t\tthis.callbacks.onFirst.call( this );\n\t\t\t}\n\n    \t}\n\n    \treturn this;\n    },\n    // ### getNode\n    getNode: function ( keys ) {\n        var node = this.root;\n        // For each key, try to read the child node.\n        // If a child is not found, return `undefined`.\n        for ( var i = 0; i < keys.length; i++ ) {\n            var key = keys[i];\n            node = reflect.getKeyValue( node, key );\n            if ( !node ) {\n                return;\n            }\n        }\n        return node;\n    },\n    // ### get\n    get: function ( keys ) {\n        // Get the node specified by keys.\n    \tvar node = this.getNode( keys );\n\n        // If it's a leaf, return it.\n    \tif ( this.treeStructure.length === keys.length ) {\n    \t\treturn node;\n    \t} else {\n    \t\t// Otherwise, create a container for leaf values and\n            // recursively walk the node's children.\n    \t\tvar Type = this.treeStructure[this.treeStructure.length - 1];\n    \t\tvar items = new Type();\n    \t\tgetDeep( node, items, keys.length, this.treeStructure.length - 1 );\n    \t\treturn items;\n    \t}\n    },\n    // ### delete\n    delete: function ( keys, deleteHandler ) {\n\n        // `parentNode` will eventually be the parent nodde of the\n        // node specified by keys.\n        var parentNode = this.root,\n            // The nodes traversed to the node specified by `keys`.\n            path = [this.root],\n            lastKey = keys[keys.length - 1];\n\n        // Set parentNode to the node specified by keys\n        // and record the nodes in `path`.\n        for ( var i = 0; i < keys.length - 1; i++ ) {\n    \t\tvar key = keys[i];\n    \t\tvar childNode = reflect.getKeyValue( parentNode, key );\n    \t\tif ( childNode === undefined ) {\n    \t\t\treturn false;\n    \t\t} else {\n    \t\t\tpath.push( childNode );\n    \t\t}\n    \t\tparentNode = childNode;\n    \t}\n\n\n        // Depending on which keys were specified and the content of the\n        // key, do various cleanups ...\n        if ( !keys.length ) {\n            // If there are no keys, recursively clear the entire tree.\n    \t\tclearDeep( parentNode, [], this.treeStructure.length - 1, deleteHandler );\n    \t}\n        else if ( keys.length === this.treeStructure.length ) {\n            // If removing a leaf, remove that value.\n    \t\tif ( reflect.isMoreListLikeThanMapLike( parentNode ) ) {\n\t\t\t\tif(deleteHandler) {\n\t\t\t\t\tdeleteHandler.apply(null, keys.concat(lastKey));\n\t\t\t\t}\n    \t\t\treflect.removeValues( parentNode, [lastKey] );\n    \t\t} else {\n    \t\t\tthrow new Error( \"can-key-tree: Map types are not supported yet.\" );\n    \t\t}\n    \t}\n        else {\n            // If removing a node 'within' the tree, recursively clear\n            // that node and then delete the key from parent to node.\n            var nodeToRemove = reflect.getKeyValue( parentNode, lastKey );\n    \t\tif ( nodeToRemove !== undefined ) {\n    \t\t\tclearDeep( nodeToRemove, keys, this.treeStructure.length - 1, deleteHandler );\n    \t\t\treflect.deleteKeyValue( parentNode, lastKey );\n    \t\t} else {\n    \t\t\treturn false;\n    \t\t}\n    \t}\n\n        // After deleting the node, check if its parent is empty and\n        // recursively prune parent nodes that are now empty.\n    \tfor ( i = path.length - 2; i >= 0; i-- ) {\n    \t\tif ( reflect.size( parentNode ) === 0 ) {\n    \t\t\tparentNode = path[i];\n    \t\t\treflect.deleteKeyValue( parentNode, keys[i] );\n    \t\t} else {\n    \t\t\tbreak;\n    \t\t}\n    \t}\n        // Call `onEmpty` if the tree is now empty.\n    \tif (  reflect.size( this.root ) === 0 ) {\n\t\t\tthis.empty = true;\n\t\t\tif(this.callbacks.onEmpty) {\n\t\t\t\tthis.callbacks.onEmpty.call( this );\n\t\t\t}\n    \t}\n    \treturn true;\n    },\n    // ### size\n    // Recursively count the number of leaf values.\n    size: function () {\n    \treturn getDeepSize( this.root, this.treeStructure.length - 1 );\n    },\n\tisEmpty: function(){\n\t\treturn this.empty;\n\t}\n});\n\nmodule.exports = KeyTree;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-key-tree/can-key-tree.js?");

/***/ }),

/***/ "../../../../node_modules/can-key/get/get.js":
/*!********************************************************!*\
  !*** C:/Projects/game/node_modules/can-key/get/get.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../../../node_modules/can-reflect/can-reflect.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"../../../../node_modules/can-key/utils.js\");\n\n/**\n * @module {function} can-key/get/get\n * @parent can-key\n * @description Get properties on deep/nested objects of different types: Object, Map, [can-reflect] types, etc.\n *\n * @signature `get(obj, path)`\n * @param  {Object} obj the object to use as the root for property-based navigation\n * @param  {String} path a String of dot-separated keys, representing a path of properties\n * @return {*}       the value at the property path\n *\n * @body\n *\n * A *path* is a dot-delimited sequence of zero or more property names, such that \"foo.bar\" means \"the property\n * 'bar' of the object at the property 'foo' of the root.\"  An empty path returns the object passed.\n *\n * ```js\n * var get = require(\"can-key\");\n * console.log(get({a: {b: {c: \"foo\"}}}, \"a.b.c\")); // -> \"foo\"\n * console.log(get({a: {}}, \"a.b.c\")); // -> undefined\n * console.log(get([{a: {}}, {a: {b: \"bar\"}}], \"a.b\")); // -> \"bar\"\n *\n * var map = new Map();\n * map.set(\"first\", {second: \"third\"});\n *\n * get(map, \"first.second\") //-> \"third\"\n * ```\n */\nfunction get(obj, name) {\n    // The parts of the name we are looking up\n    // `['App','Models','Recipe']`\n    var parts = utils.parts(name);\n\n    var length = parts.length,\n        current, i, container;\n\n    if (!length) {\n        return obj;\n    }\n\n    current = obj;\n\n    // Walk current to the 2nd to last object or until there\n    // is not a container.\n    for (i = 0; i < length && utils.isContainer(current) && current !== null; i++) {\n        container = current;\n        current = canReflect.getKeyValue( container, parts[i] );\n    }\n\n    return current;\n}\n\nmodule.exports = get;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-key/get/get.js?");

/***/ }),

/***/ "../../../../node_modules/can-key/utils.js":
/*!******************************************************!*\
  !*** C:/Projects/game/node_modules/can-key/utils.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar utils = {\n    isContainer: function (current) {\n        var type = typeof current;\n        return current && (type === \"object\" || type === \"function\");\n    },\n    strReplacer: /\\{([^\\}]+)\\}/g,\n\n    parts: function(name) {\n        if(Array.isArray(name)) {\n            return name;\n        } else {\n            return typeof name !== 'undefined' ? (name + '').replace(/\\[/g,'.')\n            \t\t.replace(/]/g,'').split('.') : [];\n        }\n    }\n};\n\nmodule.exports= utils;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-key/utils.js?");

/***/ }),

/***/ "../../../../node_modules/can-log/can-log.js":
/*!********************************************************!*\
  !*** C:/Projects/game/node_modules/can-log/can-log.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.warnTimeout = 5000;\nexports.logLevel = 0;\n\n/**\n * @module {{}} can-log log\n * @parent can-js-utilities\n * @collection can-infrastructure\n * @hide\n *\n * Utilities for logging to the console.\n */\n\n/**\n * @function can-log.warn warn\n * @parent can-log\n * @description\n *\n * Adds a warning message to the console.\n *\n * ```\n * var canLog = require(\"can-log\");\n *\n * canLog.warn(\"something evil\");\n * ```\n *\n * @signature `canLog.warn(msg)`\n * @param {String} msg the message to be logged.\n */\nexports.warn = function() {\n\tvar ll = this.logLevel;\n\tif (ll < 2) {\n\t\tif (typeof console !== \"undefined\" && console.warn) {\n\t\t\tthis._logger(\"warn\", Array.prototype.slice.call(arguments));\n\t\t} else if (typeof console !== \"undefined\" && console.log) {\n\t\t\tthis._logger(\"log\", Array.prototype.slice.call(arguments));\n\t\t}\n\t}\n};\n\n/**\n * @function can-log.log log\n * @parent can-log\n * @description\n * Adds a message to the console.\n * @hide\n *\n * ```\n * var canLog = require(\"can-log\");\n *\n * canLog.log(\"hi\");\n * ```\n *\n * @signature `canLog.log(msg)`\n * @param {String} msg the message\n */\nexports.log = function() {\n\tvar ll = this.logLevel;\n\tif (ll < 1) {\n\t\tif (typeof console !== \"undefined\" && console.log) {\n\t\t\tthis._logger(\"log\", Array.prototype.slice.call(arguments));\n\t\t}\n\t}\n};\n\n/**\n * @function can-log.error error\n * @parent can-log\n * @description\n * Adds an error message to the console.\n * @hide\n *\n * ```\n * var canLog = require(\"can-log\");\n *\n * canLog.error(new Error(\"Oh no!\"));\n * ```\n *\n * @signature `canLog.error(err)`\n * @param {String|Error} err The error to be logged.\n */\nexports.error = function() {\n\tvar ll = this.logLevel;\n\tif (ll < 1) {\n\t\tif (typeof console !== \"undefined\" && console.error) {\n\t\t\tthis._logger(\"error\", Array.prototype.slice.call(arguments));\n\t\t}\n\t}\n};\n\nexports._logger = function (type, arr) {\n\ttry {\n\t\tconsole[type].apply(console, arr);\n\t} catch(e) {\n\t\tconsole[type](arr);\n\t}\n};\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-log/can-log.js?");

/***/ }),

/***/ "../../../../node_modules/can-log/dev/dev.js":
/*!********************************************************!*\
  !*** C:/Projects/game/node_modules/can-log/dev/dev.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar canLog = __webpack_require__(/*! ../can-log */ \"../../../../node_modules/can-log/can-log.js\");\n\n/**\n * @module {{}} can-log/dev dev\n * @parent can-log\n * @hide\n * \n * Utilities for logging development-mode messages. Use this module for\n * anything that should be shown to the user during development but isn't\n * needed in production. In production these functions become noops.\n */\nmodule.exports = {\n\twarnTimeout: 5000,\n\tlogLevel: 0,\n\t/**\n\t * @function can-log/dev.stringify stringify\n\t * @parent can-log\n\t * @description\n\t * @hide\n\t *\n\t * JSON stringifies a value, but unlike JSON, will output properties with\n\t * a value of `undefined` (e.g. `{ \"prop\": undefined }`, not `{}`).\n\t *\n\t * ```\n\t * var dev = require('can-log/dev');\n\t * var query = { where: undefined };\n\t * \n\t * dev.warn('No records found: ' + dev.stringify(query));\n\t * ```\n\t *\n\t * @signature `dev.stringify(value)`\n\t * @param {Any} value A value to stringify.\n\t * @return {String} A stringified representation of the passed in value.\n\t */\n\tstringify: function(value) {\n\t\tvar flagUndefined = function flagUndefined(key, value) {\n\t\t\treturn value === undefined ?\n\t\t\t\t \"/* void(undefined) */\" : value;\n\t\t};\n\t\t\n\t\treturn JSON.stringify(value, flagUndefined, \"  \").replace(\n\t\t\t/\"\\/\\* void\\(undefined\\) \\*\\/\"/g, \"undefined\");\n\t},\n\t/**\n\t * @function can-log/dev.warn warn\n\t * @parent can-log\n\t * @description\n\t * @hide\n\t *\n\t * Adds a warning message to the console.\n\t *\n\t * ```\n\t * var dev = require('can-log/dev');\n\t * \n\t * dev.warn(\"something evil\");\n\t * ```\n\t *\n\t * @signature `dev.warn(msg)`\n\t * @param {String} msg The warning message.\n\t */\n\twarn: function() {\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tcanLog.warn.apply(this, arguments);\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\t/**\n\t * @function can-log/dev.log log\n\t * @parent can-log\n\t * @description\n\t * @hide\n\t *\n\t * Adds a message to the console.\n\t *\n\t * ```\n\t * var dev = require('can-log/dev');\n\t * \n\t * dev.log(\"hi\");\n\t * ```\n\t *\n\t * @signature `dev.log(msg)`\n\t * @param {String} msg The message.\n\t */\n\tlog: function() {\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tcanLog.log.apply(this, arguments);\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\t/**\n\t * @function can-log/dev.error error\n\t * @parent can-log\n\t * @description\n\t * @hide\n\t *\n\t * Adds an error message to the console.\n\t *\n\t * ```\n\t * var dev = require(\"can-log/dev\");\n\t * \n\t * dev.error(new Error(\"Oh no!\"));\n\t * ```\n\t *\n\t * @signature `dev.error(err)`\n\t * @param {String|Error} err The error to be logged.\n\t */\n\terror: function() {\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tcanLog.error.apply(this, arguments);\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\t_logger: canLog._logger\n};\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-log/dev/dev.js?");

/***/ }),

/***/ "../../../../node_modules/can-namespace/can-namespace.js":
/*!********************************************************************!*\
  !*** C:/Projects/game/node_modules/can-namespace/can-namespace.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {};\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-namespace/can-namespace.js?");

/***/ }),

/***/ "../../../../node_modules/can-observation-recorder/can-observation-recorder.js":
/*!******************************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-observation-recorder/can-observation-recorder.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../../../node_modules/can-namespace/can-namespace.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../../../node_modules/can-symbol/can-symbol.js\");\n\n// Contains stack of observation records created by pushing with `.start`\n// and popping with `.stop()`.\n// The top of the stack is the \"target\" observation record - the record that calls\n// to `ObservationRecorder.add` get added to.\nvar stack = [];\n\nvar addParentSymbol = canSymbol.for(\"can.addParent\"),\n\tgetValueSymbol = canSymbol.for(\"can.getValue\");\n\nvar ObservationRecorder = {\n\tstack: stack,\n\tstart: function(name) {\n\t\tvar deps = {\n\t\t\tkeyDependencies: new Map(),\n\t\t\tvalueDependencies: new Set(),\n\t\t\tchildDependencies: new Set(),\n\n\t\t\t// `traps` and `ignore` are here only for performance\n\t\t\t// reasons. They work with `ObservationRecorder.ignore` and `ObservationRecorder.trap`.\n\t\t\ttraps: null,\n\t\t\tignore: 0,\n\t\t\tname: name\n\t\t};\n\n\t\tstack.push(deps);\n\n\t\treturn deps;\n\t},\n\tstop: function() {\n\t\treturn stack.pop();\n\t},\n\n\tadd: function(obj, event) {\n\t\tvar top = stack[stack.length - 1];\n\t\tif (top && top.ignore === 0) {\n\n\t\t\tif (top.traps) {\n\t\t\t\ttop.traps.push([obj, event]);\n\t\t\t} else {\n\t\t\t\t// Use `=== undefined` instead of `arguments.length` for performance.\n\t\t\t\tif (event === undefined) {\n\t\t\t\t\ttop.valueDependencies.add(obj);\n\t\t\t\t} else {\n\t\t\t\t\tvar eventSet = top.keyDependencies.get(obj);\n\t\t\t\t\tif (!eventSet) {\n\t\t\t\t\t\teventSet = new Set();\n\t\t\t\t\t\ttop.keyDependencies.set(obj, eventSet);\n\t\t\t\t\t}\n\t\t\t\t\teventSet.add(event);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\taddMany: function(observes) {\n\t\tvar top = stack[stack.length - 1];\n\t\tif (top) {\n\t\t\tif (top.traps) {\n\t\t\t\ttop.traps.push.apply(top.traps, observes);\n\t\t\t} else {\n\t\t\t\tfor (var i = 0, len = observes.length; i < len; i++) {\n\t\t\t\t\tthis.add(observes[i][0], observes[i][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcreated: function(obs) {\n\t\tvar top = stack[stack.length - 1];\n\t\tif (top) {\n\t\t\ttop.childDependencies.add(obs);\n\t\t\tif (obs[addParentSymbol]) {\n\t\t\t\tobs[addParentSymbol](top);\n\t\t\t}\n\t\t}\n\t},\n\tignore: function(fn) {\n\t\treturn function() {\n\t\t\tif (stack.length) {\n\t\t\t\tvar top = stack[stack.length - 1];\n\t\t\t\ttop.ignore++;\n\t\t\t\tvar res = fn.apply(this, arguments);\n\t\t\t\ttop.ignore--;\n\t\t\t\treturn res;\n\t\t\t} else {\n\t\t\t\treturn fn.apply(this, arguments);\n\t\t\t}\n\t\t};\n\t},\n\tpeekValue: function(value) {\n\t\tif(!value || !value[getValueSymbol]) {\n\t\t\treturn value;\n\t\t}\n\t\tif (stack.length) {\n\t\t\tvar top = stack[stack.length - 1];\n\t\t\ttop.ignore++;\n\t\t\tvar res = value[getValueSymbol]();\n\t\t\ttop.ignore--;\n\t\t\treturn res;\n\t\t} else {\n\t\t\treturn value[getValueSymbol]();\n\t\t}\n\t},\n\tisRecording: function() {\n\t\tvar len = stack.length;\n\t\tvar last = len && stack[len - 1];\n\t\treturn last && (last.ignore === 0) && last;\n\t},\n\t// `can-observation` uses this to do diffs more easily.\n\tmakeDependenciesRecord: function(name) {\n\t\treturn {\n\t\t\ttraps: null,\n\t\t\tkeyDependencies: new Map(),\n\t\t\tvalueDependencies: new Set(),\n\t\t\t//childDependencies: new Set(),\n\t\t\tignore: 0,\n\t\t\tname: name\n\t\t};\n\t},\n\t// The following are legacy methods we should do away with.\n\tmakeDependenciesRecorder: function() {\n\t\treturn ObservationRecorder.makeDependenciesRecord();\n\t},\n\t// Traps should be replace by calling `.start()` and `.stop()`.\n\t// To do this, we'd need a method that accepts a dependency record.\n\ttrap: function() {\n\t\tif (stack.length) {\n\t\t\tvar top = stack[stack.length - 1];\n\t\t\tvar oldTraps = top.traps;\n\t\t\tvar traps = top.traps = [];\n\t\t\treturn function() {\n\t\t\t\ttop.traps = oldTraps;\n\t\t\t\treturn traps;\n\t\t\t};\n\t\t} else {\n\t\t\treturn function() {\n\t\t\t\treturn [];\n\t\t\t};\n\t\t}\n\t},\n\ttrapsCount: function() {\n\t\tif (stack.length) {\n\t\t\tvar top = stack[stack.length - 1];\n\t\t\treturn top.traps.length;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n};\n\nif (namespace.ObservationRecorder) {\n\tthrow new Error(\"You can't have two versions of can-observation-recorder, check your dependencies\");\n} else {\n\tmodule.exports = namespace.ObservationRecorder = ObservationRecorder;\n}\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-observation-recorder/can-observation-recorder.js?");

/***/ }),

/***/ "../../../../node_modules/can-observation/can-observation.js":
/*!************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-observation/can-observation.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* global require */\n// # can-observation\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../../../node_modules/can-namespace/can-namespace.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../../../node_modules/can-reflect/can-reflect.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../../../node_modules/can-queues/can-queues.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../../../node_modules/can-observation-recorder/can-observation-recorder.js\");\n\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../../../node_modules/can-symbol/can-symbol.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../../../node_modules/can-log/dev/dev.js\");\nvar valueEventBindings = __webpack_require__(/*! can-event-queue/value/value */ \"../../../../node_modules/can-event-queue/value/value.js\");\n\nvar recorderHelpers = __webpack_require__(/*! ./recorder-dependency-helpers */ \"../../../../node_modules/can-observation/recorder-dependency-helpers.js\");\nvar temporarilyBind = __webpack_require__(/*! ./temporarily-bind */ \"../../../../node_modules/can-observation/temporarily-bind.js\");\n\nvar dispatchSymbol = canSymbol.for(\"can.dispatch\");\nvar getChangesSymbol = canSymbol.for(\"can.getChangesDependencyRecord\");\nvar getValueDependenciesSymbol = canSymbol.for(\"can.getValueDependencies\");\n\n// ## Observation constructor\nfunction Observation(func, context, options){\n\tthis.deriveQueue = queues.deriveQueue;\n\n\tthis.func = func;\n\tthis.context = context;\n\tthis.options = options || {priority: 0, isObservable: true};\n\t// A flag if we are bound or not\n\tthis.bound = false;\n\n\t// Set _value to undefined so can-view-scope & can-compute can check for it\n\tthis._value = undefined;\n\n\t// These properties will manage what our new and old dependencies are.\n\tthis.newDependencies = ObservationRecorder.makeDependenciesRecord();\n\tthis.oldDependencies = null;\n\n\t// Make functions we need to pass around and maintain `this`.\n\tvar self = this;\n\tthis.onDependencyChange = function(newVal){\n\t\tself.dependencyChange(this, newVal);\n\t};\n\tthis.update = this.update.bind(this);\n\n\n\t// Add debugging names.\n\t//!steal-remove-start\n\tif (true) {\n\t\tthis.onDependencyChange[getChangesSymbol] = function getChanges() {\n\t\t\tvar s = new Set();\n\t\t\ts.add(self);\n\t\t\treturn {\n\t\t\t\tvalueDependencies: s\n\t\t\t};\n\t\t};\n\t\tObject.defineProperty(this.onDependencyChange, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".onDependencyChange\",\n\t\t});\n\t\tObject.defineProperty(this.update, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".update\",\n\t\t});\n\t\tthis._name = canReflect.getName(this); // cached for performance\n\t}\n\t//!steal-remove-end\n}\n\n// ## Observation prototype methods\n\n// Mixin value event bindings. This is where the following are added:\n// - `.handlers` which call `onBound` and `onUnbound`\n// - `.on` / `.off`\n// - `can.onValue` `can.offValue`\n// - `can.getWhatIChange`\nvalueEventBindings(Observation.prototype);\n\ncanReflect.assign(Observation.prototype, {\n\t// Starts observing changes and adds event listeners.\n\tonBound: function(){\n\t\tthis.bound = true;\n\n\t\t// Store the old dependencies\n\t\tthis.oldDependencies = this.newDependencies;\n\t\t// Start recording dependencies.\n\t\tObservationRecorder.start(this._name);\n\t\t// Call the observation's function and update the new value.\n\t\tthis._value = this.func.call(this.context);\n\t\t// Get the new dependencies.\n\t\tthis.newDependencies = ObservationRecorder.stop();\n\n\t\t// Diff and update the bindings. On change, everything will call\n\t\t// `this.onDependencyChange`, which calls `this.dependencyChange`.\n\t\trecorderHelpers.updateObservations(this);\n\t},\n\t// This is called when any of the dependencies change.\n\t// It queues up an update in the `deriveQueue` to be run after all source\n\t// observables have had time to notify all observables that \"derive\" their value.\n\tdependencyChange: function(context, args){\n\t\tif(this.bound === true) {\n\t\t\tvar queuesArgs = [];\n\t\t\tqueuesArgs = [\n\t\t\t\tthis.update,\n\t\t\t\tthis,\n\t\t\t\t[],\n\t\t\t\t{\n\t\t\t\t\tpriority: this.options.priority,\n\t\t\t\t\telement: this.options.element\n\t\t\t\t}\n\t\t\t];\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tqueuesArgs = [\n\t\t\t\t\tthis.update,\n\t\t\t\t\tthis,\n\t\t\t\t\t[],\n\t\t\t\t\t{\n\t\t\t\t\t\tpriority: this.options.priority,\n\t\t\t\t\t\telement: this.options.element\n\t\t\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\t\t\t, log: [ canReflect.getName(this.update) ]\n\t\t\t\t\t\t/* jshint laxcomma: false */\n\t\t\t\t\t}\n\t\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\t\t, [canReflect.getName(context), \"changed\"]\n\t\t\t\t\t/* jshint laxcomma: false */\n\t\t\t\t];\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\t// Update this observation after all `notify` tasks have been run.\n\t\t\tthis.deriveQueue.enqueue.apply(this.deriveQueue, queuesArgs);\n\t\t}\n\t},\n\t// Called to update its value as part of the `derive` queue.\n\tupdate: function() {\n\t\tif (this.bound === true) {\n\t\t\t// Keep the old value.\n\t\t\tvar oldValue = this._value;\n\t\t\tthis.oldValue = null;\n\t\t\t// Re-run `this.func` and update dependency bindings.\n\t\t\tthis.onBound();\n\t\t\t// If our value changed, call the `dispatch` method provided by `can-event-queue/value/value`.\n\t\t\tif (oldValue !== this._value) {\n\t\t\t\tthis[dispatchSymbol](this._value, oldValue);\n\t\t\t}\n\t\t}\n\t},\n\t// Called when nothing is bound to this observation.\n\t// Removes all event listeners on all dependency observables.\n\tonUnbound: function(){\n\t\tthis.bound = false;\n\t\trecorderHelpers.stopObserving(this.newDependencies, this.onDependencyChange);\n\t\t// Setup newDependencies in case someone binds again to this observable.\n\t\tthis.newDependencies = ObservationRecorder.makeDependenciesRecord();\n\t},\n\t// Reads the value of the observation.\n\tget: function(){\n\n\t\t// If an external observation is tracking observables and\n\t\t// this compute can be listened to by \"function\" based computes ....\n\t\tif( this.options.isObservable && ObservationRecorder.isRecording() ) {\n\n\t\t\t// ... tell the tracking compute to listen to change on this observation.\n\t\t\tObservationRecorder.add(this);\n\t\t\t// ... if we are not bound, we should bind so that\n\t\t\t// we don't have to re-read to get the value of this observation.\n\t\t\tif (this.bound === false) {\n\t\t\t\tObservation.temporarilyBind(this);\n\t\t\t}\n\n\t\t}\n\n\n\t\tif(this.bound === true ) {\n\t\t\t// It's possible that a child dependency of this observable might be queued\n\t\t\t// to change. Check all child dependencies and make sure they are up-to-date by\n\t\t\t// possibly running what they have registered in the derive queue.\n\t\t\tif(this.deriveQueue.tasksRemainingCount() > 0) {\n\t\t\t\tObservation.updateChildrenAndSelf(this);\n\t\t\t}\n\n\t\t\treturn this._value;\n\t\t} else {\n\t\t\t// If we are not bound, just call the function.\n\t\t\treturn this.func.call(this.context);\n\t\t}\n\t},\n\n\thasDependencies: function(){\n\t\tvar newDependencies = this.newDependencies;\n\t\treturn this.bound ?\n\t\t\t(newDependencies.valueDependencies.size + newDependencies.keyDependencies.size) > 0  :\n\t\t\tundefined;\n\t},\n\tlog: function() {\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tvar quoteString = function quoteString(x) {\n\t\t\t\treturn typeof x === \"string\" ? JSON.stringify(x) : x;\n\t\t\t};\n\t\t\tthis._log = function(previous, current) {\n\t\t\t\tdev.log(\n\t\t\t\t\tcanReflect.getName(this),\n\t\t\t\t\t\"\\n is  \", quoteString(current),\n\t\t\t\t\t\"\\n was \", quoteString(previous)\n\t\t\t\t);\n\t\t\t};\n\t\t}\n\t\t//!steal-remove-end\n\t}\n});\n\nObject.defineProperty(Observation.prototype, \"value\", {\n\tget: function() {\n\t\treturn this.get();\n\t}\n});\n\nvar observationProto = {\n\t\"can.getValue\": Observation.prototype.get,\n\t\"can.isValueLike\": true,\n\t\"can.isMapLike\": false,\n\t\"can.isListLike\": false,\n\t\"can.valueHasDependencies\": Observation.prototype.hasDependencies,\n\t\"can.getValueDependencies\": function(){\n\t\tif (this.bound === true) {\n\t\t\t// Only provide `keyDependencies` and `valueDependencies` properties\n\t\t\t// if there's actually something there.\n\t\t\tvar deps = this.newDependencies,\n\t\t\t\tresult = {};\n\n\t\t\tif (deps.keyDependencies.size) {\n\t\t\t\tresult.keyDependencies = deps.keyDependencies;\n\t\t\t}\n\n\t\t\tif (deps.valueDependencies.size) {\n\t\t\t\tresult.valueDependencies = deps.valueDependencies;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\treturn undefined;\n\t},\n\t\"can.getPriority\": function(){\n\t\treturn this.options.priority;\n\t},\n\t\"can.setPriority\": function(priority){\n\t\tthis.options.priority = priority;\n\t},\n\t\"can.setElement\": function(element) {\n\t\tthis.options.element = element;\n\t\tthis.deriveQueue = queues.domQueue || queues.deriveQueue;\n\t}\n};\n\n//!steal-remove-start\nif (true) {\n\tobservationProto[\"can.getName\"] = function() {\n\t\treturn canReflect.getName(this.constructor) + \"<\" + canReflect.getName(this.func) + \">\";\n\t};\n}\n//!steal-remove-end\ncanReflect.assignSymbols(Observation.prototype, observationProto);\n\n// ## Observation.updateChildrenAndSelf\n// This recursively checks if an observation's dependencies might be in the `derive` queue.\n// If it is, we need to update that value so the reading of this value will be correct.\n// This can happen if an observation suddenly switches to depending on something that has higher\n// priority than itself.  We need to make sure that value is completely updated.\nObservation.updateChildrenAndSelf = function(observation){\n\t// If the observable has an `update` method and it's enqueued, flush that task immediately so\n\t// the value is right.\n\t// > NOTE: This only works for `Observation` right now.  We need a way of knowing how\n\t// > to find what an observable might have in the `deriveQueue`.\n\tif(observation.update !== undefined && observation.deriveQueue.isEnqueued( observation.update ) === true) {\n\t\t// TODO: In the future, we should be able to send log information\n\t\t// to explain why this needed to be updated.\n\t\tobservation.deriveQueue.flushQueuedTask(observation.update);\n\t\treturn true;\n\t}\n\n\t// If we can get dependency values from this observable ...\n\tif(observation[getValueDependenciesSymbol]) {\n\t\t// ... Loop through each dependency and see if any of them (or their children) needed an update.\n\t\tvar childHasChanged = false;\n\t\tvar valueDependencies = observation[getValueDependenciesSymbol]().valueDependencies || [];\n\t\tvalueDependencies.forEach(function(observable){\n\t\t\tif( Observation.updateChildrenAndSelf( observable ) === true) {\n\t\t\t\tchildHasChanged = true;\n\t\t\t}\n\t\t});\n\t\treturn childHasChanged;\n\t} else {\n\t\treturn false;\n\t}\n};\n\n// ## Legacy Stuff\n// Warn when `ObservationRecorder` methods are called on `Observation`.\nvar alias = {addAll: \"addMany\"};\n[\"add\",\"addAll\",\"ignore\",\"trap\",\"trapsCount\",\"isRecording\"].forEach(function(methodName){\n\tObservation[methodName] = function(){\n\t\tvar name = alias[methodName] ? alias[methodName] : methodName;\n\t\tconsole.warn(\"can-observation: Call \"+name+\"() on can-observation-recorder.\");\n\t\treturn ObservationRecorder[name].apply(this, arguments);\n\t};\n});\nObservation.prototype.start = function(){\n\tconsole.warn(\"can-observation: Use .on and .off to bind.\");\n\treturn this.onBound();\n};\nObservation.prototype.stop = function(){\n\tconsole.warn(\"can-observation: Use .on and .off to bind.\");\n\treturn this.onUnbound();\n};\n\n// ### temporarilyBind\n// Will bind an observable value temporarily.  This should be part of queues probably.\nObservation.temporarilyBind = temporarilyBind;\n\n\nmodule.exports = namespace.Observation = Observation;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-observation/can-observation.js?");

/***/ }),

/***/ "../../../../node_modules/can-observation/recorder-dependency-helpers.js":
/*!************************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-observation/recorder-dependency-helpers.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// # Recorder Dependency Helpers\n// This exposes two helpers:\n// - `updateObservations` - binds and unbinds a diff of two observation records\n//   (see can-observation-recorder for details on this data type).\n// - `stopObserving` - unbinds an observation record.\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../../../node_modules/can-reflect/can-reflect.js\");\n\n\n\n// ## Helpers\n// The following helpers all use `this` to pass additional arguments. This\n// is for performance reasons as it avoids creating new functions.\n\nfunction addNewKeyDependenciesIfNotInOld(event) {\n    // Expects `this` to have:\n    // - `.observable` - the observable we might be binding to.\n    // - `.oldEventSet` - the bound keys on the old dependency record for `observable`.\n    // - `.onDependencyChange` - the handler we will call back when the key is changed.\n    // If there wasn't any keys, or when we tried to delete we couldn't because the key\n    // wasn't in the set, start binding.\n    if(this.oldEventSet === undefined || this.oldEventSet[\"delete\"](event) === false) {\n        canReflect.onKeyValue(this.observable, event, this.onDependencyChange,\"notify\");\n    }\n}\n\n// ### addObservablesNewKeyDependenciesIfNotInOld\n// For each event in the `eventSet` of new observables,\n// setup a binding (or delete the key).\nfunction addObservablesNewKeyDependenciesIfNotInOld(eventSet, observable){\n    eventSet.forEach(addNewKeyDependenciesIfNotInOld, {\n        onDependencyChange: this.onDependencyChange,\n        observable: observable,\n        oldEventSet: this.oldDependencies.keyDependencies.get(observable)\n    });\n}\n\nfunction removeKeyDependencies(event) {\n    canReflect.offKeyValue(this.observable, event, this.onDependencyChange,\"notify\");\n}\n\nfunction removeObservablesKeyDependencies(oldEventSet, observable){\n    oldEventSet.forEach(removeKeyDependencies, {onDependencyChange: this.onDependencyChange, observable: observable});\n}\n\nfunction addValueDependencies(observable) {\n    // If we were unable to delete the key in the old set, setup a binding.\n    if(this.oldDependencies.valueDependencies.delete(observable) === false) {\n        canReflect.onValue(observable, this.onDependencyChange,\"notify\");\n    }\n}\nfunction removeValueDependencies(observable) {\n    canReflect.offValue(observable, this.onDependencyChange,\"notify\");\n}\n\n\nmodule.exports = {\n    // ## updateObservations\n    //\n    // Binds `observationData.onDependencyChange` to dependencies in `observationData.newDependencies` that are not currently in\n    // `observationData.oldDependencies`.  Anything in `observationData.oldDependencies`\n    // left over is unbound.\n    //\n    // The algorthim works by:\n    // 1. Loop through the `new` dependencies, checking if an equivalent is in the `old` bindings.\n    //    - If there is an equivalent binding, delete that dependency from `old`.\n    //    - If there is __not__ an equivalent binding, setup a binding from that dependency to `.onDependencyChange`.\n    // 2. Loop through the remaining `old` dependencies, teardown bindings.\n    //\n    // For performance, this method mutates the values in `.oldDependencies`.\n    updateObservations: function(observationData){\n        observationData.newDependencies.keyDependencies.forEach(addObservablesNewKeyDependenciesIfNotInOld, observationData);\n        observationData.oldDependencies.keyDependencies.forEach(removeObservablesKeyDependencies, observationData);\n        observationData.newDependencies.valueDependencies.forEach(addValueDependencies, observationData);\n        observationData.oldDependencies.valueDependencies.forEach(removeValueDependencies, observationData);\n    },\n    stopObserving: function(observationReciever, onDependencyChange){\n        observationReciever.keyDependencies.forEach(removeObservablesKeyDependencies, {onDependencyChange: onDependencyChange});\n        observationReciever.valueDependencies.forEach(removeValueDependencies, {onDependencyChange: onDependencyChange});\n    }\n};\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-observation/recorder-dependency-helpers.js?");

/***/ }),

/***/ "../../../../node_modules/can-observation/temporarily-bind.js":
/*!*************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-observation/temporarily-bind.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../../../node_modules/can-reflect/can-reflect.js\");\n\nvar temporarilyBoundNoOperation = function(){};\n// A list of temporarily bound computes\nvar observables;\n// Unbinds all temporarily bound computes.\nvar unbindTemporarilyBoundValue = function () {\n\tfor (var i = 0, len = observables.length; i < len; i++) {\n\t\tcanReflect.offValue(observables[i], temporarilyBoundNoOperation);\n\t}\n\tobservables = null;\n};\n\n// ### temporarilyBind\n// Binds computes for a moment to cache their value and prevent re-calculating it.\nfunction temporarilyBind(compute) {\n\tvar computeInstance = compute.computeInstance || compute;\n\tcanReflect.onValue(computeInstance, temporarilyBoundNoOperation);\n\tif (!observables) {\n\t\tobservables = [];\n\t\tsetTimeout(unbindTemporarilyBoundValue, 10);\n\t}\n\tobservables.push(computeInstance);\n}\n\nmodule.exports = temporarilyBind;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-observation/temporarily-bind.js?");

/***/ }),

/***/ "../../../../node_modules/can-queues/can-queues.js":
/*!**************************************************************!*\
  !*** C:/Projects/game/node_modules/can-queues/can-queues.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canDev = __webpack_require__( /*! can-log/dev/dev */ \"../../../../node_modules/can-log/dev/dev.js\" );\nvar Queue = __webpack_require__( /*! ./queue */ \"../../../../node_modules/can-queues/queue.js\" );\nvar PriorityQueue = __webpack_require__( /*! ./priority-queue */ \"../../../../node_modules/can-queues/priority-queue.js\" );\nvar queueState = __webpack_require__( /*! ./queue-state */ \"../../../../node_modules/can-queues/queue-state.js\" );\nvar CompletionQueue = __webpack_require__( /*! ./completion-queue */ \"../../../../node_modules/can-queues/completion-queue.js\" );\nvar DomOrderQueue = __webpack_require__(/*! ./dom-order-queue */ \"../../../../node_modules/can-queues/dom-order-queue.js\");\nvar ns = __webpack_require__( /*! can-namespace */ \"../../../../node_modules/can-namespace/can-namespace.js\" );\n\n// How many `batch.start` - `batch.stop` calls have been made.\nvar batchStartCounter = 0;\n// If a task was added since the last flush caused by `batch.stop`.\nvar addedTask = false;\n// If we are flushing due to a `batch.stop`.\nvar isFlushing = false;\n\n// Legacy values for the old batchNum.\nvar batchNum = 0;\nvar batchData;\n\n// Used by `.enqueueByQueue` to know the property names that might be passed.\nvar queueNames = [\"notify\", \"derive\", \"domUI\", \"dom\",\"mutate\"];\n// Create all the queues so that when one is complete,\n// the next queue is flushed.\nvar NOTIFY_QUEUE,\n\tDERIVE_QUEUE,\n\tDOM_UI_QUEUE,\n\tDOM_QUEUE,\n\tMUTATE_QUEUE;\n\n// This is for immediate notification. This is where we teardown (remove childNodes)\n// immediately.\nNOTIFY_QUEUE = new Queue( \"NOTIFY\", {\n\tonComplete: function () {\n\t\tDERIVE_QUEUE.flush();\n\t},\n\tonFirstTask: function () {\n\t\t// Flush right away if we aren't in a batch.\n\t\tif ( !batchStartCounter ) {\n\t\t\tNOTIFY_QUEUE.flush();\n\t\t} else {\n\t\t\taddedTask = true;\n\t\t}\n\t}\n});\n\n// For observations not connected to the DOM\nDERIVE_QUEUE = new PriorityQueue( \"DERIVE\", {\n\tonComplete: function () {\n\t\tDOM_QUEUE.flush();\n\t},\n\tonFirstTask: function () {\n\t\taddedTask = true;\n\t}\n});\n\n// DOM_DERIVE comes next so that any prior derives have a chance\n// to settle before the derives that actually affect the DOM\n// are re-caculated.\n// See the `Child bindings are called before the parent` can-stache test.\n// All stache-related observables should update in DOM order.\n\n// Observations that are given an element update their value here.\nDOM_QUEUE = new DomOrderQueue( \"DOM   \" ,{\n\tonComplete: function () {\n\t\tDOM_UI_QUEUE.flush();\n\t},\n\tonFirstTask: function () {\n\t\taddedTask = true;\n\t}\n});\n\n// The old DOM_UI queue ... we should seek to remove this.\nDOM_UI_QUEUE = new CompletionQueue( \"DOM_UI\", {\n\tonComplete: function () {\n\t\tMUTATE_QUEUE.flush();\n\t},\n\tonFirstTask: function () {\n\t\taddedTask = true;\n\t}\n});\n\n// Update\nMUTATE_QUEUE = new Queue( \"MUTATE\", {\n\tonComplete: function () {\n\t\tqueueState.lastTask = null;\n\t\tisFlushing = false;\n\t},\n\tonFirstTask: function () {\n\t\taddedTask = true;\n\t}\n});\n\nvar queues = {\n\tQueue: Queue,\n\tPriorityQueue: PriorityQueue,\n\tCompletionQueue: CompletionQueue,\n\tDomOrderQueue: DomOrderQueue,\n\tnotifyQueue: NOTIFY_QUEUE,\n\tderiveQueue: DERIVE_QUEUE,\n\tdomQueue: DOM_QUEUE,\n\tdomUIQueue: DOM_UI_QUEUE,\n\tmutateQueue: MUTATE_QUEUE,\n\tbatch: {\n\t\tstart: function () {\n\t\t\tbatchStartCounter++;\n\t\t\tif ( batchStartCounter === 1 ) {\n\t\t\t\tbatchNum++;\n\t\t\t\tbatchData = {number: batchNum};\n\t\t\t}\n\t\t},\n\t\tstop: function () {\n\t\t\tbatchStartCounter--;\n\t\t\tif ( batchStartCounter === 0 ) {\n\t\t\t\tif ( addedTask ) {\n\t\t\t\t\taddedTask = false;\n\t\t\t\t\tisFlushing = true;\n\t\t\t\t\tNOTIFY_QUEUE.flush();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Legacy method to return if we are between start and stop calls.\n\t\tisCollecting: function () {\n\t\t\treturn batchStartCounter > 0;\n\t\t},\n\t\t// Legacy method provide a number for each batch.\n\t\tnumber: function () {\n\t\t\treturn batchNum;\n\t\t},\n\t\t// Legacy method to provide batch information.\n\t\tdata: function () {\n\t\t\treturn batchData;\n\t\t}\n\t},\n\trunAsTask: function(fn, reasonLog){\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\treturn function(){\n\t\t\t\tqueueState.lastTask = {\n\t\t\t\t\tfn: fn,\n\t\t\t\t\tcontext: this,\n\t\t\t\t\targs: arguments,\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\treasonLog: typeof reasonLog === \"function\" ? reasonLog.apply(this, arguments): reasonLog,\n\t\t\t\t\t\tparentTask: queueState.lastTask,\n\t\t\t\t\t\tstack: {name: \"RUN_AS\"}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tvar ret = fn.apply(this, arguments);\n\t\t\t\tqueueState.lastTask = queueState.lastTask && queueState.lastTask.meta.parentTask;\n\t\t\t\treturn ret;\n\t\t\t};\n\t\t}\n\t\t//!steal-remove-end\n\t\treturn fn;\n\t},\n\tenqueueByQueue: function enqueueByQueue ( fnByQueue, context, args, makeMeta, reasonLog ) {\n\t\tif ( fnByQueue ) {\n\t\t\tqueues.batch.start();\n\t\t\t// For each queue, check if there are tasks for it.\n\t\t\tqueueNames.forEach( function ( queueName ) {\n\t\t\t\tvar name = queueName + \"Queue\";\n\t\t\t\tvar QUEUE = queues[name];\n\t\t\t\tvar tasks = fnByQueue[queueName];\n\t\t\t\tif ( tasks !== undefined ) {\n\t\t\t\t\t// For each task function, setup the meta and enqueue it.\n\t\t\t\t\ttasks.forEach( function ( fn ) {\n\t\t\t\t\t\tvar meta = makeMeta != null ? makeMeta( fn, context, args ) : {};\n\t\t\t\t\t\tmeta.reasonLog = reasonLog;\n\t\t\t\t\t\tQUEUE.enqueue( fn, context, args, meta );\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\tqueues.batch.stop();\n\t\t}\n\t},\n\tlastTask: function(){\n\t\treturn queueState.lastTask;\n\t},\n\t// Currently an internal method that provides the task stack.\n\t// Returns an array with the first task as the first item.\n\tstack: function (task) {\n\t\tvar current = task || queueState.lastTask;\n\t\tvar stack = [];\n\t\twhile ( current ) {\n\t\t\tstack.unshift( current );\n\t\t\t// Queue.prototype._logEnqueue ensures\n\t\t\t// that the `parentTask` is always set.\n\t\t\tcurrent = current.meta.parentTask;\n\t\t}\n\t\treturn stack;\n\t},\n\tlogStack: function (task) {\n\t\tvar stack = this.stack(task);\n\t\tstack.forEach( function ( task, i ) {\n\t\t\tvar meta = task.meta;\n\t\t\tif( i === 0 && meta && meta.reasonLog) {\n\t\t\t\tcanDev.log.apply( canDev, meta.reasonLog);\n\t\t\t}\n\t\t\tvar log = meta && meta.log ? meta.log : [task.fn.name, task];\n\t\t\tcanDev.log.apply( canDev, [task.meta.stack.name + \" ran task:\"].concat( log ));\n\t\t});\n\t},\n\t// A method that is not used.  It should return the number of tasks\n\t// remaining, but doesn't seem to actually work.\n\ttaskCount: function () {\n\t\treturn NOTIFY_QUEUE.tasks.length + DERIVE_QUEUE.tasks.length + DOM_UI_QUEUE.tasks.length + MUTATE_QUEUE.tasks.length;\n\t},\n\t// A shortcut for flushign the notify queue.  `batch.start` and `batch.stop` should be\n\t// used instead.\n\tflush: function () {\n\t\tNOTIFY_QUEUE.flush();\n\t},\n\tlog: function () {\n\t\tNOTIFY_QUEUE.log.apply( NOTIFY_QUEUE, arguments );\n\t\tDERIVE_QUEUE.log.apply( DERIVE_QUEUE, arguments );\n\t\tDOM_UI_QUEUE.log.apply( DOM_UI_QUEUE, arguments );\n\t\tDOM_QUEUE.log.apply( DOM_QUEUE, arguments );\n\t\tMUTATE_QUEUE.log.apply( MUTATE_QUEUE, arguments );\n\t}\n};\n\nif ( ns.queues ) {\n\tthrow new Error( \"You can't have two versions of can-queues, check your dependencies\" );\n} else {\n\tmodule.exports = ns.queues = queues;\n}\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-queues/can-queues.js?");

/***/ }),

/***/ "../../../../node_modules/can-queues/completion-queue.js":
/*!********************************************************************!*\
  !*** C:/Projects/game/node_modules/can-queues/completion-queue.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Queue = __webpack_require__( /*! ./queue */ \"../../../../node_modules/can-queues/queue.js\" );\n\n// This queue does not allow another task to run until this one is complete\nvar CompletionQueue = function () {\n\tQueue.apply( this, arguments );\n\tthis.flushCount = 0;\n};\nCompletionQueue.prototype = Object.create( Queue.prototype );\nCompletionQueue.prototype.constructor = CompletionQueue;\n\nCompletionQueue.prototype.flush = function () {\n\tif ( this.flushCount === 0 ) {\n\t\tthis.flushCount ++;\n\t\twhile ( this.index < this.tasks.length ) {\n\t\t\tvar task = this.tasks[this.index++];\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tthis._logFlush( task );\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\ttask.fn.apply( task.context, task.args );\n\t\t}\n\t\tthis.index = 0;\n\t\tthis.tasks = [];\n\t\tthis.flushCount--;\n\t\tthis.callbacks.onComplete( this );\n\t}\n};\n\nmodule.exports = CompletionQueue;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-queues/completion-queue.js?");

/***/ }),

/***/ "../../../../node_modules/can-queues/dom-order-queue.js":
/*!*******************************************************************!*\
  !*** C:/Projects/game/node_modules/can-queues/dom-order-queue.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Queue = __webpack_require__( /*! ./queue */ \"../../../../node_modules/can-queues/queue.js\" );\nvar sortedIndexBy = __webpack_require__(/*! ./sorted-index-by */ \"../../../../node_modules/can-queues/sorted-index-by.js\");\nvar elementSort = __webpack_require__(/*! ./element-sort */ \"../../../../node_modules/can-queues/element-sort.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../../../node_modules/can-symbol/can-symbol.js\");\n\nvar canElementSymbol = canSymbol.for(\"can.element\");\n\n// TODO: call sortable queue and take how it should be sorted ...\nfunction sortTasks(taskA, taskB){\n\t// taskA - in the document?\n\t// taskA - given a number?\n\t//\n\treturn elementSort.sortOrder(taskA.meta.element, taskB.meta.element);\n}\n\nvar DomOrderQueue = function () {\n\tQueue.apply( this, arguments );\n\t// A map of a task's function to the task for that function.\n\t// This is so we can prevent duplicate functions from being enqueued\n\t// and so `flushQueuedTask` can find the task and run it.\n\tthis.taskMap = new Map();\n\n\tthis.unsortable = [];\n\tthis.isFlushing = false;\n};\nDomOrderQueue.prototype = Object.create( Queue.prototype );\nDomOrderQueue.prototype.constructor = DomOrderQueue;\n\nDomOrderQueue.prototype.enqueue = function ( fn, context, args, meta ) {\n\tvar task;\n\t// Only allow the enqueing of a given function once.\n\tif ( !this.taskMap.has( fn ) ) {\n\n\t\tif(!meta) {\n\t\t\tmeta = {};\n\t\t}\n\t\tif(!meta.element) {\n\t\t\tmeta.element = fn[canElementSymbol];\n\t\t}\n\n\t\ttask = {\n\t\t\tfn: fn,\n\t\t\tcontext: context,\n\t\t\targs: args,\n\t\t\tmeta: meta\n\t\t};\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tif( !meta.element ) {\n\t\t\t\tthrow new Error(\"DomOrderQueue tasks must be created with a meta.element.\");\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tthis.taskMap.set( fn, task );\n\n\t\tvar index = sortedIndexBy(sortTasks, this.tasks, task);\n\n\t\tthis.tasks.splice(index, 0, task);\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tthis._logEnqueue( task );\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tif ( this.tasks.length === 1 ) {\n\t\t\tthis.callbacks.onFirstTask( this );\n\t\t}\n\t} else {\n\t\t// update the task with the new data\n\t\t// TODO: ideally this would key off the mutation instead of the function.\n\t\t// We could make it key off the element and function,  not just function.\n\t\ttask = this.taskMap.get( fn );\n\t\ttask.context = context;\n\t\ttask.args = args;\n\n\t\tif(!meta) {\n\t\t\tmeta = {};\n\t\t}\n\n\t\tif(!meta.element) {\n\t\t\tmeta.element = fn[canElementSymbol];\n\t\t}\n\n\t\ttask.meta = meta;\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tthis._logEnqueue( task );\n\t\t}\n\t\t//!steal-remove-end\n\t}\n};\n\n\nDomOrderQueue.prototype.flush = function () {\n\t// Only allow one task to run at a time.\n\tif ( this.isFlushing ) {\n\t\treturn;\n\t}\n\tthis.isFlushing = true;\n\n\twhile ( this.tasks.length ) {\n\t\tvar task = this.tasks.shift();\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tthis._logFlush( task );\n\t\t}\n\t\t//!steal-remove-end\n\t\tthis.taskMap[\"delete\"]( task.fn );\n\t\ttask.fn.apply( task.context, task.args );\n\t}\n\tthis.isFlushing = false;\n\tthis.callbacks.onComplete( this );\n};\n\nDomOrderQueue.prototype.isEnqueued = function ( fn ) {\n\treturn this.taskMap.has( fn );\n};\n\nDomOrderQueue.prototype.flushQueuedTask = function ( fn ) {\n\tvar task = this.dequeue(fn);\n\tif(task) {\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tthis._logFlush( task );\n\t\t}\n\t\t//!steal-remove-end\n\t\ttask.fn.apply( task.context, task.args );\n\t}\n};\nDomOrderQueue.prototype.dequeue = function(fn){\n\tvar task = this.taskMap.get( fn );\n\tif ( task ) {\n\n\t\tvar index = this.tasks.indexOf(task);\n\n\t\tif ( index >= 0 ) {\n\t\t\tthis.tasks.splice( index, 1 );\n\t\t\tthis.taskMap[\"delete\"]( task.fn );\n\t\t\treturn task;\n\t\t} else {\n\t\t\tconsole.warn(\"Task\", fn, \"has already run\");\n\t\t}\n\t}\n};\n\nDomOrderQueue.prototype.tasksRemainingCount = function () {\n\treturn this.tasks.length;\n};\n\nmodule.exports = DomOrderQueue;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-queues/dom-order-queue.js?");

/***/ }),

/***/ "../../../../node_modules/can-queues/element-sort.js":
/*!****************************************************************!*\
  !*** C:/Projects/game/node_modules/can-queues/element-sort.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Taken from jQuery\nvar hasDuplicate,\n\tsortInput,\n\tsortStable = true,\n\tindexOf = Array.prototype.indexOf;\n\nfunction sortOrder( a, b ) {\n\n\t// Flag for duplicate removal\n\tif ( a === b ) {\n\t\thasDuplicate = true;\n\t\treturn 0;\n\t}\n\n\t// Sort on method existence if only one input has compareDocumentPosition\n\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\tif ( compare ) {\n\t\treturn compare;\n\t}\n\n\t// Calculate position if both inputs belong to the same document\n\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\ta.compareDocumentPosition( b ) :\n\n\t\t// Otherwise we know they are disconnected\n\t\t1;\n\n\t// Disconnected nodes\n\tif ( compare & 1 ) {\n\n\t\t// Choose the first element that is related to our preferred document\n\t\tif ( a === document || a.ownerDocument === document &&\n\t\t\tdocument.documentElement.contains(a) ) {\n\t\t\treturn -1;\n\t\t}\n\t\tif ( b === document || b.ownerDocument === document &&\n\t\t\tdocument.documentElement.contains(b) ) {\n\t\t\treturn 1;\n\t\t}\n\n\t\t// Maintain original order\n\t\treturn sortInput ?\n\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n\t\t\t0;\n\t}\n\n\treturn compare & 4 ? -1 : 1;\n}\n\nfunction uniqueSort( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\thasDuplicate = false;\n\tsortInput = !sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( ( elem = results[ i++ ] ) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n}\n\nmodule.exports = {\n\tuniqueSort: uniqueSort,\n\tsortOrder: sortOrder\n};\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-queues/element-sort.js?");

/***/ }),

/***/ "../../../../node_modules/can-queues/priority-queue.js":
/*!******************************************************************!*\
  !*** C:/Projects/game/node_modules/can-queues/priority-queue.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Queue = __webpack_require__( /*! ./queue */ \"../../../../node_modules/can-queues/queue.js\" );\n\nvar PriorityQueue = function () {\n\tQueue.apply( this, arguments );\n\t// A map of a task's function to the task for that function.\n\t// This is so we can prevent duplicate functions from being enqueued\n\t// and so `flushQueuedTask` can find the task and run it.\n\tthis.taskMap = new Map();\n\t// An \"array-of-arrays\"-ish data structure that stores\n\t// each task organized by its priority.  Each object in this list\n\t// looks like `{tasks: [...], index: 0}` where:\n\t// - `tasks` - the tasks for a particular priority.\n\t// - `index` - the index of the task waiting to be prioritized.\n\tthis.taskContainersByPriority = [];\n\n\t// The index within `taskContainersByPriority` of the first `taskContainer`\n\t// which has tasks that have not been run.\n\tthis.curPriorityIndex = Infinity;\n\t// The index within `taskContainersByPriority` of the last `taskContainer`\n\t// which has tasks that have not been run.\n\tthis.curPriorityMax = 0;\n\n\tthis.isFlushing = false;\n\n\t// Manage the number of tasks remaining to keep\n\t// this lookup fast.\n\tthis.tasksRemaining = 0;\n};\nPriorityQueue.prototype = Object.create( Queue.prototype );\nPriorityQueue.prototype.constructor = PriorityQueue;\n\nPriorityQueue.prototype.enqueue = function ( fn, context, args, meta ) {\n\t// Only allow the enqueing of a given function once.\n\tif ( !this.taskMap.has( fn ) ) {\n\n\t\tthis.tasksRemaining++;\n\n\t\tvar isFirst = this.taskContainersByPriority.length === 0;\n\n\t\tvar task = {\n\t\t\tfn: fn,\n\t\t\tcontext: context,\n\t\t\targs: args,\n\t\t\tmeta: meta || {}\n\t\t};\n\n\t\tvar taskContainer = this.getTaskContainerAndUpdateRange( task );\n\t\ttaskContainer.tasks.push( task );\n\t\tthis.taskMap.set( fn, task );\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tthis._logEnqueue( task );\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tif ( isFirst ) {\n\t\t\tthis.callbacks.onFirstTask( this );\n\t\t}\n\t}\n};\n\n// Given a task, updates the queue's cursors so that `flush`\n// will be able to run the task.\nPriorityQueue.prototype.getTaskContainerAndUpdateRange = function ( task ) {\n\tvar priority = task.meta.priority || 0;\n\n\tif ( priority < this.curPriorityIndex ) {\n\t\tthis.curPriorityIndex = priority;\n\t}\n\n\tif ( priority > this.curPriorityMax ) {\n\t\tthis.curPriorityMax = priority;\n\t}\n\n\tvar tcByPriority = this.taskContainersByPriority;\n\tvar taskContainer = tcByPriority[priority];\n\tif ( !taskContainer ) {\n\t\ttaskContainer = tcByPriority[priority] = {tasks: [], index: 0};\n\t}\n\treturn taskContainer;\n};\n\nPriorityQueue.prototype.flush = function () {\n\t// Only allow one task to run at a time.\n\tif ( this.isFlushing ) {\n\t\treturn;\n\t}\n\tthis.isFlushing = true;\n\twhile ( true ) {\n\t\t// If the first prioritized taskContainer with tasks remaining\n\t\t// is before the last prioritized taskContainer ...\n\t\tif ( this.curPriorityIndex <= this.curPriorityMax ) {\n\t\t\tvar taskContainer = this.taskContainersByPriority[this.curPriorityIndex];\n\n\t\t\t// If that task container actually has tasks remaining ...\n\t\t\tif ( taskContainer && ( taskContainer.tasks.length > taskContainer.index ) ) {\n\n\t\t\t\t// Run the task.\n\t\t\t\tvar task = taskContainer.tasks[taskContainer.index++];\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(true) {\n\t\t\t\t\tthis._logFlush( task );\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t\tthis.tasksRemaining--;\n\t\t\t\tthis.taskMap[\"delete\"]( task.fn );\n\t\t\t\ttask.fn.apply( task.context, task.args );\n\n\t\t\t} else {\n\t\t\t\t// Otherwise, move to the next taskContainer.\n\t\t\t\tthis.curPriorityIndex++;\n\t\t\t}\n\t\t} else {\n\t\t\t// Otherwise, reset the state for the next `.flush()`.\n\t\t\tthis.taskMap = new Map();\n\t\t\tthis.curPriorityIndex = Infinity;\n\t\t\tthis.curPriorityMax = 0;\n\t\t\tthis.taskContainersByPriority = [];\n\t\t\tthis.isFlushing = false;\n\t\t\tthis.callbacks.onComplete( this );\n\t\t\treturn;\n\t\t}\n\t}\n};\n\nPriorityQueue.prototype.isEnqueued = function ( fn ) {\n\treturn this.taskMap.has( fn );\n};\n\nPriorityQueue.prototype.flushQueuedTask = function ( fn ) {\n\tvar task = this.dequeue(fn);\n\tif(task) {\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tthis._logFlush( task );\n\t\t}\n\t\t//!steal-remove-end\n\t\ttask.fn.apply( task.context, task.args );\n\t}\n};\nPriorityQueue.prototype.dequeue = function(fn){\n\tvar task = this.taskMap.get( fn );\n\tif ( task ) {\n\t\tvar priority = task.meta.priority || 0;\n\t\tvar taskContainer = this.taskContainersByPriority[priority];\n\t\tvar index = taskContainer.tasks.indexOf( task, taskContainer.index );\n\n\t\tif ( index >= 0 ) {\n\t\t\ttaskContainer.tasks.splice( index, 1 );\n\t\t\tthis.tasksRemaining--;\n\t\t\tthis.taskMap[\"delete\"]( task.fn );\n\t\t\treturn task;\n\t\t} else {\n\t\t\tconsole.warn(\"Task\", fn, \"has already run\");\n\t\t}\n\t}\n};\n\nPriorityQueue.prototype.tasksRemainingCount = function () {\n\treturn this.tasksRemaining;\n};\n\nmodule.exports = PriorityQueue;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-queues/priority-queue.js?");

/***/ }),

/***/ "../../../../node_modules/can-queues/queue-state.js":
/*!***************************************************************!*\
  !*** C:/Projects/game/node_modules/can-queues/queue-state.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = {\n\tlastTask: null\n};\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-queues/queue-state.js?");

/***/ }),

/***/ "../../../../node_modules/can-queues/queue.js":
/*!*********************************************************!*\
  !*** C:/Projects/game/node_modules/can-queues/queue.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar queueState = __webpack_require__(/*! ./queue-state */ \"../../../../node_modules/can-queues/queue-state.js\");\nvar canDev = __webpack_require__(/*! can-log/dev/dev */ \"../../../../node_modules/can-log/dev/dev.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"../../../../node_modules/can-assign/can-assign.js\");\n\nfunction noOperation () {}\n\nvar Queue = function ( name, callbacks ) {\n\tthis.callbacks = assign( {\n\t\tonFirstTask: noOperation,\n\t\t// The default behavior is to clear the lastTask state.\n\t\t// This is overwritten by `can-queues.js`.\n\t\tonComplete: function () {\n\t\t\tqueueState.lastTask = null;\n\t\t}\n\t}, callbacks || {});\n\tthis.name = name;\n\tthis.index = 0;\n\tthis.tasks = [];\n\tthis._log = false;\n};\n\nQueue.prototype.constructor = Queue;\n\nQueue.noop = noOperation;\n\nQueue.prototype.enqueue = function ( fn, context, args, meta ) {\n\tvar len = this.tasks.push({\n\t\tfn: fn,\n\t\tcontext: context,\n\t\targs: args,\n\t\tmeta: meta || {}\n\t});\n\t//!steal-remove-start\n\tif(true) {\n\t\tthis._logEnqueue( this.tasks[len - 1] );\n\t}\n\t//!steal-remove-end\n\n\tif ( len === 1 ) {\n\t\tthis.callbacks.onFirstTask( this );\n\t}\n};\n\nQueue.prototype.flush = function () {\n\twhile ( this.index < this.tasks.length ) {\n\t\tvar task = this.tasks[this.index++];\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tthis._logFlush( task );\n\t\t}\n\n\t\t//!steal-remove-end\n\t\ttask.fn.apply( task.context, task.args );\n\t}\n\tthis.index = 0;\n\tthis.tasks = [];\n\tthis.callbacks.onComplete( this );\n};\n\nQueue.prototype.log = function () {\n\tthis._log = arguments.length ? arguments[0] : true;\n};\n\n//The following are removed in production.\n//!steal-remove-start\nif(true) {\n\tQueue.prototype._logEnqueue = function ( task ) {\n\t\t// For debugging, set the parentTask to the last\n\t\t// run task.\n\t\ttask.meta.parentTask = queueState.lastTask;\n\t\t// Also let the task know which stack it was run within.\n\t\ttask.meta.stack = this;\n\n\t\tif ( this._log === true || this._log === \"enqueue\" ) {\n\t\t\tvar log = task.meta.log ? task.meta.log.concat( task ) : [task.fn.name, task];\n\t\t\tcanDev.log.apply( canDev, [this.name + \" enqueuing:\"].concat( log ));\n\t\t}\n\t};\n\t// `_logFlush` MUST be called by all queues prior to flushing in\n\t// development.\n\tQueue.prototype._logFlush = function ( task ) {\n\t\tif ( this._log === true || this._log === \"flush\" ) {\n\t\t\tvar log = task.meta.log ? task.meta.log.concat( task ) : [task.fn.name, task];\n\t\t\tcanDev.log.apply( canDev, [this.name + \" running  :\"].concat( log ));\n\t\t}\n\t\t// Update the state to mark this as the task that was run last.\n\t\tqueueState.lastTask = task;\n\t};\n}\n//!steal-remove-end\n\nmodule.exports = Queue;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-queues/queue.js?");

/***/ }),

/***/ "../../../../node_modules/can-queues/sorted-index-by.js":
/*!*******************************************************************!*\
  !*** C:/Projects/game/node_modules/can-queues/sorted-index-by.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(compare, array, value) {\n\tif (!array || !array.length) {\n\t\treturn undefined;\n\t}\n\t// check the start and the end\n\tif (compare(value, array[0]) === -1) {\n\t\treturn 0;\n\t} else if (compare(value, array[array.length - 1]) === 1) {\n\t\treturn array.length;\n\t}\n\tvar low = 0,\n\t\thigh = array.length;\n\n\t// From lodash lodash 4.6.1 <https://lodash.com/>\n\t// Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n\twhile (low < high) {\n\t\tvar mid = (low + high) >>> 1,\n\t\t\titem = array[mid],\n\t\t\tcomputed = compare(value, item);\n\t\tif (computed === -1) {\n\t\t\thigh = mid;\n\t\t} else {\n\t\t\tlow = mid + 1;\n\t\t}\n\t}\n\treturn high;\n\t// bisect by calling sortFunc\n};\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-queues/sorted-index-by.js?");

/***/ }),

/***/ "../../../../node_modules/can-reflect-promise/can-reflect-promise.js":
/*!********************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-reflect-promise/can-reflect-promise.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../../../node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../../../node_modules/can-symbol/can-symbol.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../../../node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../../../node_modules/can-queues/can-queues.js\");\nvar KeyTree = __webpack_require__(/*! can-key-tree */ \"../../../../node_modules/can-key-tree/can-key-tree.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../../../node_modules/can-log/dev/dev.js\");\n\n\nvar getKeyValueSymbol = canSymbol.for(\"can.getKeyValue\"),\n\tobserveDataSymbol = canSymbol.for(\"can.meta\");\n\nvar promiseDataPrototype = {\n\tisPending: true,\n\tstate: \"pending\",\n\tisResolved: false,\n\tisRejected: false,\n\tvalue: undefined,\n\treason: undefined\n};\n\nfunction setVirtualProp(promise, property, value) {\n\tvar observeData = promise[observeDataSymbol];\n\tvar old = observeData[property];\n\tobserveData[property] = value;\n\tqueues.enqueueByQueue(observeData.handlers.getNode([property]), promise, [value,old], function() {\n\t\treturn {};\n\t},[\"Promise\", promise, \"resolved with value\", value, \"and changed virtual property: \"+property]);\n}\n\nfunction initPromise(promise) {\n\tvar observeData = promise[observeDataSymbol];\n\tif(!observeData) {\n\t\tObject.defineProperty(promise, observeDataSymbol, {\n\t\t\tenumerable: false,\n\t\t\tconfigurable: false,\n\t\t\twritable: false,\n\t\t\tvalue: Object.create(promiseDataPrototype)\n\t\t});\n\t\tobserveData = promise[observeDataSymbol];\n\t\tobserveData.handlers = new KeyTree([Object, Object, Array]);\n\t}\n\tpromise.then(function(value){\n\t\tqueues.batch.start();\n\t\tsetVirtualProp(promise, \"isPending\", false);\n\t\tsetVirtualProp(promise, \"isResolved\", true);\n\t\tsetVirtualProp(promise, \"value\", value);\n\t\tsetVirtualProp(promise, \"state\", \"resolved\");\n\t\tqueues.batch.stop();\n\t}, function(reason){\n\t\tqueues.batch.start();\n\t\tsetVirtualProp(promise, \"isPending\", false);\n\t\tsetVirtualProp(promise, \"isRejected\", true);\n\t\tsetVirtualProp(promise, \"reason\", reason);\n\t\tsetVirtualProp(promise, \"state\", \"rejected\");\n\t\tqueues.batch.stop();\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tdev.error(\"Failed promise:\", reason);\n\t\t}\n\t\t//!steal-remove-end\n\t});\n}\n\nfunction setupPromise(value) {\n\tvar oldPromiseFn;\n\tvar proto = \"getPrototypeOf\" in Object ? Object.getPrototypeOf(value) : value.__proto__; //jshint ignore:line\n\n\tif(value[getKeyValueSymbol] && value[observeDataSymbol]) {\n\t\t// promise has already been set up.  Don't overwrite.\n\t\treturn;\n\t}\n\n\tif(proto === null || proto === Object.prototype) {\n\t\t// promise type is a plain object or dictionary.  Set up object instead of proto.\n\t\tproto = value;\n\n\t\tif(typeof proto.promise === \"function\") {\n\t\t\t// Duck-type identification as a jQuery.Deferred;\n\t\t\t// In that case, the promise() function returns a new object\n\t\t\t//  that needs to be decorated.\n\t\t\toldPromiseFn = proto.promise;\n\t\t\tproto.promise = function() {\n\t\t\t\tvar result = oldPromiseFn.call(proto);\n\t\t\t\tsetupPromise(result);\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}\n\t}\n\n\tcanReflect.assignSymbols(proto, {\n\t\t\"can.getKeyValue\": function(key) {\n\t\t\tif(!this[observeDataSymbol]) {\n\t\t\t\tinitPromise(this);\n\t\t\t}\n\n\t\t\tObservationRecorder.add(this, key);\n\t\t\tswitch(key) {\n\t\t\t\tcase \"state\":\n\t\t\t\tcase \"isPending\":\n\t\t\t\tcase \"isResolved\":\n\t\t\t\tcase \"isRejected\":\n\t\t\t\tcase \"value\":\n\t\t\t\tcase \"reason\":\n\t\t\t\treturn this[observeDataSymbol][key];\n\t\t\t\tdefault:\n\t\t\t\treturn this[key];\n\t\t\t}\n\t\t},\n\t\t\"can.getValue\": function() {\n\t\t\treturn this[getKeyValueSymbol](\"value\");\n\t\t},\n\t\t\"can.isValueLike\": false,\n\t\t\"can.onKeyValue\": function(key, handler, queue) {\n\t\t\tif(!this[observeDataSymbol]) {\n\t\t\t\tinitPromise(this);\n\t\t\t}\n\t\t\tthis[observeDataSymbol].handlers.add([key, queue || \"mutate\", handler]);\n\t\t},\n\t\t\"can.offKeyValue\": function(key, handler, queue) {\n\t\t\tif(!this[observeDataSymbol]) {\n\t\t\t\tinitPromise(this);\n\t\t\t}\n\t\t\tthis[observeDataSymbol].handlers.delete([key, queue || \"mutate\", handler]);\n\t\t},\n\t\t\"can.hasOwnKey\": function(key) {\n\t\t\tif (!this[observeDataSymbol]) {\n\t\t\t\tinitPromise(this);\n\t\t\t}\n\t\t\treturn (key in this[observeDataSymbol]);\n\t\t}\n\t});\n}\n\nmodule.exports = setupPromise;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-reflect-promise/can-reflect-promise.js?");

/***/ }),

/***/ "../../../../node_modules/can-reflect/can-reflect.js":
/*!****************************************************************!*\
  !*** C:/Projects/game/node_modules/can-reflect/can-reflect.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar functionReflections = __webpack_require__(/*! ./reflections/call/call */ \"../../../../node_modules/can-reflect/reflections/call/call.js\");\nvar getSet = __webpack_require__(/*! ./reflections/get-set/get-set */ \"../../../../node_modules/can-reflect/reflections/get-set/get-set.js\");\nvar observe = __webpack_require__(/*! ./reflections/observe/observe */ \"../../../../node_modules/can-reflect/reflections/observe/observe.js\");\nvar shape = __webpack_require__(/*! ./reflections/shape/shape */ \"../../../../node_modules/can-reflect/reflections/shape/shape.js\");\nvar schema = __webpack_require__(/*! ./reflections/shape/schema/schema */ \"../../../../node_modules/can-reflect/reflections/shape/schema/schema.js\");\nvar type = __webpack_require__(/*! ./reflections/type/type */ \"../../../../node_modules/can-reflect/reflections/type/type.js\");\nvar getName = __webpack_require__(/*! ./reflections/get-name/get-name */ \"../../../../node_modules/can-reflect/reflections/get-name/get-name.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../../../node_modules/can-namespace/can-namespace.js\");\n\nvar reflect = {};\n[\n\tfunctionReflections,\n\tgetSet,\n\tobserve,\n\tshape,\n\ttype,\n\tgetName,\n\tschema\n].forEach(function(reflections){\n\tfor(var prop in reflections) {\n\t\treflect[prop] = reflections[prop];\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tif(typeof reflections[prop] === \"function\") {\n\t\t\t\tvar propDescriptor = Object.getOwnPropertyDescriptor(reflections[prop], 'name');\n\t\t\t\tif (!propDescriptor || propDescriptor.writable && propDescriptor.configurable) {\n\t\t\t\t\tObject.defineProperty(reflections[prop],\"name\",{\n\t\t\t\t\t\tvalue: \"canReflect.\"+prop\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\t}\n});\n\n__webpack_require__(/*! ./types/map */ \"../../../../node_modules/can-reflect/types/map.js\");\n__webpack_require__(/*! ./types/set */ \"../../../../node_modules/can-reflect/types/set.js\");\n\nmodule.exports = namespace.Reflect = reflect;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-reflect/can-reflect.js?");

/***/ }),

/***/ "../../../../node_modules/can-reflect/reflections/call/call.js":
/*!**************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-reflect/reflections/call/call.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../../../node_modules/can-symbol/can-symbol.js\");\nvar typeReflections = __webpack_require__(/*! ../type/type */ \"../../../../node_modules/can-reflect/reflections/type/type.js\");\n\nmodule.exports = {\n\t/**\n\t * @function {function(...), Object, ...} can-reflect/call.call call\n\t * @parent can-reflect/call\n\t * @description  Call a callable, with a context object and parameters\n\t *\n\t * @signature `call(func, context, ...rest)`\n\t *\n\t * Call the callable `func` as if it were a function, bound to `context` and with any additional parameters\n\t * occurring after `context` set to the positional parameters.\n\t *\n\t * Note that `func` *must* either be natively callable, implement [can-symbol/symbols/apply @@@@can.apply],\n\t * or have a callable `apply` property to work with `canReflect.call`\n\t *\n\t * ```js\n\t * var compute = canCompute(\"foo\");\n\t *\n\t * canReflect.call(compute, null, \"bar\");\n\t * canReflect.call(compute, null); // -> \"bar\"\n\t * ```\n\t *\n\t * @param  {function(...)} func the function to call with the supplied arguments\n\t * @param  {Object} context the context object to set as `this` on the function call\n\t * @param  {*} rest any arguments after `context` will be passed to the function call\n\t * @return {*}  return types and values are determined by the call to `func`\n\t */\n\tcall: function(func, context){\n\t\tvar args = [].slice.call(arguments, 2);\n\t\tvar apply = func[canSymbol.for(\"can.apply\")];\n\t\tif(apply) {\n\t\t\treturn apply.call(func, context, args);\n\t\t} else {\n\t\t\treturn func.apply(context, args);\n\t\t}\n\t},\n\t/**\n\t * @function {function(...), Object, ...} can-reflect/call.apply apply\n\t * @parent can-reflect/call\n\t * @description  Call a callable, with a context object and a list of parameters\n\t *\n\t * @signature `apply(func, context, args)`\n\t *\n\t * Call the callable `func` as if it were a function, bound to `context` and with any additional parameters\n\t * contained in the Array-like `args`\n\t *\n\t * Note that `func` *must* either be natively callable, implement [can-symbol/symbols/apply @@@@can.apply],\n\t * or have a callable `apply` property to work with `canReflect.apply`\n\t *\n\t * ```js\n\t * var compute = canCompute(\"foo\");\n\t *\n\t * canReflect.apply(compute, null, [\"bar\"]);\n\t * canReflect.apply(compute, null, []); // -> \"bar\"\n\t * ```\n\t *\n\t * @param  {function(...)} func the function to call\n\t * @param  {Object} context the context object to set as `this` on the function call\n\t * @param  {*} args arguments to be passed to the function call\n\t * @return {*}  return types and values are determined by the call to `func`\n\t */\n\tapply: function(func, context, args){\n\t\tvar apply = func[canSymbol.for(\"can.apply\")];\n\t\tif(apply) {\n\t\t\treturn apply.call(func, context, args);\n\t\t} else {\n\t\t\treturn func.apply(context, args);\n\t\t}\n\t},\n\t/**\n\t * @function {function(...), ...} can-reflect/call.new new\n\t * @parent can-reflect/call\n\t * @description  Construct a new instance of a callable constructor\n\t *\n\t * @signature `new(func, ...rest)`\n\t *\n\t * Call the callable `func` as if it were a function, bound to a new instance of `func`, and with any additional\n\t * parameters occurring after `func` set to the positional parameters.\n\t *\n\t * Note that `func` *must* either implement [can-symbol/symbols/new @@@@can.new],\n\t * or have a callable `apply` property *and* a prototype to work with `canReflect.new`\n\t *\n\t * ```js\n\t * canReflect.new(DefineList, [\"foo\"]); // -> [\"foo\"]<DefineList>\n\t * ```\n\t *\n\t * @param  {function(...)} func a constructor\n\t * @param  {*} rest arguments to be passed to the constructor\n\t * @return {Object}  if `func` returns an Object, that returned Object; otherwise a new instance of `func`\n\t */\n\t\"new\": function(func){\n\t\tvar args = [].slice.call(arguments, 1);\n\t\tvar makeNew = func[canSymbol.for(\"can.new\")];\n\t\tif(makeNew) {\n\t\t\treturn makeNew.apply(func, args);\n\t\t} else {\n\t\t\tvar context = Object.create(func.prototype);\n\t\t\tvar ret = func.apply(context, args);\n\t\t\tif(typeReflections.isPrimitive(ret)) {\n\t\t\t\treturn context;\n\t\t\t} else {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-reflect/reflections/call/call.js?");

/***/ }),

/***/ "../../../../node_modules/can-reflect/reflections/get-name/get-name.js":
/*!**********************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-reflect/reflections/get-name/get-name.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../../../node_modules/can-symbol/can-symbol.js\");\nvar typeReflections = __webpack_require__(/*! ../type/type */ \"../../../../node_modules/can-reflect/reflections/type/type.js\");\n\nvar getNameSymbol = canSymbol.for(\"can.getName\");\n\n/**\n * @function {Object, String} can-reflect.setName setName\n * @parent can-reflect/shape\n * @description Set a human-readable name of an object.\n *\n * @signature `setName(obj, value)`\n *\n * ```js\n * var f = function() {};\n *\n * canReflect.setName(f, \"myFunction\")\n * f.name //-> \"myFunction\"\n * ```\n *\n * @param {Object} obj   the object to set on\n * @param {String} value the value to set for the object\n */\nfunction setName(obj, nameGetter) {\n\tif (typeof nameGetter !== \"function\") {\n\t\tvar value = nameGetter;\n\t\tnameGetter = function() {\n\t\t\treturn value;\n\t\t};\n\t}\n\n\tObject.defineProperty(obj, getNameSymbol, {\n\t\tvalue: nameGetter\n\t});\n}\n\n/**\n * @function {Object} can-reflect.getName getName\n * @parent can-reflect/shape\n * @description Get the name of an object.\n *\n * @signature `getValue(obj)`\n *\n * @body\n *\n * The [@@@can.getName](can-symbol/symbols/getName.html) symbol is used to\n * provide objects human readable names; the main goal of these names is to help\n * users get a glance of what the object does and what it is used for.\n *\n * There are no hard rules to define names but CanJS uses the following convention\n * for consistent names across its observable types:\n *\n * - The name starts with the observable constructor name\n * - The constructor name is decorated with the following characters based on its type:\n *\t\t- `<>`: for [value-like](can-reflect.isValueLike.html) observables, e.g: `SimpleObservable<>`\n *\t\t- `[]`: for [list-like](can-reflect.isListLike.html) observables, e.g: `DefineList[]`\n *\t\t- `{}`: for [map-like](can-reflect.isMapLike.html) observables, e.g: `DefineMap{}`\n * - Any property that makes the instance unique (like ids) are printed inside\n *    the chars mentioned before.\n *\n * The example below shows how to implement [@@@can.getName](can-symbol/symbols/getName.html),\n * in a value-like observable (similar to [can-simple-observable]).\n *\n * ```js\n * var canReflect = require(\"can-reflect\");\n *\n * function MySimpleObservable(value) {\n *\t\tthis.value = value;\n * }\n *\n * canReflect.assignSymbols(MySimpleObservable.prototype, {\n *\t\t\"can.getName\": function() {\n *\t\t\t//!steal-remove-start\n *\t\t\tif (process.env.NODE_ENV !== 'production') {\n *\t\t\t\tvar value = JSON.stringify(this.value);\n *\t\t\t\treturn canReflect.getName(this.constructor) + \"<\" + value + \">\";\n *\t\t\t}\n *\t\t\t//!steal-remove-end\n *\t\t}\n * });\n * ```\n *\n * With that in place, `MySimpleObservable` can be used like this:\n *\n * ```js\n * var one = new MySimpleObservable(1);\n * canReflect.getName(one); // MySimpleObservable<1>\n * ```\n *\n * @param  {Object} obj The object to get from\n * @return {String} The human-readable name of the object\n */\nvar anonymousID = 0;\nfunction getName(obj) {\n\tvar type = typeof obj;\n\tif(obj === null || (type !== \"object\" && type !== \"function\")) {\n\t\treturn \"\"+obj;\n\t}\n\tvar nameGetter = obj[getNameSymbol];\n\tif (nameGetter) {\n\t\treturn nameGetter.call(obj);\n\t}\n\n\tif (type === \"function\") {\n\t\tif (!(\"name\" in obj)) {\n\t\t\t// IE doesn't support function.name natively\n\t\t\tobj.name = \"functionIE\" + anonymousID++;\n\t\t}\n\t\treturn obj.name;\n\t}\n\n\tif (obj.constructor && obj !== obj.constructor) {\n\t\tvar parent = getName(obj.constructor);\n\t\tif (parent) {\n\t\t\tif (typeReflections.isValueLike(obj)) {\n\t\t\t\treturn parent + \"<>\";\n\t\t\t}\n\n\t\t\tif (typeReflections.isMoreListLikeThanMapLike(obj)) {\n\t\t\t\treturn parent + \"[]\";\n\t\t\t}\n\n\t\t\tif (typeReflections.isMapLike(obj)) {\n\t\t\t\treturn parent + \"{}\";\n\t\t\t}\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nmodule.exports = {\n\tsetName: setName,\n\tgetName: getName\n};\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-reflect/reflections/get-name/get-name.js?");

/***/ }),

/***/ "../../../../node_modules/can-reflect/reflections/get-set/get-set.js":
/*!********************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-reflect/reflections/get-set/get-set.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../../../node_modules/can-symbol/can-symbol.js\");\nvar typeReflections = __webpack_require__(/*! ../type/type */ \"../../../../node_modules/can-reflect/reflections/type/type.js\");\n\nvar setKeyValueSymbol = canSymbol.for(\"can.setKeyValue\"),\n\tgetKeyValueSymbol = canSymbol.for(\"can.getKeyValue\"),\n\tgetValueSymbol = canSymbol.for(\"can.getValue\"),\n\tsetValueSymbol = canSymbol.for(\"can.setValue\");\n\nvar reflections = {\n\t/**\n\t * @function {Object, String, *} can-reflect.setKeyValue setKeyValue\n\t * @parent can-reflect/get-set\n\t * @description Set the value of a named property on a MapLike object.\n\t *\n\t * @signature `setKeyValue(obj, key, value)`\n\t *\n\t * Set the property on Map-like `obj`, identified by the String, Symbol or Object value `key`, to the value `value`.\n\t * The default behavior can be overridden on `obj` by implementing [can-symbol/symbols/setKeyValue @@@@can.setKeyValue],\n\t * otherwise native named property access is used for string keys, and `Object.defineProperty` is used to set symbols.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t *\n\t * canReflect.setKeyValue(foo, \"bar\", \"quux\");\n\t * foo[bar]; // -> \"quux\"\n\t * ```\n\t * @param  {Object} obj   the object to set on\n\t * @param  {String} key   the key for the property to set\n\t * @param  {*} value      the value to set on the object\n\t */\n\tsetKeyValue: function(obj, key, value){\n\t\tif( typeReflections.isSymbolLike(key) ) {\n\t\t\tif(typeof key === \"symbol\") {\n\t\t\t\tobj[key] = value;\n\t\t\t} else {\n\t\t\t\tObject.defineProperty(obj, key, {\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\twritable: true\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tvar setKeyValue = obj[setKeyValueSymbol];\n\t\tif(setKeyValue !== undefined) {\n\t\t\treturn setKeyValue.call(obj, key, value);\n\t\t} else {\n\t\t\tobj[key] = value;\n\t\t}\n\t},\n\t/**\n\t * @function {Object, String} can-reflect.getKeyValue getKeyValue\n\t * @parent can-reflect/get-set\n\t * @description Get the value of a named property on a MapLike object.\n\t *\n\t * @signature `getKeyValue(obj, key)`\n\t *\n\t * Retrieve the property on Map-like `obj` identified by the String or Symbol value `key`.  The default behavior\n\t * can be overridden on `obj` by implementing [can-symbol/symbols/getKeyValue @@@@can.getKeyValue],\n\t * otherwise native named property access is used.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t *\n\t * canReflect.getKeyValue(foo, \"bar\"); // -> \"baz\"\n\t * ```\n\t *\n\t * @param  {Object} obj   the object to get from\n\t * @param  {String} key   the key of the property to get\n\t */\n\tgetKeyValue: function(obj, key) {\n\t\tvar getKeyValue = obj[getKeyValueSymbol];\n\t\tif(getKeyValue) {\n\t\t\treturn getKeyValue.call(obj, key);\n\t\t}\n\t\treturn obj[key];\n\t},\n\t/**\n\t * @function {Object, String} can-reflect.deleteKeyValue deleteKeyValue\n\t * @parent can-reflect/get-set\n\t * @description Delete a named property from a MapLike object.\n\t *\n\t * @signature `deleteKeyValue(obj, key)`\n\t *\n\t * Remove the property identified by the String or Symbol `key` from the Map-like object `obj`, if possible.\n\t * Property definitions may interfere with deleting key values; the behavior on `obj` if `obj[key]` cannot\n\t * be deleted is undefined.  The default use of the native `delete` keyword can be overridden by `obj` if it\n\t * implements [can-symbol/symbols/deleteKeyValue @@@@can.deleteKeyValue].\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t * var quux = new CanMap({ thud: \"jeek\" });\n\t *\n\t * canReflect.deleteKeyValue(foo, \"bar\");\n\t * canReflect.deleteKeyValue(quux, \"thud\");\n\t *\n\t * \"bar\" in foo; // ->  true  -- DefineMaps use property defs which cannot be un-defined\n\t * foo.bar // -> undefined    --  but set values to undefined when deleting\n\t *\n\t * \"thud\" in quux; // -> false\n\t * quux.thud; // -> undefined\n\t * ```\n\t *\n\t * @param  {Object} obj   the object to delete on\n\t * @param  {String} key   the key for the property to delete\n\t */\n\tdeleteKeyValue: function(obj, key) {\n\t\tvar deleteKeyValue = obj[canSymbol.for(\"can.deleteKeyValue\")];\n\t\tif(deleteKeyValue) {\n\t\t\treturn deleteKeyValue.call(obj, key);\n\t\t}\n\t\tdelete obj[key];\n\t},\n\t/**\n\t * @function {Object} can-reflect.getValue getValue\n\t * @parent can-reflect/get-set\n\t * @description Get the value of an object with a gettable value\n\t *\n\t * @signature `getValue(obj)`\n\t *\n\t * Return the value of the Value-like object `obj`.  Unless `obj` implements\n\t * [can-symbol/symbols/getValue @@@@can.getValue], the result of `getValue` on\n\t * `obj` will always be `obj`.  Observable Map-like objects may want to implement\n\t * `@@@@can.getValue` to return non-observable or plain representations of themselves.\n\t *\n\t * ```js\n\t * var compute = canCompute(\"foo\");\n\t * var primitive = \"bar\";\n\t *\n\t * canReflect.getValue(compute); // -> \"foo\"\n\t * canReflect.getValue(primitive); // -> \"bar\"\n\t * ```\n\t *\n\t * @param  {Object} obj   the object to get from\n\t * @return {*} the value of the object via `@@can.getValue`, or the value itself.\n\t */\n\tgetValue: function(value){\n\t\tif(typeReflections.isPrimitive(value)) {\n\t\t\treturn value;\n\t\t}\n\t\tvar getValue = value[getValueSymbol];\n\t\tif(getValue) {\n\t\t\treturn getValue.call(value);\n\t\t}\n\t\treturn value;\n\t},\n\t/**\n\t * @function {Object, *} can-reflect.setValue setValue\n\t * @parent can-reflect/get-set\n\t * @description Set the value of a mutable object.\n\t *\n\t * @signature `setValue(obj, value)`\n\t *\n\t * Set the value of a Value-like object `obj` to the value `value`.  `obj` *must* implement\n\t * [can-symbol/symbols/setValue @@@@can.setValue] to be used with `canReflect.setValue`.\n\t * Map-like objects may want to implement `@@@@can.setValue` to merge objects of properties\n\t * into themselves.\n\t *\n\t * ```js\n\t * var compute = canCompute(\"foo\");\n\t * var plain = {};\n\t *\n\t * canReflect.setValue(compute, \"bar\");\n\t * compute(); // -> bar\n\t *\n\t * canReflect.setValue(plain, { quux: \"thud\" }); // throws \"can-reflect.setValue - Can not set value.\"\n\t * ```\n\t *\n\t * @param  {Object} obj   the object to set on\n\t * @param  {*} value      the value to set for the object\n\t */\n\tsetValue: function(item, value){\n\t\tvar setValue = item && item[setValueSymbol];\n\t\tif(setValue) {\n\t\t\treturn setValue.call(item, value);\n\t\t} else {\n\t\t\tthrow new Error(\"can-reflect.setValue - Can not set value.\");\n\t\t}\n\t},\n\n\tsplice: function(obj, index, removing, adding){\n\t\tvar howMany;\n\t\tif(typeof removing !== \"number\") {\n\t\t\tvar updateValues = obj[canSymbol.for(\"can.updateValues\")];\n\t\t\tif(updateValues) {\n\t\t\t\treturn updateValues.call(obj, index, removing, adding);\n\t\t\t}\n\t\t\thowMany = removing.length;\n\t\t} else {\n\t\t\thowMany = removing;\n\t\t}\n\n\t\tif(arguments.length <= 3){\n\t\t\tadding = [];\n\t\t}\n\n\t\tvar splice = obj[canSymbol.for(\"can.splice\")];\n\t\tif(splice) {\n\t\t\treturn splice.call(obj, index, howMany, adding);\n\t\t}\n\t\treturn [].splice.apply(obj, [index, howMany].concat(adding) );\n\t},\n\taddValues: function(obj, adding, index) {\n\t\tvar add = obj[canSymbol.for(\"can.addValues\")];\n\t\tif(add) {\n\t\t\treturn add.call(obj, adding, index);\n\t\t}\n\t\tif(Array.isArray(obj) && index === undefined) {\n\t\t\treturn obj.push.apply(obj, adding);\n\t\t}\n\t\treturn reflections.splice(obj, index, [], adding);\n\t},\n\tremoveValues: function(obj, removing, index) {\n\t\tvar removeValues = obj[canSymbol.for(\"can.removeValues\")];\n\t\tif(removeValues) {\n\t\t\treturn removeValues.call(obj, removing, index);\n\t\t}\n\t\tif(Array.isArray(obj) && index === undefined) {\n\t\t\tremoving.forEach(function(item){\n\t\t\t\tvar index = obj.indexOf(item);\n\t\t\t\tif(index >=0) {\n\t\t\t\t\tobj.splice(index, 1);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\treturn reflections.splice(obj, index, removing, []);\n\t}\n};\n/**\n * @function {Object, String} can-reflect.get get\n * @hide\n * @description an alias for [can-reflect.getKeyValue getKeyValue]\n */\nreflections.get = reflections.getKeyValue;\n/**\n * @function {Object, String} can-reflect.set set\n * @hide\n * @description an alias for [can-reflect.setKeyValue setKeyValue]\n */\nreflections.set = reflections.setKeyValue;\n/**\n * @function {Object, String} can-reflect.delete delete\n * @hide\n * @description an alias for [can-reflect.deleteKeyValue deleteKeyValue]\n */\nreflections[\"delete\"] = reflections.deleteKeyValue;\n\nmodule.exports = reflections;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-reflect/reflections/get-set/get-set.js?");

/***/ }),

/***/ "../../../../node_modules/can-reflect/reflections/helpers.js":
/*!************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-reflect/reflections/helpers.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../../../node_modules/can-symbol/can-symbol.js\");\n\nmodule.exports = {\n\tmakeGetFirstSymbolValue: function(symbolNames){\n\t\tvar symbols = symbolNames.map(function(name){\n\t\t\treturn canSymbol.for(name);\n\t\t});\n\t\tvar length = symbols.length;\n\n\t\treturn function getFirstSymbol(obj){\n\t\t\tvar index = -1;\n\n\t\t\twhile (++index < length) {\n\t\t\t\tif(obj[symbols[index]] !== undefined) {\n\t\t\t\t\treturn obj[symbols[index]];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t},\n\t// The `in` check is from jQuery’s fix for an iOS 8 64-bit JIT object length bug:\n\t// https://github.com/jquery/jquery/pull/2185\n\thasLength: function(list){\n\t\tvar type = typeof list;\n\t\tif(type === \"string\" || Array.isArray(list)) {\n\t\t\treturn true;\n\t\t}\n\t\tvar length = list && (type !== 'boolean' && type !== 'number' && \"length\" in list) && list.length;\n\n\t\t// var length = \"length\" in obj && obj.length;\n\t\treturn typeof list !== \"function\" &&\n\t\t\t( length === 0 || typeof length === \"number\" && length > 0 && ( length - 1 ) in list );\n\t}\n};\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-reflect/reflections/helpers.js?");

/***/ }),

/***/ "../../../../node_modules/can-reflect/reflections/observe/observe.js":
/*!********************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-reflect/reflections/observe/observe.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../../../node_modules/can-symbol/can-symbol.js\");\n\nvar slice = [].slice;\n\nfunction makeFallback(symbolName, fallbackName) {\n\treturn function(obj, event, handler, queueName){\n\t\tvar method = obj[canSymbol.for(symbolName)];\n\t\tif(method !== undefined) {\n\t\t\treturn method.call(obj, event, handler, queueName);\n\t\t}\n\t\treturn this[fallbackName].apply(this, arguments);\n\t};\n}\n\nfunction makeErrorIfMissing(symbolName, errorMessage){\n\treturn function(obj){\n\t\tvar method = obj[canSymbol.for(symbolName)];\n\t\tif(method !== undefined) {\n\t\t\tvar args = slice.call(arguments, 1);\n\t\t\treturn method.apply(obj, args);\n\t\t}\n\t\tthrow new Error(errorMessage);\n\t};\n}\n\nmodule.exports = {\n\t// KEY\n\t/**\n\t * @function {Object, String, function(*, *), String} can-reflect/observe.onKeyValue onKeyValue\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on a MapLike object, based on a key change\n\t *\n\t * @signature `onKeyValue(obj, key, handler, [queueName])`\n\t *\n\t * Register a handler on the Map-like object `obj` to trigger when the property key `key` changes.\n\t * `obj` *must* implement [can-symbol/symbols/onKeyValue @@@@can.onKeyValue] to be compatible with\n\t * can-reflect.onKeyValue.  The function passed as `handler` will receive the new value of the property\n\t * as the first argument, and the previous value of the property as the second argument.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * canReflect.onKeyValue(obj, \"foo\", function(newVal, oldVal) {\n\t * \tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n\t * });\n\t *\n\t * obj.foo = \"baz\";  // -> logs \"foo is now baz , was bar\"\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {String} key  the key to listen to\n\t * @param {function(*, *)} handler a callback function that recieves the new value\n\t * @param {String} [queueName]  the queue to dispatch events to\n\t */\n\tonKeyValue: makeFallback(\"can.onKeyValue\", \"onEvent\"),\n\t/**\n\t * @function {Object, String, function(*), String} can-reflect/observe.offKeyValue offKeyValue\n\t * @parent can-reflect/observe\n\t * @description  Unregister an event handler on a MapLike object, based on a key change\n\t *\n\t * @signature `offKeyValue(obj, key, handler, [queueName])`\n\t *\n\t * Unregister a handler from the Map-like object `obj` that had previously been registered with\n\t * [can-reflect/observe.onKeyValue onKeyValue]. The function passed as `handler` will no longer be called\n\t * when the value of `key` on `obj` changes.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * var handler = function(newVal, oldVal) {\n\t * \tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n\t * };\n\t *\n\t * canReflect.onKeyValue(obj, \"foo\", handler);\n\t * canReflect.offKeyValue(obj, \"foo\", handler);\n\t *\n\t * obj.foo = \"baz\";  // -> nothing is logged\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {String} key  the key to stop listening to\n\t * @param {function(*)} handler the callback function that should be removed from the event handlers for `key`\n\t * @param {String} [queueName]  the queue that the handler was set to receive events from\n\t */\n\toffKeyValue: makeFallback(\"can.offKeyValue\",\"offEvent\"),\n\n\t/**\n\t * @function {Object, function(Array)} can-reflect/observe.onKeys onKeys\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on a MapLike object, triggered on the key set changing\n\t *\n\t * @signature `onKeys(obj, handler)`\n\t *\n\t * Register an event handler on the Map-like object `obj` to trigger when `obj`'s keyset changes.\n\t * `obj` *must* implement [can-symbol/symbols/onKeys @@@@can.onKeys] to be compatible with\n\t * can-reflect.onKeys.  The function passed as `handler` will receive an Array of object diffs (see\n\t * [can-util/js/diff-object/diff-object diffObject] for the format) as its one argument.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * canReflect.onKeys(obj, function(diffs) {\n\t * \tconsole.log(diffs);\n\t * });\n\t *\n\t * obj.set(\"baz\", \"quux\");  // -> logs '[{\"property\": \"baz\", \"type\": \"add\", \"value\": \"quux\"}]'\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {function(Array)} handler the callback function to receive the diffs in the key set\n\t */\n\t// any key change (diff would normally happen)\n\tonKeys: makeErrorIfMissing(\"can.onKeys\",\"can-reflect: can not observe an onKeys event\"),\n\t/**\n\t * @function {Object, function(Array)} can-reflect/observe.onKeysAdded onKeysAdded\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on a MapLike object, triggered on new keys being added.\n\t *\n\t * @signature `onKeysAdded(obj, handler)`\n\t *\n\t * Register an event handler on the Map-like object `obj` to trigger when a new key or keys are set on\n\t * `obj`. `obj` *must* implement [can-symbol/symbols/onKeysAdded @@@@can.onKeysAdded] to be compatible with\n\t * can-reflect.onKeysAdded.  The function passed as `handler` will receive an Array of Strings as its one\n\t * argument.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * canReflect.onKeysAded(obj, function(newKeys) {\n\t * \tconsole.log(newKeys);\n\t * });\n\t *\n\t * foo.set(\"baz\", \"quux\");  // -> logs '[\"baz\"]'\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {function(Array)} handler the callback function to receive the array of added keys\n\t */\n\t// keys added at a certain point {key: 1}, index\n\tonKeysAdded: makeErrorIfMissing(\"can.onKeysAdded\",\"can-reflect: can not observe an onKeysAdded event\"),\n\t/**\n\t * @function {Object, function(Array)} can-reflect/observe.onKeysRemoved onKeysRemoved\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on a MapLike object, triggered on keys being deleted.\n\t *\n\t * @signature `onKeysRemoved(obj, handler)`\n\t *\n\t * Register an event handler on the Map-like object `obj` to trigger when a key or keys are removed from\n\t * `obj`'s keyset. `obj` *must* implement [can-symbol/symbols/onKeysRemoved @@@@can.onKeysRemoved] to be\n\t * compatible with can-reflect.onKeysAdded.  The function passed as `handler` will receive an Array of\n\t * Strings as its one argument.\n\t *\n\t * ```js\n\t * var obj = new CanMap({ foo: \"bar\" });\n\t * canReflect.onKeys(obj, function(diffs) {\n\t * \tconsole.log(JSON.stringify(diffs));\n\t * });\n\t *\n\t * foo.removeAttr(\"foo\");  // -> logs '[\"foo\"]'\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {function(Array)} handler the callback function to receive the array of removed keys\n\t */\n\tonKeysRemoved: makeErrorIfMissing(\"can.onKeysRemoved\",\"can-reflect: can not unobserve an onKeysRemoved event\"),\n\n\t/**\n\t * @function {Object, String} can-reflect/observe.getKeyDependencies getKeyDependencies\n\t * @parent can-reflect/observe\n\t * @description  Return the observable objects that compute to the value of a named property on an object\n\t *\n\t * @signature `getKeyDependencies(obj, key)`\n\t *\n\t * Return the observable objects that provide input values to generate the computed value of the\n\t * property `key` on Map-like object `obj`.  If `key` does not have dependencies on `obj`, returns `undefined`.\n\t * Otherwise returns an object with up to two keys: `keyDependencies` is a [can-util/js/cid-map/cid-map CIDMap] that\n\t * maps each Map-like object providing keyed values to an Array of the relevant keys; `valueDependencies` is a\n\t * [can-util/js/cid-set/cid-set CIDSet] that contains all Value-like dependencies providing their own values.\n\t *\n\t * `obj` *must* implement [can-symbol/symbols/getKeyDependencies @@@@can.getKeyDependencies] to work with\n\t * `canReflect.getKeyDependencies`.\n\t *\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ \"bar\": \"baz\" })\n\t * var obj = new (DefineMap.extend({\n\t * \t baz: {\n\t * \t   get: function() {\n\t * \t     return foo.bar;\n\t * \t   }\n\t * \t }\n\t * }))();\n\t *\n\t * canReflect.getKeyDependencies(obj, \"baz\");  // -> { valueDependencies: CIDSet }\n\t * ```\n\t *\n\t * @param {Object} obj the object to check for key dependencies\n\t * @param {String} key the key on the object to check\n\t * @return {Object} the observable values that this keyed value depends on\n\t */\n\tgetKeyDependencies: makeErrorIfMissing(\"can.getKeyDependencies\", \"can-reflect: can not determine dependencies\"),\n\n\t/**\n\t * @function {Object, String} can-reflect/observe.getWhatIChange getWhatIChange\n\t * @hide\n\t * @parent can-reflect/observe\n\t * @description Return the observable objects that derive their value from the\n\t * obj, passed in.\n\t *\n\t * @signature `getWhatIChange(obj, key)`\n\t *\n\t * `obj` *must* implement `@@@@can.getWhatIChange` to work with\n\t * `canReflect.getWhatIChange`.\n\t *\n\t * @param {Object} obj the object to check for what it changes\n\t * @param {String} [key] the key on the object to check\n\t * @return {Object} the observable values that derive their value from `obj`\n\t */\n\tgetWhatIChange: makeErrorIfMissing(\n\t\t\"can.getWhatIChange\",\n\t\t\"can-reflect: can not determine dependencies\"\n\t),\n\n\t/**\n\t * @function {Function} can-reflect/observe.getChangesDependencyRecord getChangesDependencyRecord\n\t * @hide\n\t * @parent can-reflect/observe\n\t * @description Return the observable objects that are mutated by the handler\n\t * passed in as argument.\n\t *\n\t * @signature `getChangesDependencyRecord(handler)`\n\t *\n\t * `handler` *must* implement `@@@@can.getChangesDependencyRecord` to work with\n\t * `canReflect.getChangesDependencyRecord`.\n\t *\n\t * ```js\n\t * var one = new SimpleObservable(\"one\");\n\t * var two = new SimpleObservable(\"two\");\n\t *\n\t * var handler = function() {\n\t *\ttwo.set(\"2\");\n\t * };\n\t *\n\t * canReflect.onValue(one, handler);\n\t * canReflect.getChangesDependencyRecord(handler); // -> { valueDependencies: new Set([two]) }\n\t * ```\n\t *\n\t * @param {Function} handler the event handler to check for what it changes\n\t * @return {Object} the observable values that are mutated by the handler\n\t */\n\tgetChangesDependencyRecord: function getChangesDependencyRecord(handler) {\n\t\tvar fn = handler[canSymbol.for(\"can.getChangesDependencyRecord\")];\n\n\t\tif (typeof fn === \"function\") {\n\t\t\treturn fn();\n\t\t}\n\t},\n\n\t/**\n\t * @function {Object, String} can-reflect/observe.keyHasDependencies keyHasDependencies\n\t * @parent can-reflect/observe\n\t * @description  Determine whether the value for a named property on an object is bound to other events\n\t *\n\t * @signature `keyHasDependencies(obj, key)`\n\t *\n\t * Returns `true` if the computed value of the property `key` on Map-like object `obj` derives from other values.\n\t * Returns `false` if `key` is computed on `obj` but does not have dependencies on other objects. If `key` is not\n\t * a computed value on `obj`, returns `undefined`.\n\t *\n\t * `obj` *must* implement [can-symbol/symbols/keyHasDependencies @@@@can.keyHasDependencies] to work with\n\t * `canReflect.keyHasDependencies`.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ \"bar\": \"baz\" })\n\t * var obj = new (DefineMap.extend({\n\t * \t baz: {\n\t * \t   get: function() {\n\t * \t     return foo.bar;\n\t * \t   }\n\t * \t },\n\t * \t quux: {\n\t * \t \t get: function() {\n\t * \t \t   return \"thud\";\n\t * \t \t }\n\t * \t }\n\t * }))();\n\t *\n\t * canReflect.keyHasDependencies(obj, \"baz\");  // -> true\n\t * canReflect.keyHasDependencies(obj, \"quux\");  // -> false\n\t * canReflect.keyHasDependencies(foo, \"bar\");  // -> undefined\n\t * ```\n\t *\n\t * @param {Object} obj the object to check for key dependencies\n\t * @param {String} key the key on the object to check\n\t * @return {Boolean} `true` if there are other objects that may update the keyed value; `false` otherwise\n\t *\n\t */\n\t// TODO: use getKeyDeps once we know what that needs to look like\n\tkeyHasDependencies: makeErrorIfMissing(\"can.keyHasDependencies\",\"can-reflect: can not determine if this has key dependencies\"),\n\n\t// VALUE\n\t/**\n\t * @function {Object, function(*)} can-reflect/observe.onValue onValue\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on an observable ValueLike object, based on a change in its value\n\t *\n\t * @signature `onValue(handler, [queueName])`\n\t *\n\t * Register an event handler on the Value-like object `obj` to trigger when its value changes.\n\t * `obj` *must* implement [can-symbol/symbols/onValue @@@@can.onValue] to be compatible with\n\t * can-reflect.onKeyValue.  The function passed as `handler` will receive the new value of `obj`\n\t * as the first argument, and the previous value of `obj` as the second argument.\n\t *\n\t * ```js\n\t * var obj = canCompute(\"foo\");\n\t * canReflect.onValue(obj, function(newVal, oldVal) {\n\t * \tconsole.log(\"compute is now\", newVal, \", was\", oldVal);\n\t * });\n\t *\n\t * obj(\"bar\");  // -> logs \"compute is now bar , was foo\"\n\t * ```\n\t *\n\t * @param {*} obj  any object implementing @@can.onValue\n\t * @param {function(*, *)} handler  a callback function that receives the new and old values\n\t */\n\tonValue: makeErrorIfMissing(\"can.onValue\",\"can-reflect: can not observe value change\"),\n\t/**\n\t * @function {Object, function(*)} can-reflect/observe.offValue offValue\n\t * @parent can-reflect/observe\n\t * @description  Unregister an value change handler from an observable ValueLike object\n\t *\n\t * @signature `offValue(handler, [queueName])`\n\t *\n\t * Unregister an event handler from the Value-like object `obj` that had previously been registered with\n\t * [can-reflect/observe.onValue onValue]. The function passed as `handler` will no longer be called\n\t * when the value of `obj` changes.\n\t *\n\t * ```js\n\t * var obj = canCompute( \"foo\" );\n\t * var handler = function(newVal, oldVal) {\n\t * \tconsole.log(\"compute is now\", newVal, \", was\", oldVal);\n\t * };\n\t *\n\t * canReflect.onKeyValue(obj, handler);\n\t * canReflect.offKeyValue(obj, handler);\n\t *\n\t * obj(\"baz\");  // -> nothing is logged\n\t * ```\n\t *\n\t * @param {*} obj\n\t * @param {function(*)} handler\n\t */\n\toffValue: makeErrorIfMissing(\"can.offValue\",\"can-reflect: can not unobserve value change\"),\n\n\t/**\n\t * @function {Object} can-reflect/observe.getValueDependencies getValueDependencies\n\t * @parent can-reflect/observe\n\t * @description  Return all the events that bind to the value of an observable, Value-like object\n\t *\n\t * @signature `getValueDependencies(obj)`\n\t *\n\t * Return the observable objects that provide input values to generate the computed value of the\n\t * Value-like object `obj`.  If `obj` does not have dependencies, returns `undefined`.\n\t * Otherwise returns an object with up to two keys: `keyDependencies` is a [can-util/js/cid-map/cid-map CIDMap] that\n\t * maps each Map-like object providing keyed values to an Array of the relevant keys; `valueDependencies` is a\n\t * [can-util/js/cid-set/cid-set CIDSet] that contains all Value-like dependencies providing their own values.\n\t *\n\t * `obj` *must* implement [can-symbol/symbols/getValueDependencies @@@@can.getValueDependencies] to work with\n\t * `canReflect.getValueDependencies`.\n\t *\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ \"bar\": \"baz\" })\n\t * var obj = canCompute(function() {\n\t * \t return foo.bar;\n\t * });\n\t *\n\t * canReflect.getValueDependencies(obj);  // -> { valueDependencies: CIDSet } because `obj` is internally backed by\n\t * a [can-observation]\n\t * ```\n\t *\n\t * @param {Object} obj the object to check for value dependencies\n\t * @return {Object} the observable objects that `obj`'s value depends on\n\t *\n\t */\n\tgetValueDependencies: makeErrorIfMissing(\"can.getValueDependencies\",\"can-reflect: can not determine dependencies\"),\n\n\t/**\n\t * @function {Object} can-reflect/observe.valueHasDependencies valueHasDependencies\n\t * @parent can-reflect/observe\n\t * @description  Determine whether the value of an observable object is bound to other events\n\t *\n\t * @signature `valueHasDependencies(obj)`\n\t *\n\t * Returns `true` if the computed value of the Value-like object `obj` derives from other values.\n\t * Returns `false` if `obj` is computed but does not have dependencies on other objects. If `obj` is not\n\t * a computed value, returns `undefined`.\n\t *\n\t * `obj` *must* implement [can-symbol/symbols/valueHasDependencies @@@@can.valueHasDependencies] to work with\n\t * `canReflect.valueHasDependencies`.\n\t *\n\t * ```js\n\t * var foo = canCompute( \"bar\" );\n\t * var baz = canCompute(function() {\n\t * \t return foo();\n\t * });\n\t * var quux = \"thud\";\n\t * var jeek = canCompute(function(plonk) {\n\t * \t if(argument.length) {\n\t * \t \t  quux = plonk;\n\t * \t }\n\t * \t return quux;\n\t * });\n\t *\n\t * canReflect.valueHasDependencies(baz);  // -> true\n\t * canReflect.valueHasDependencies(jeek);  // -> false\n\t * canReflect.valueHasDependencies(foo);  // -> undefined\n\t * ```\n\t *\n\t * @param {Object} obj the object to check for dependencies\n\t * @return {Boolean} `true` if there are other dependencies that may update the object's value; `false` otherwise\n\t *\n\t */\n\tvalueHasDependencies: makeErrorIfMissing(\"can.valueHasDependencies\",\"can-reflect: can not determine if value has dependencies\"),\n\n\t// PATCHES\n\t/**\n\t * @function {Object, function(*), String} can-reflect/observe.onPatches onPatches\n\t * @parent can-reflect/observe\n\t * @description  Register an handler on an observable that listens to any key changes\n\t *\n\t * @signature `onPatches(obj, handler, [queueName])`\n\t *\n\t * Register an event handler on the object `obj` that fires when anything changes on an object: a key value is added,\n\t * an existing key has is value changed, or a key is deleted from the object.\n\t *\n\t * If object is an array-like and the changed property includes numeric indexes, patch sets will include array-specific\n\t * patches in addition to object-style patches\n\t *\n\t * For more on the patch formats, see [can-util/js/diff-object/diff-object] and [can-util/js/diff-array/diff-array].\n\t *\n\t * ```js\n\t * var obj = new DefineMap({});\n\t * var handler = function(patches) {\n\t * \tconsole.log(patches);\n\t * };\n\t *\n\t * canReflect.onPatches(obj, handler);\n\t * obj.set(\"foo\", \"bar\");  // logs [{ type: \"add\", property: \"foo\", value: \"bar\" }]\n\t * obj.set(\"foo\", \"baz\");  // logs [{ type: \"set\", property: \"foo\", value: \"baz\" }]\n\t *\n\t * var arr = new DefineList([]);\n\t * canReflect.onPatches(arr, handler);\n\t * arr.push(\"foo\");  // logs [{type: \"add\", property:\"0\", value: \"foo\"},\n\t *                            {index: 0, deleteCount: 0, insert: [\"foo\"]}]\n   * arr.pop();  // logs [{type: \"remove\", property:\"0\"},\n\t *                            {index: 0, deleteCount: 1, insert: []}]\n\t * ```\n\t *\n\t * @param {*} obj\n\t * @param {function(*)} handler\n\t * @param {String} [queueName] the name of a queue in [can-queues]; dispatches to `handler` will happen on this queue\n\t */\n\tonPatches: makeErrorIfMissing(\"can.onPatches\", \"can-reflect: can not observe patches on object\"),\n\t/**\n\t * @function {Object, function(*), String} can-reflect/observe.offPatches offPatches\n\t * @parent can-reflect/observe\n\t * @description  Unregister an object patches handler from an observable object\n\t *\n\t * @signature `offPatches(obj, handler, [queueName])`\n\t *\n\t * Unregister an event handler from the object `obj` that had previously been registered with\n\t * [can-reflect/observe.onPatches onPatches]. The function passed as `handler` will no longer be called\n\t * when `obj` has key or index changes.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({});\n\t * var handler = function(patches) {\n\t * \tconsole.log(patches);\n\t * };\n\t *\n\t * canReflect.onPatches(obj, handler);\n\t * canReflect.offPatches(obj, handler);\n\t *\n\t * obj.set(\"foo\", \"bar\");  // nothing is logged\n\t * ```\n\t *\n\t * @param {*} obj\n\t * @param {function(*)} handler\n\t * @param {String} [queueName] the name of the queue in [can-queues] the handler was registered under\n\t */\n\toffPatches: makeErrorIfMissing(\"can.offPatches\", \"can-reflect: can not unobserve patches on object\"),\n\n\t/**\n\t * @function {Object, function(*)} can-reflect/observe.onInstancePatches onInstancePatches\n\t * @parent can-reflect/observe\n\t *\n\t * @description Registers a handler that listens to patch events on any instance\n\t *\n\t * @signature `onInstancePatches(Type, handler(instance, patches))`\n\t *\n\t * Listens to patch changes on any instance of `Type`. This is used by [can-connect]\n\t * to know when a potentially `unbound` instance's `id` changes. If the `id` changes,\n\t * the instance can be moved into the store while it is being saved. E.g:\n\t *\n\t * ```js\n\t * canReflect.onInstancePatches(Map, function onInstancePatches(instance, patches) {\n\t *\tpatches.forEach(function(patch) {\n\t *\t\tif (\n\t *\t\t\t(patch.type === \"add\" || patch.type === \"set\") &&\n\t *\t\t\tpatch.key === connection.idProp &&\n\t *\t\t\tcanReflect.isBound(instance)\n\t *\t\t) {\n\t *\t\t\tconnection.addInstanceReference(instance);\n\t *\t\t}\n\t *\t});\n\t *});\n\t * ```\n\t *\n\t * @param {*} Type\n\t * @param {function(*)} handler\n\t */\n\tonInstancePatches: makeErrorIfMissing(\n\t\t\"can.onInstancePatches\",\n\t\t\"can-reflect: can not observe onInstancePatches on Type\"\n\t),\n\n\t/**\n\t * @function {Object, function(*)} can-reflect/observe.offInstancePatches offInstancePatches\n\t * @parent can-reflect/observe\n\t *\n\t * @description Unregisters a handler registered through [can-reflect/observe.onInstancePatches]\n\t *\n\t * @signature `offInstancePatches(Type, handler(instance, patches))`\n\t *\n\t * ```js\n\t * canReflect.offInstancePatches(Map, onInstancePatches);\n\t * ```\n\t *\n\t * @param {*} Type\n\t * @param {function(*)} handler\n\t */\n\toffInstancePatches: makeErrorIfMissing(\n\t\t\"can.offInstancePatches\",\n\t\t\"can-reflect: can not unobserve onInstancePatches on Type\"\n\t),\n\n\t// HAS BINDINGS VS DOES NOT HAVE BINDINGS\n\t/**\n\t * @function {Object, function(*), String} can-reflect/observe.onInstanceBoundChange onInstanceBoundChange\n\t * @parent can-reflect/observe\n\t * @description Listen to when observables of a type are bound and unbound.\n\t *\n\t * @signature `onInstanceBoundChange(Type, handler, [queueName])`\n\t *\n\t * Register an event handler on the object `Type` that fires when instances of the type become bound (the first handler is added)\n\t * or unbound (the last remaining handler is removed). The function passed as `handler` will be called\n\t * with the `instance` as the first argument and `true` as the second argument when `instance` gains its first binding,\n\t * and called with `false` when `instance` loses its\n\t * last binding.\n\t *\n\t * ```js\n\t * Person = DefineMap.extend({ ... });\n\t *\n\t * var person = Person({});\n\t * var handler = function(instance, newVal) {\n\t * \tconsole.log(instance, \"bound state is now\", newVal);\n\t * };\n\t * var keyHandler = function() {};\n\t *\n\t * canReflect.onInstanceBoundChange(Person, handler);\n\t * canReflect.onKeyValue(obj, \"name\", keyHandler);  // logs person Bound state is now true\n\t * canReflect.offKeyValue(obj, \"name\", keyHandler);  // logs person Bound state is now false\n\t * ```\n\t *\n\t * @param {function} Type A constructor function\n\t * @param {function(*,Boolean)} handler(instance,isBound) A function called with the `instance` whose bound status changed and the state of the bound status.\n\t * @param {String} [queueName] the name of a queue in [can-queues]; dispatches to `handler` will happen on this queue\n\t */\n\tonInstanceBoundChange: makeErrorIfMissing(\"can.onInstanceBoundChange\", \"can-reflect: can not observe bound state change in instances.\"),\n\t/**\n\t * @function {Object, function(*), String} can-reflect/observe.offInstanceBoundChange offInstanceBoundChange\n\t * @parent can-reflect/observe\n\t * @description Stop listening to when observables of a type are bound and unbound.\n\t *\n\t * @signature `offInstanceBoundChange(Type, handler, [queueName])`\n\t *\n\t * Unregister an event handler from the type `Type` that had previously been registered with\n\t * [can-reflect/observe.onInstanceBoundChange onInstanceBoundChange]. The function passed as `handler` will no longer be called\n\t * when instances of `Type` gains its first or loses its last binding.\n\t *\n\t * ```js\n\t * Person = DefineMap.extend({ ... });\n\t *\n\t * var person = Person({});\n\t * var handler = function(instance, newVal) {\n\t * \tconsole.log(instance, \"bound state is now\", newVal);\n\t * };\n\t * var keyHandler = function() {};\n\t *\n\t * canReflect.onInstanceBoundChange(Person, handler);\n\t * canReflect.offInstanceBoundChange(Person, handler);\n\t * canReflect.onKeyValue(obj, \"name\", keyHandler);  // nothing is logged\n\t * canReflect.offKeyValue(obj, \"name\", keyHandler); // nothing is logged\n\t * ```\n\t *\n\t * @param {function} Type A constructor function\n\t * @param {function(*,Boolean)} handler(instance,isBound) The `handler` passed to `canReflect.onInstanceBoundChange`.\n\t * @param {String} [queueName] the name of the queue in [can-queues] the handler was registered under\n\t */\n\toffInstanceBoundChange: makeErrorIfMissing(\"can.offInstanceBoundChange\", \"can-reflect: can not unobserve bound state change\"),\n\t/**\n\t * @function {Object} can-reflect/observe.isBound isBound\n\t * @parent can-reflect/observe\n\t * @description  Determine whether any listeners are bound to the observable object\n\t *\n\t * @signature `isBound(obj)`\n\t *\n\t * `isBound` queries an observable object to find out whether any listeners have been set on it using\n\t * [can-reflect/observe.onKeyValue onKeyValue] or [can-reflect/observe.onValue onValue]\n\t *\n\t * ```js\n\t * var obj = new DefineMap({});\n\t * var handler = function() {};\n\t * canReflect.isBound(obj); // -> false\n\t * canReflect.onKeyValue(obj, \"foo\", handler);\n\t * canReflect.isBound(obj); // -> true\n\t * canReflect.offKeyValue(obj, \"foo\", handler);\n\t * canReflect.isBound(obj); // -> false\n\t * ```\n\t *\n\t * @param {*} obj\n\t * @return {Boolean} `true` if obj has at least one key-value or value listener, `false` otherwise\n\t */\n\tisBound: makeErrorIfMissing(\"can.isBound\", \"can-reflect: cannot determine if object is bound\"),\n\n\t// EVENT\n\t/**\n\t * @function {Object, String, function(*)} can-reflect/observe.onEvent onEvent\n\t * @parent can-reflect/observe\n\t * @description  Register a named event handler on an observable object\n\t *\n\t * @signature `onEvent(obj, eventName, callback)`\n\t *\n\t *\n\t * Register an event handler on the object `obj` to trigger when the event `eventName` is dispatched.\n\t * `obj` *must* implement [can-symbol/symbols/onKeyValue @@@@can.onEvent] or `.addEventListener()` to be compatible\n\t * with can-reflect.onKeyValue.  The function passed as `callback` will receive the event descriptor as the first\n\t * argument, and any data passed to the event dispatch as subsequent arguments.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * canReflect.onEvent(obj, \"foo\", function(ev, newVal, oldVal) {\n\t * \tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n\t * });\n\t *\n\t * canEvent.dispatch.call(obj, \"foo\", [\"baz\", \"quux\"]);  // -> logs \"foo is now baz , was quux\"\n\t * ```\n\t *\n\t * @param {Object} obj the object to bind a new event handler to\n\t * @param {String} eventName the name of the event to bind the handler to\n\t * @param {function(*)} callback  the handler function to bind to the event\n\t */\n\tonEvent: function(obj, eventName, callback, queue){\n\t\tif(obj) {\n\t\t\tvar onEvent = obj[canSymbol.for(\"can.onEvent\")];\n\t\t\tif(onEvent !== undefined) {\n\t\t\t\treturn onEvent.call(obj, eventName, callback, queue);\n\t\t\t} else if(obj.addEventListener) {\n\t\t\t\tobj.addEventListener(eventName, callback, queue);\n\t\t\t}\n\t\t}\n\t},\n\t/**\n\t * @function {Object, String, function(*)} can-reflect/observe.offValue offEvent\n\t * @parent can-reflect/observe\n\t * @description  Unregister an event handler on a MapLike object, based on a key change\n\t *\n\t * @signature `offEvent(obj, eventName, callback)`\n\t *\n\t * Unregister an event handler from the object `obj` that had previously been registered with\n\t * [can-reflect/observe.onEvent onEvent]. The function passed as `callback` will no longer be called\n\t * when the event named `eventName` is dispatched on `obj`.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * var handler = function(ev, newVal, oldVal) {\n\t * \tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n\t * };\n\t *\n\t * canReflect.onEvent(obj, \"foo\", handler);\n\t * canReflect.offEvent(obj, \"foo\", handler);\n\t *\n\t * canEvent.dispatch.call(obj, \"foo\", [\"baz\", \"quux\"]);  // -> nothing is logged\n\t * ```\n\t *\n\t * @param {Object} obj the object to unbind an event handler from\n\t * @param {String} eventName the name of the event to unbind the handler from\n\t * @param {function(*)} callback the handler function to unbind from the event\n\t */\n\toffEvent: function(obj, eventName, callback, queue){\n\t\tif(obj) {\n\t\t\tvar offEvent = obj[canSymbol.for(\"can.offEvent\")];\n\t\t\tif(offEvent !== undefined) {\n\t\t\t\treturn offEvent.call(obj, eventName, callback, queue);\n\t\t\t}  else if(obj.removeEventListener) {\n\t\t\t\tobj.removeEventListener(eventName, callback, queue);\n\t\t\t}\n\t\t}\n\n\t},\n\t/**\n\t * @function {function} can-reflect/setPriority setPriority\n\t * @parent can-reflect/observe\n\t * @description  Provide a priority for when an observable that derives its\n\t * value should be re-evaluated.\n\t *\n\t * @signature `setPriority(obj, priority)`\n\t *\n\t * Calls an underlying `@@can.setPriority` symbol on `obj` if it exists with `priorty`.\n\t * Returns `true` if a priority was set, `false` if otherwise.\n\t *\n\t * Lower priorities (`0` being the lowest), will be an indication to run earlier than\n\t * higher priorities.\n\t *\n\t * ```js\n\t * var obj = canReflect.assignSymbols({},{\n\t *   \"can.setPriority\": function(priority){\n\t *     return this.priority = priority;\n\t *   }\n\t * });\n\t *\n\t * canReflect.setPriority(obj, 0) //-> true\n\t * obj.priority //-> 0\n\t *\n\t * canReflect.setPriority({},20) //-> false\n\t * ```\n\t *\n\t * @param {Object} obj An observable that will update its priority.\n\t * @param {Number} priority The priority number.  Lower priorities (`0` being the lowest),\n\t * indicate to run earlier than higher priorities.\n\t * @return {Boolean} `true` if a priority was able to be set, `false` if otherwise.\n\t *\n\t * @body\n\t *\n\t * ## Use\n\t *\n\t * There's often a need to specify the order of re-evaluation for\n\t * __observables__ that derive (or compute) their value from other observables.\n\t *\n\t * This is needed by templates to avoid unnecessary re-evaluation.  Say we had the following template:\n\t *\n\t * ```js\n\t * {{#if value}}\n\t *   {{value}}\n\t * {{/if}}\n\t * ```\n\t *\n\t * If `value` became falsey, we'd want the `{{#if}}` to be aware of it before\n\t * the `{{value}}` magic tags updated. We can do that by setting priorities:\n\t *\n\t * ```js\n\t * canReflect.setPriority(magicIfObservable, 0);\n\t * canReflect.setPriority(magicValueObservable,1);\n\t * ```\n\t *\n\t * Internally, those observables will use that `priority` to register their\n\t * re-evaluation with the `derive` queue in [can-queues].\n\t *\n\t */\n\tsetPriority: function(obj, priority) {\n\t\tif(obj) {\n\t\t\tvar setPriority =  obj[canSymbol.for(\"can.setPriority\")];\n\t\t\tif(setPriority !== undefined) {\n\t\t\t\tsetPriority.call(obj, priority);\n\t\t\t \treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\t/**\n\t * @function {function} can-reflect/getPriority getPriority\n\t * @parent can-reflect/observe\n\t * @description  Read the priority for an observable that derives its\n\t * value.\n\t *\n\t * @signature `getPriority(obj)`\n\t *\n\t * Calls an underlying `@@can.getPriority` symbol on `obj` if it exists\n\t * and returns its value. Read [can-reflect/setPriority] for more information.\n\t *\n\t *\n\t *\n\t * @param {Object} obj An observable.\n\t * @return {Undefined|Number} Returns the priority number if\n\t * available, undefined if this object does not support the `can.getPriority`\n\t * symbol.\n\t *\n\t * @body\n\t *\n\t */\n\tgetPriority: function(obj) {\n\t\tif(obj) {\n\t\t\tvar getPriority =  obj[canSymbol.for(\"can.getPriority\")];\n\t\t\tif(getPriority !== undefined) {\n\t\t\t\treturn getPriority.call(obj);\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n};\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-reflect/reflections/observe/observe.js?");

/***/ }),

/***/ "../../../../node_modules/can-reflect/reflections/shape/schema/schema.js":
/*!************************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-reflect/reflections/shape/schema/schema.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../../../node_modules/can-symbol/can-symbol.js\");\nvar typeReflections = __webpack_require__(/*! ../../type/type */ \"../../../../node_modules/can-reflect/reflections/type/type.js\");\nvar getSetReflections = __webpack_require__(/*! ../../get-set/get-set */ \"../../../../node_modules/can-reflect/reflections/get-set/get-set.js\");\nvar shapeReflections = __webpack_require__(/*! ../shape */ \"../../../../node_modules/can-reflect/reflections/shape/shape.js\");\n\nvar getSchemaSymbol = canSymbol.for(\"can.getSchema\"),\n    isMemberSymbol = canSymbol.for(\"can.isMember\"),\n    newSymbol = canSymbol.for(\"can.new\");\n\nfunction comparator(a, b) {\n    return a.localeCompare(b);\n}\n\nfunction sort(obj) {\n    if(typeReflections.isPrimitive(obj) || obj instanceof Date) {\n        return obj;\n    }\n    var out;\n    if (typeReflections.isListLike(obj)) {\n        out = [];\n        shapeReflections.eachKey(obj, function(item){\n            out.push(sort(item));\n        });\n        return out;\n    }\n    if( typeReflections.isMapLike(obj) ) {\n\n        out = {};\n\n        shapeReflections.getOwnKeys(obj).sort(comparator).forEach(function (key) {\n            out[key] = sort( getSetReflections.getKeyValue(obj, key) );\n        });\n\n        return out;\n    }\n\n\n    return obj;\n}\n\nfunction isPrimitiveConverter(Type){\n    return Type === Number || Type === String || Type === Boolean;\n}\n\nvar schemaReflections =  {\n    /**\n\t * @function can-reflect.getSchema getSchema\n\t * @parent can-reflect/shape\n\t * @description Returns the schema for a type or value.\n\t *\n\t * @signature `getSchema(valueOrType)`\n\t *\n     * Calls the `@can.getSchema` property on the `valueOrType` argument. If it's not available and\n     * `valueOrType` has a `constructor` property, calls the `constructor[@can.getSchema]`\n     * and returns the result.\n     *\n     * ```js\n     * import canReflect from \"can-reflect\";\n     *\n     * var Type = DefineMap.extend({\n     *   name: \"string\",\n     *   id: \"number\"\n     * });\n     *\n     * canReflect.getSchema( Type ) //-> {\n     * //   type: \"map\",\n     * //   keys: {\n     * //     name: MaybeString\n     * //     id: MaybeNumber\n     * //   }\n     * // }\n     * ```\n\t *\n\t *\n\t * @param  {Object|Function} valueOrType A value, constructor function, or class to get the schema from.\n\t * @return {Object} A schema. A schema for a [can-reflect.isMapLike] looks like:\n     *\n     *\n     * ```js\n     * {\n     *   type: \"map\",\n     *   identity: [\"id\"],\n     *   keys: {\n     *     id: Number,\n     *     name: String,\n     *     complete: Boolean,\n     *     owner: User\n     *   }\n     * }\n     * ```\n     *\n     * A schema for a list looks like:\n     *\n     * ```js\n     * {\n     *   type: \"list\",\n     *   values: String\n     *   keys: {\n     *     count: Number\n     *   }\n     * }\n     * ```\n     *\n\t */\n    getSchema: function(type){\n        if (type === undefined) {\n            return undefined;\n        }\n        var getSchema = type[getSchemaSymbol];\n        if(getSchema === undefined ) {\n            type = type.constructor;\n            getSchema = type && type[getSchemaSymbol];\n        }\n        return getSchema !== undefined ? getSchema.call(type) : undefined;\n    },\n    /**\n\t * @function can-reflect.getIdentity getIdentity\n\t * @parent can-reflect/shape\n\t * @description Get a unique primitive representing an object.\n\t *\n\t * @signature `getIdentity( object [,schema] )`\n\t *\n\t * This uses the object's schema, or the provided schema to return a unique string or number that\n     * represents the object.\n     *\n     * ```js\n     * import canReflect from \"can-reflect\";\n     *\n     * canReflect.getIdentity({id: 5}, {identity: [\"id\"]}) //-> 5\n     * ```\n     *\n     * If the schema has multiple identity keys, the identity keys and values\n     * are return stringified (and sorted):\n     *\n     * ```js\n     * canReflect.getIdentity(\n     *   {z: \"Z\", a: \"A\", foo: \"bar\"},\n     *   {identity: [\"a\",\"b\"]}) //-> '{\"a\":\"A\",\"b\":\"B\"}'\n     * ```\n\t *\n\t * @param  {Object|Function} object A map-like object.\n     * @param {Object} [schema] A schema object with an `identity` array of the unique\n     * keys of the object like:\n     *   ```js\n     *   {identity: [\"id\"]}\n     *   ```\n\t * @return {Number|String} A value that uniquely represents the object.\n\t */\n    getIdentity: function(value, schema){\n        schema = schema || schemaReflections.getSchema(value);\n        if(schema === undefined) {\n            throw new Error(\"can-reflect.getIdentity - Unable to find a schema for the given value.\");\n        }\n\n        var identity = schema.identity;\n        if(!identity || identity.length === 0) {\n            throw new Error(\"can-reflect.getIdentity - Provided schema lacks an identity property.\");\n        } else if(identity.length === 1) {\n            return getSetReflections.getKeyValue(value, identity[0]);\n        } else {\n            var id = {};\n            identity.forEach(function(key){\n                id[key] = getSetReflections.getKeyValue(value, key);\n            });\n            return JSON.stringify(schemaReflections.cloneKeySort(id));\n        }\n    },\n    /**\n\t * @function can-reflect.cloneKeySort cloneKeySort\n\t * @parent can-reflect/shape\n\t * @description Copy a value while sorting its keys.\n\t *\n\t * @signature `cloneKeySort(value)`\n\t *\n     * `cloneKeySort` returns a copy of `value` with its [can-reflect.isMapLike]\n     * key values sorted. If you just want a copy of a value,\n     * use [can-reflect.serialize].\n     *\n     * ```js\n     * import canRefect from \"can-reflect\";\n     *\n     * canReflect.cloneKeySort({z: \"Z\", a: \"A\"}) //-> {a:\"A\",z:\"Z\"}\n     * ```\n     *\n     * Nested objects are also sorted.\n\t *\n     * This is useful if you need to store a representation of an object that can be used as a\n     * key.\n\t *\n\t * @param  {Object} value An object or array.\n\t * @return {Object} A copy of the object with its keys sorted.\n\t */\n    cloneKeySort: function(obj) {\n        return sort(obj);\n    },\n    /**\n\t * @function can-reflect.convert convert\n\t * @parent can-reflect/shape\n\t * @description Convert one value to another type.\n\t *\n\t * @signature `convert(value, Type)`\n\t *\n     * `convert` attempts to convert `value` to the type specified by `Type`.\n     *\n     * ```js\n     * import canRefect from \"can-reflect\";\n     *\n     * canReflect.convert(\"1\", Number) //-> 1\n     * ```\n     *\n     * `convert` works by performing the following logic:\n     *\n     * 1. If the `Type` is a primitive like `Number`, `String`, `Boolean`, the\n     *    `value` will be passed to the `Type` function and the result returned.\n     *    ```js\n     *    return Type(value);\n     *    ```\n     * 2. The value will be checked if it is already an instance of the type\n     *    by performing the following:\n     *    1. If the `Type` has a `can.isMember` symbol value, that value will be used\n     *       to determine if the `value` is already an instance.\n     *    2. If the `Type` is a [can-reflect.isConstructorLike] function, `instanceof Type`\n     *       will be used to check if `value` is already an instance.\n     * 3. If `value` is already an instance, `value` will be returned.\n     * 4. If `Type` has a `can.new` symbol, `value` will be passed to it and the result\n     *    returned.\n     * 5. If `Type` is a [can-reflect.isConstructorLike] function, `new Type(value)` will be\n     *    called the the result returned.\n     * 6. If `Type` is a regular function, `Type(value)` will be called and the result returned.\n     * 7. If a value hasn't been returned, an error is thrown.\n\t *\n\t * @param  {Object|Primitive} value A value to be converted.\n     * @param  {Object|Function} Type A constructor function or an object that implements the\n     * necessary symbols.\n\t * @return {Object} The `value` converted to a member of `Type`.\n\t */\n    convert: function(value, Type){\n        if(isPrimitiveConverter(Type)) {\n            return Type(value);\n        }\n        // check if value is already a member\n        var isMemberTest = Type[isMemberSymbol],\n            isMember = false,\n            type = typeof Type,\n            createNew = Type[newSymbol];\n        if(isMemberTest !== undefined) {\n            isMember = isMemberTest.call(Type, value);\n        } else if(type === \"function\") {\n            if(typeReflections.isConstructorLike(Type)) {\n                isMember = (value instanceof Type);\n            }\n        }\n        if(isMember) {\n            return value;\n        }\n        if(createNew !== undefined) {\n            return createNew.call(Type, value);\n        } else if(type === \"function\") {\n            if(typeReflections.isConstructorLike(Type)) {\n                return new Type(value);\n            } else {\n                // call it like a normal function\n                return Type(value);\n            }\n        } else {\n            throw new Error(\"can-reflect: Can not convert values into type. Type must provide `can.new` symbol.\");\n        }\n    }\n};\nmodule.exports = schemaReflections;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-reflect/reflections/shape/schema/schema.js?");

/***/ }),

/***/ "../../../../node_modules/can-reflect/reflections/shape/shape.js":
/*!****************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-reflect/reflections/shape/shape.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../../../node_modules/can-symbol/can-symbol.js\");\nvar getSetReflections = __webpack_require__(/*! ../get-set/get-set */ \"../../../../node_modules/can-reflect/reflections/get-set/get-set.js\");\nvar typeReflections = __webpack_require__(/*! ../type/type */ \"../../../../node_modules/can-reflect/reflections/type/type.js\");\nvar helpers = __webpack_require__(/*! ../helpers */ \"../../../../node_modules/can-reflect/reflections/helpers.js\");\n\n\n// IE-remove-start\nvar getPrototypeOfWorksWithPrimitives = true;\ntry {\n\tObject.getPrototypeOf(1);\n} catch(e) {\n\tgetPrototypeOfWorksWithPrimitives = false;\n}\n// IE-remove-end\n\nvar ArrayMap;\nif(typeof Map === \"function\") {\n\tArrayMap = Map;\n} else {\n\t// IE-remove-start\n\tvar isEven = function isEven(num) {\n\t\treturn num % 2 === 0;\n\t};\n\n\t// A simple map that stores items in an array.\n\t// like [key, value]\n\t// You can find the value by searching for the key and then +1.\n\tArrayMap = function(){\n\t\tthis.contents = [];\n\t};\n\n\tArrayMap.prototype = {\n\t\t/**\n\t\t * Get an index of a key. Because we store boths keys and values in\n\t\t * a flat array, we ensure we are getting a key by checking that it is an\n\t\t * even number index (all keys are even number indexed).\n\t\t **/\n\t\t_getIndex: function(key) {\n\t\t\tvar idx;\n\t\t\tdo {\n\t\t\t\tidx = this.contents.indexOf(key, idx);\n\t\t\t} while(idx !== -1 && !isEven(idx));\n\t\t\treturn idx;\n\t\t},\n\t\thas: function(key){\n\t\t\treturn this._getIndex(key) !== -1;\n\t\t},\n\t\tget: function(key){\n\t\t\tvar idx = this._getIndex(key);\n\t\t\tif(idx !== -1) {\n\t\t\t\treturn this.contents[idx + 1];\n\t\t\t}\n\t\t},\n\t\tset: function(key, value){\n\t\t\tvar idx = this._getIndex(key);\n\t\t\tif(idx !== -1) {\n\t\t\t\t// Key already exists, replace the value.\n\t\t\t\tthis.contents[idx + 1] = value;\n\t\t\t} else {\n\t\t\t\tthis.contents.push(key);\n\t\t\t\tthis.contents.push(value);\n\t\t\t}\n\t\t},\n\t\t\"delete\": function(key){\n\t\t\tvar idx = this._getIndex(key);\n\t\t\tif(idx !== -1) {\n\t\t\t\t// Key already exists, replace the value.\n\t\t\t\tthis.contents.splice(idx, 2);\n\t\t\t}\n\t\t}\n\t};\n\t// IE-remove-end\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar shapeReflections;\n\nvar shiftFirstArgumentToThis = function(func){\n\treturn function(){\n\t\tvar args = [this];\n\t\targs.push.apply(args, arguments);\n\t\treturn func.apply(null,args);\n\t};\n};\n\nvar getKeyValueSymbol = canSymbol.for(\"can.getKeyValue\");\nvar shiftedGetKeyValue = shiftFirstArgumentToThis(getSetReflections.getKeyValue);\nvar setKeyValueSymbol = canSymbol.for(\"can.setKeyValue\");\nvar shiftedSetKeyValue = shiftFirstArgumentToThis(getSetReflections.setKeyValue);\n\nvar sizeSymbol = canSymbol.for(\"can.size\");\n\nvar hasUpdateSymbol = helpers.makeGetFirstSymbolValue([\"can.updateDeep\",\"can.assignDeep\",\"can.setKeyValue\"]);\nvar shouldUpdateOrAssign = function(obj){\n\treturn typeReflections.isPlainObject(obj) || Array.isArray(obj) || !!hasUpdateSymbol(obj);\n};\n\n// is the value itself its serialized value\nfunction isSerializedHelper(obj){\n\tif (typeReflections.isPrimitive(obj)) {\n\t\treturn true;\n\t}\n\tif(hasUpdateSymbol(obj)) {\n\t\treturn false;\n\t}\n\treturn typeReflections.isBuiltIn(obj) && !typeReflections.isPlainObject(obj) && !Array.isArray(obj) && !typeReflections.isObservableLike(obj);\n}\n\n// IE11 doesn't support primitives\nvar Object_Keys;\ntry{\n\tObject.keys(1);\n\tObject_Keys = Object.keys;\n} catch(e) {\n\tObject_Keys = function(obj){\n\t\tif(typeReflections.isPrimitive(obj)) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\treturn Object.keys(obj);\n\t\t}\n\t};\n}\n\nfunction createSerializeMap(Type) {\n\tvar MapType = Type || ArrayMap;\n\treturn {\n\t\tunwrap: new MapType(),\n\t\tserialize: new MapType() ,\n\t\tisSerializing: {\n\t\t\tunwrap: new MapType(),\n\t\t\tserialize: new MapType()\n\t\t},\n\t\tcircularReferenceIsSerializing: {\n\t\t\tunwrap: new MapType(),\n\t\t\tserialize: new MapType()\n\t\t}\n\t};\n}\n\nfunction makeSerializer(methodName, symbolsToCheck){\n\t// A local variable that is shared with all operations that occur withing a single\n\t// outer call to serialize()\n\tvar serializeMap = null;\n\n\t// Holds the value of running serialize(), preserving the same map for all\n\t// internal instances.\n\tfunction SerializeOperation(MapType) {\n\t\tthis.first = !serializeMap;\n\n\t\tif(this.first) {\n\t\t\tserializeMap = createSerializeMap(MapType);\n\t\t}\n\n\t\tthis.map = serializeMap;\n\t\tthis.result = null;\n\t}\n\n\tSerializeOperation.prototype.end = function(){\n\t\t// If this is the first, outer call, clean up the serializeMap.\n\t\tif(this.first) {\n\t\t\tserializeMap = null;\n\t\t}\n\t\treturn this.result;\n\t};\n\n\treturn function serializer(value, MapType){\n\t\tif (isSerializedHelper(value)) {\n\t\t\treturn value;\n\t\t}\n\n\t\tvar operation = new SerializeOperation(MapType);\n\n\t\tif(typeReflections.isValueLike(value)) {\n\t\t\toperation.result = this[methodName](getSetReflections.getValue(value));\n\n\t\t} else {\n\t\t\t// Date, RegEx and other Built-ins are handled above\n\t\t\t// only want to do something if it's intended to be serialized\n\t\t\t// or do nothing for a POJO\n\n\t\t\tvar isListLike = typeReflections.isIteratorLike(value) || typeReflections.isMoreListLikeThanMapLike(value);\n\t\t\toperation.result = isListLike ? [] : {};\n\n\t\t\t// handle maping to what is serialized\n\t\t\tif( operation.map[methodName].has(value) ) {\n\t\t\t\t// if we are in the process of serializing the first time, setup circular reference detection.\n\t\t\t\tif(operation.map.isSerializing[methodName].has(value)) {\n\t\t\t\t\toperation.map.circularReferenceIsSerializing[methodName].set(value, true);\n\t\t\t\t}\n\t\t\t\treturn operation.map[methodName].get(value);\n\t\t\t} else {\n\t\t\t\toperation.map[methodName].set(value, operation.result);\n\t\t\t}\n\n\t\t\tfor(var i = 0, len = symbolsToCheck.length ; i< len;i++) {\n\t\t\t\tvar serializer = value[symbolsToCheck[i]];\n\t\t\t\tif(serializer) {\n\t\t\t\t\t// mark that we are serializing\n\t\t\t\t\toperation.map.isSerializing[methodName].set(value, true);\n\t\t\t\t\tvar oldResult = operation.result;\n\t\t\t\t\toperation.result = serializer.call(value, oldResult);\n\t\t\t\t\toperation.map.isSerializing[methodName].delete(value);\n\n\t\t\t\t\t// if the result differs, but this was circular, blow up.\n\t\t\t\t\tif(operation.result !== oldResult) {\n\t\t\t\t\t\t// jshint -W073\n\t\t\t\t\t\tif(operation.map.circularReferenceIsSerializing[methodName].has(value)) {\n\t\t\t\t\t\t\t// Circular references should use a custom serializer\n\t\t\t\t\t\t\t// that sets the serialized value on the object\n\t\t\t\t\t\t\t// passed to it as the first argument e.g.\n\t\t\t\t\t\t\t// function(proto){\n\t\t\t\t\t\t\t//   return proto.a = canReflect.serialize(this.a);\n\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t\toperation.end();\n\t\t\t\t\t\t\tthrow new Error(\"Cannot serialize cirular reference!\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\toperation.map[methodName].set(value, operation.result);\n\t\t\t\t\t}\n\t\t\t\t\treturn operation.end();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeof obj ==='function') {\n\t\t\t\toperation.map[methodName].set(value, value);\n\n\t\t\t\toperation.result = value;\n\t\t\t} else if( isListLike ) {\n\t\t\t\tthis.eachIndex(value,function(childValue, index){\n\t\t\t\t\toperation.result[index] = this[methodName](childValue);\n\t\t\t\t},this);\n\t\t\t} else {\n\t\t\t\tthis.eachKey(value,function(childValue, prop){\n\t\t\t\t\toperation.result[prop] = this[methodName](childValue);\n\t\t\t\t},this);\n\t\t\t}\n\t\t}\n\n\t\treturn operation.end();\n\t};\n}\n\n// returns a Map type of the keys mapped to true\nvar makeMap;\nif(typeof Map !== \"undefined\") {\n\tmakeMap = function(keys) {\n\t\tvar map = new Map();\n\t\tshapeReflections.eachIndex(keys, function(key){\n\t\t\tmap.set(key, true);\n\t\t});\n\t\treturn map;\n\t};\n} else {\n\tmakeMap = function(keys) {\n\t\tvar map = {};\n\t\tkeys.forEach(function(key){\n\t\t\tmap[key] = true;\n\t\t});\n\n\t\treturn {\n\t\t\tget: function(key){\n\t\t\t\treturn map[key];\n\t\t\t},\n\t\t\tset: function(key, value) {\n\t\t\t\tmap[key] = value;\n\t\t\t},\n\t\t\tkeys: function(){\n\t\t\t\treturn keys;\n\t\t\t}\n\t\t};\n\t};\n}\n\n// creates an optimized hasOwnKey lookup.\n// If the object has hasOwnKey, then we just use that.\n// Otherwise, try to put all keys in a map.\nvar fastHasOwnKey = function(obj){\n\tvar hasOwnKey = obj[canSymbol.for(\"can.hasOwnKey\")];\n\tif(hasOwnKey) {\n\t\treturn hasOwnKey.bind(obj);\n\t} else {\n\t\tvar map = makeMap( shapeReflections.getOwnEnumerableKeys(obj) );\n\t\treturn function(key) {\n\t\t\treturn map.get(key);\n\t\t};\n\t}\n};\n\n\n// combines patches if it makes sense\nfunction addPatch(patches, patch) {\n\tvar lastPatch = patches[patches.length -1];\n\tif(lastPatch) {\n\t\t// same number of deletes and counts as the index is back\n\t\tif(lastPatch.deleteCount === lastPatch.insert.length && (patch.index - lastPatch.index === lastPatch.deleteCount) ) {\n\t\t\tlastPatch.insert.push.apply(lastPatch.insert, patch.insert);\n\t\t\tlastPatch.deleteCount += patch.deleteCount;\n\t\t\treturn;\n\t\t}\n\t}\n\tpatches.push(patch);\n}\n\nfunction updateDeepList(target, source, isAssign) {\n\tvar sourceArray = this.toArray(source); // jshint ignore:line\n\n\tvar patches = [],\n\t\tlastIndex = -1;\n\tthis.eachIndex(target, function(curVal, index){ // jshint ignore:line\n\t\tlastIndex = index;\n\t\t// If target has more items than the source.\n\t\tif(index >= sourceArray.length) {\n\t\t\tif(!isAssign) {\n\t\t\t\t// add a patch that removes the last items\n\t\t\t\taddPatch(patches, {index: index, deleteCount: target.length - index + 1, insert: []});\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tvar newVal = sourceArray[index];\n\t\tif( typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false ) {\n\t\t\taddPatch(patches, {index: index, deleteCount: 1, insert: [newVal]});\n\t\t} else {\n\t\t\tif(isAssign === true) {\n\t\t\t\tthis.assignDeep(curVal, newVal);\n\t\t\t} else {\n\t\t\t\tthis.updateDeep(curVal, newVal);\n\t\t\t}\n\n\t\t}\n\t}, this); // jshint ignore:line\n\t// add items at the end\n\tif(sourceArray.length > lastIndex) {\n\t\taddPatch(patches, {index: lastIndex+1, deleteCount: 0, insert: sourceArray.slice(lastIndex+1)});\n\t}\n\tfor(var i = 0, patchLen = patches.length; i < patchLen; i++) {\n\t\tvar patch = patches[i];\n\t\tgetSetReflections.splice(target, patch.index, patch.deleteCount, patch.insert);\n\t}\n\treturn target;\n}\n\nshapeReflections = {\n\t/**\n\t * @function {Object, function(*), [Object]} can-reflect.each each\n\t * @parent can-reflect/shape\n\t * @description  Iterate a List-like or Map-like, calling `callback` on each keyed or indexed property\n\t *\n\t * @signature `each(obj, callback, context)`\n\t *\n\t * If `obj` is a List-like or an Iterator-like, `each` functions as [can-reflect.eachIndex eachIndex],\n\t * iterating over numeric indexes from 0 to `obj.length - 1` and calling `callback` with each property and\n\t * index, optionally with `context` as `this` (defaulting to `obj`).  If not, `each` functions as\n\t * [can-reflect.eachKey eachKey],\n\t * iterating over every key on `obj` and calling `callback` on each one.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t * var quux = new DefineList([ \"thud\", \"jeek\" ]);\n\t *\n\t * canReflect.each(foo, console.log, console); // -> logs 'baz bar {foo}'\n\t * canReflect.each(quux, console.log, console); // -> logs 'thud 0 {quux}'; logs 'jeek 1 {quux}'\n\t * ```\n\t *\n\t * @param  {Object}   obj     The object to iterate over\n\t * @param  {Function(*, ValueLike)} callback a function that receives each item in the ListLike or MapLike\n\t * @param  {[Object]}   context  an optional `this` context for calling the callback\n\t * @return {Array} the result of calling [can-reflect.eachIndex `eachIndex`] if `obj` is a ListLike,\n\t * or [can-reflect.eachKey `eachKey`] if a MapLike.\n\t */\n\teach: function(obj, callback, context){\n\n\t\t// if something is more \"list like\" .. use eachIndex\n\t\tif(typeReflections.isIteratorLike(obj) || typeReflections.isMoreListLikeThanMapLike(obj) ) {\n\t\t\treturn shapeReflections.eachIndex(obj,callback,context);\n\t\t} else {\n\t\t\treturn shapeReflections.eachKey(obj,callback,context);\n\t\t}\n\t},\n\n\t/**\n\t * @function {ListLike, function(*), [Object]} can-reflect.eachIndex eachIndex\n\t * @parent can-reflect/shape\n\t * @description  Iterate a ListLike calling `callback` on each numerically indexed element\n\t *\n\t * @signature `eachIndex(list, callback, context)`\n\t *\n\t * For each numeric index from 0 to `list.length - 1`, call `callback`, passing the current\n\t * property value, the current index, and `list`, and optionally setting `this` as `context`\n\t * if specified (otherwise use the current property value).\n\t *\n\t * ```js\n\t * var foo = new DefineList([ \"bar\", \"baz\" ]);\n\t *\n\t * canReflect.eachIndex(foo, console.log, console); // -> logs 'bar 0 {foo}'; logs 'baz 1 {foo}'\n\t * ```\n\t *\n\t * @param  {ListLike}   list     The list to iterate over\n\t * @param  {Function(*, Number)} callback a function that receives each item\n\t * @param  {[Object]}   context  an optional `this` context for calling the callback\n\t * @return {ListLike}   the original list\n\t */\n\teachIndex: function(list, callback, context){\n\t\t// each index in something list-like. Uses iterator if it has it.\n\t\tif(Array.isArray(list)) {\n\t\t\treturn shapeReflections.eachListLike(list, callback, context);\n\t\t} else {\n\t\t\tvar iter, iterator = list[canSymbol.iterator];\n\t\t\tif(typeReflections.isIteratorLike(list)) {\n\t\t\t\t// we are looping through an iterator\n\t\t\t\titer = list;\n\t\t\t} else if(iterator) {\n\t\t\t\titer = iterator.call(list);\n\t\t\t}\n\t\t\t// fast-path arrays\n\t\t\tif(iter) {\n\t\t\t\tvar res, index = 0;\n\n\t\t\t\twhile(!(res = iter.next()).done) {\n\t\t\t\t\tif( callback.call(context || list, res.value, index++, list) === false ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tshapeReflections.eachListLike(list, callback, context);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t},\n\teachListLike: function(list, callback, context){\n\t\tvar index = -1;\n\t\tvar length = list.length;\n\t\tif( length === undefined ) {\n\t\t\tvar size = list[sizeSymbol];\n\t\t\tif(size) {\n\t\t\t\tlength = size.call(list);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"can-reflect: unable to iterate.\");\n\t\t\t}\n\t\t}\n\n\t\twhile (++index < length) {\n\t\t\tvar item = list[index];\n\t\t\tif (callback.call(context || item, item, index, list) === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t},\n\t/**\n\t * @function can-reflect.toArray toArray\n\t * @parent can-reflect/shape\n\t * @description  convert the values of any MapLike or ListLike into an array\n\t *\n\t * @signature `toArray(obj)`\n\t *\n\t * Convert the values of any Map-like or List-like into a JavaScript Array.  If a Map-like,\n\t * key data is discarded and only value data is preserved.\n\t *\n\t * ```js\n\t * var foo = new DefineList([\"bar\", \"baz\"]);\n\t * var quux = new DefineMap({ thud: \"jeek\" });\n\t * ```\n\t *\n\t * canReflect.toArray(foo); // -> [\"bar\", \"baz\"]\n\t * canReflect.toArray(quux): // -> [\"jeek\"]\n\t *\n\t * @param  {Object} obj Any object, whether MapLike or ListLike\n\t * @return {Array}  an array of the values of `obj`\n\t */\n\ttoArray: function(obj){\n\t\tvar arr = [];\n\t\tshapeReflections.each(obj, function(value){\n\t\t\tarr.push(value);\n\t\t});\n\t\treturn arr;\n\t},\n\t/**\n\t * @function can-reflect.eachKey eachKey\n\t * @parent can-reflect/shape\n\t * @description Iterate over a MapLike, calling `callback` on each enumerable property\n\t *\n\t * @signature `eachKey(obj, callback, context)`\n\t *\n\t * Iterate all own enumerable properties on Map-like `obj`\n\t * (using [can-reflect/shape/getOwnEnumerableKeys canReflect.getOwnEnumerableKeys]), and call\n\t * `callback` with the property value, the property key, and `obj`, and optionally setting\n\t * `this` on the callback as `context` if provided, `obj` otherwise.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t *\n\t * canReflect.eachKey(foo, console.log, console); // logs 'baz bar {foo}'\n\t * ```\n\t *\n\t * @param  {Object}   obj   The object to iterate over\n\t * @param  {Function(*, String)} callback The callback to call on each enumerable property value\n\t * @param  {[Object]}   context  an optional `this` context for calling `callback`\n\t * @return {Array}    the enumerable keys of `obj` as an Array\n\t */\n\teachKey: function(obj, callback, context){\n\t\t// each key in something map like\n\t\t// eachOwnEnumerableKey\n\t\tif(obj) {\n\t\t\tvar enumerableKeys = shapeReflections.getOwnEnumerableKeys(obj);\n\n\t\t\t// cache getKeyValue method if we can\n\t\t\tvar getKeyValue = obj[getKeyValueSymbol] || shiftedGetKeyValue;\n\n\t\t\treturn shapeReflections.eachIndex(enumerableKeys, function(key){\n\t\t\t\tvar value = getKeyValue.call(obj, key);\n\t\t\t\treturn callback.call(context || obj, value, key, obj);\n\t\t\t});\n\t\t}\n\t\treturn obj;\n\t},\n\t/**\n\t * @function can-reflect.hasOwnKey hasOwnKey\n\t * @parent can-reflect/shape\n\t * @description  Determine whether an object contains a key on itself, not only on its prototype chain\n\t *\n\t * @signature `hasOwnKey(obj, key)`\n\t *\n\t * Return `true` if an object's own properties include the property key `key`, `false` otherwise.\n\t * An object may implement [can-symbol/symbols/hasOwnKey @@@@can.hasOwnKey] to override default behavior.\n\t * By default, `canReflect.hasOwnKey` will first look for\n\t * [can-symbol/symbols/getOwnKey @@@@can.getOwnKey] on `obj`. If present, it will call `@@@@can.getOwnKey` and\n\t * test `key` against the returned Array of keys.  If absent, `Object.prototype.hasOwnKey()` is used.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ \"bar\": \"baz\" });\n\t *\n\t * canReflect.hasOwnKey(foo, \"bar\"); // -> true\n\t * canReflect.hasOwnKey(foo, \"each\"); // -> false\n\t * foo.each // -> function each() {...}\n\t * ```\n\t *\n\t * @param  {Object} obj Any MapLike object\n\t * @param  {String} key The key to look up on `obj`\n\t * @return {Boolean} `true` if `obj`'s key set contains `key`, `false` otherwise\n\t */\n\t\"hasOwnKey\": function(obj, key){\n\t\t// if a key or index\n\t\t// like has own property\n\t\tvar hasOwnKey = obj[canSymbol.for(\"can.hasOwnKey\")];\n\t\tif(hasOwnKey) {\n\t\t\treturn hasOwnKey.call(obj, key);\n\t\t}\n\t\tvar getOwnKeys = obj[canSymbol.for(\"can.getOwnKeys\")];\n\t\tif( getOwnKeys ) {\n\t\t\tvar found = false;\n\t\t\tshapeReflections.eachIndex(getOwnKeys.call(obj), function(objKey){\n\t\t\t\tif(objKey === key) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn found;\n\t\t}\n\t\treturn hasOwnProperty.call(obj, key);\n\t},\n\t/**\n\t * @function can-reflect.getOwnEnumerableKeys getOwnEnumerableKeys\n\t * @parent can-reflect/shape\n\t * @description Return the list of keys which can be iterated over on an object\n\t *\n\t * @signature `getOwnEnumerableKeys(obj)`\n\t *\n\t * Return all keys on `obj` which have been defined as enumerable, either from explicitly setting\n\t * `enumerable` on the property descriptor, or by using `=` to set the value of the property without\n\t * a key descriptor, but excluding properties that only exist on `obj`'s prototype chain.  The\n\t * default behavior can be overridden by implementing\n\t * [can-symbol/symbols/getOwnEnumerableKeys @@@@can.getOwnEnumerableKeys] on `obj`.  By default,\n\t * `canReflect.getOwnEnumerableKeys` will use [can-symbol/symbols/getOwnKeys @@@@can.getOwnKeys] to\n\t * retrieve the set of keys and [can-symbol/symbols/getOwnKeyDescriptor @@@@can.getOwnKeyDescriptor]\n\t * to filter for those which are enumerable.  If either symbol is absent from `obj`, `Object.keys`\n\t * is used.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\", [canSymbol.for(\"quux\")]: \"thud\" });\n\t * Object.defineProperty(foo, \"jeek\", {\n\t *   enumerable: true,\n\t *   value: \"plonk\"\n\t * });\n\t *\n\t * canReflect.getOwnEnumerableKeys(foo); // -> [\"bar\", \"jeek\"]\n\t * ```\n\t *\n\t * @param  {Object} obj Any Map-like object\n\t * @return {Array} the Array of all enumerable keys from the object, either using\n\t * [can-symbol/symbols/getOwnEnumerableKeys `@@@@can.getOwnEnumerableKeys`] from `obj`, or filtering\n\t * `obj`'s own keys for those which are enumerable.\n\t */\n\tgetOwnEnumerableKeys: function(obj){\n\t\t// own enumerable keys (aliased as keys)\n\t\tvar getOwnEnumerableKeys = obj[canSymbol.for(\"can.getOwnEnumerableKeys\")];\n\t\tif(getOwnEnumerableKeys) {\n\t\t\treturn getOwnEnumerableKeys.call(obj);\n\t\t}\n\t\tif( obj[canSymbol.for(\"can.getOwnKeys\")] && obj[canSymbol.for(\"can.getOwnKeyDescriptor\")] ) {\n\t\t\tvar keys = [];\n\t\t\tshapeReflections.eachIndex(shapeReflections.getOwnKeys(obj), function(key){\n\t\t\t\tvar descriptor =  shapeReflections.getOwnKeyDescriptor(obj, key);\n\t\t\t\tif(descriptor.enumerable) {\n\t\t\t\t\tkeys.push(key);\n\t\t\t\t}\n\t\t\t}, this);\n\n\t\t\treturn keys;\n\t\t} /*else if(obj[canSymbol.iterator]){\n\t\t\tvar iter = obj[canSymbol.iterator](obj);\n\t\t\tvar index = 0;\n\t\t\tvar keys;\n\t\t\treturn {\n\t\t\t\tnext: function(){\n\t\t\t\t\tvar res = iter.next();\n\t\t\t\t\tif(index++)\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!().done) {\n\n\t\t\t\tif( callback.call(context || list, res.value, index++, list) === false ){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/ else {\n\t\t\treturn Object_Keys(obj);\n\t\t}\n\t},\n\t/**\n\t * @function can-reflect.getOwnKeys getOwnKeys\n\t * @parent can-reflect/shape\n\t * @description Return the list of keys on an object, whether or not they can be iterated over\n\t *\n\t * @signature `getOwnKeys(obj)`\n\t *\n\t * Return the Array of all String (not Symbol) keys from `obj`, whether they are enumerable or not.  If\n\t * [can-symbol/symbols/getOwnKeys @@@@can.getOwnKeys] exists on `obj`, it is called to return\n\t * the keys; otherwise, `Object.getOwnPropertyNames()` is used.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\", [canSymbol.for(\"quux\")]: \"thud\" });\n\t * Object.defineProperty(foo, \"jeek\", {\n\t *   enumerable: false,\n\t *   value: \"plonk\"\n\t * });\n\t *\n\t * canReflect.getOwnKeys(foo); // -> [\"bar\", \"jeek\"]\n\t * ```\n\t *\n\t * @param  {Object} obj Any MapLike object\n\t * @return {Array} the Array of all String keys from the object.\n\t */\n\tgetOwnKeys: function(obj){\n\t\t// own enumerable&non-enumerable keys (Object.getOwnPropertyNames)\n\t\tvar getOwnKeys = obj[canSymbol.for(\"can.getOwnKeys\")];\n\t\tif(getOwnKeys) {\n\t\t\treturn getOwnKeys.call(obj);\n\t\t} else {\n\t\t\treturn Object.getOwnPropertyNames(obj);\n\t\t}\n\t},\n\t/**\n\t * @function can-reflect.getOwnKeyDescriptor getOwnKeyDescriptor\n\t * @parent can-reflect/shape\n\t * @description Return a property descriptor for a named property on an object.\n\t *\n\t * @signature `getOwnKeyDescriptor(obj, key)`\n\t *\n\t *\tReturn the key descriptor for the property key `key` on the Map-like object `obj`. A key descriptor\n\t *\tis specified in ECMAScript 5 and contains keys for the property's `configurable` and `enumerable` states,\n\t *\tas well as either `value` and `writable` for value properties, or `get` and `set` for getter/setter properties.\n\t *\n\t * The default behavior can be overridden by implementing [can-symbol/symbols/getOwnKeyDescriptor @@@@can.getOwnKeyDescriptor]\n\t * on `obj`; otherwise the default is to call `Object.getOwnKeyDescriptor()`.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t *\n\t * getOwnKeyDescriptor(foo, \"bar\"); // -> {configurable: true, writable: true, enumerable: true, value: \"baz\"}\n\t * ```\n\t *\n\t * @param  {Object} obj Any object with named properties\n\t * @param  {String} key The property name to look up on `obj`\n\t * @return {Object}   A key descriptor object\n\t */\n\tgetOwnKeyDescriptor: function(obj, key){\n\t\tvar getOwnKeyDescriptor = obj[canSymbol.for(\"can.getOwnKeyDescriptor\")];\n\t\tif(getOwnKeyDescriptor) {\n\t\t\treturn getOwnKeyDescriptor.call(obj, key);\n\t\t} else {\n\t\t\treturn Object.getOwnPropertyDescriptor(obj, key);\n\t\t}\n\t},\n\t/**\n\t * @function can-reflect.unwrap unwrap\n\t * @parent can-reflect/shape\n\t * @description Unwraps a map-like or array-like value into an object or array.\n\t *\n\t *\n\t * @signature `unwrap(obj)`\n\t *\n\t * Recursively unwraps a map-like or list-like object.\n\t *\n\t * ```js\n\t * import canReflect from \"can-reflect\";\n\t *\n\t * var map = new DefineMap({foo: \"bar\"});\n\t * canReflect.unwrap(map) //-> {foo: \"bar\"}\n\t * ```\n\t *\n\t * `unwrap` is similar to [can-reflect.serialize] except it does not try to provide `JSON.stringify()`-safe\n\t * objects.  For example, an object with a `Date` instance property value will not be expected to\n\t * serialize the date instance:\n\t *\n\t * ```js\n\t * var date = new Date();\n\t * var map = new DefineMap({date: date});\n\t * canReflect.unwrap(map) //-> {date: date}\n\t * ```\n\t *\n\t * @param {Object} obj A map-like or array-like object.\n\t * @return {Object} Returns objects and arrays.\n\t */\n\tunwrap: makeSerializer(\"unwrap\",[canSymbol.for(\"can.unwrap\")]),\n\t/**\n\t * @function can-reflect.serialize serialize\n\t * @parent can-reflect/shape\n\t * @description Serializes an object to a value that can be passed to JSON.stringify.\n\t *\n\t *\n\t * @signature `serialize(obj)`\n\t *\n\t * Recursively serializes a map-like or list-like object.\n\t *\n\t * ```js\n\t * import canReflect from \"can-reflect\";\n\t * canReflect.serialize({foo: \"bar\"}) //-> {foo: \"bar\"}\n\t * ```\n\t *\n\t * It does this by recursively:\n\t *\n\t *  - Checking if `obj` is a primitive, if it is, returns the value.\n\t *  - If `obj` is an object:\n\t *    - calling the `@can.serialize` property on the value if it exists.\n\t *    - If the `@can.serialize` value doesn't exist, walks through every key-value\n\t *      on `obj` and copy to a new object.\n\t *\n\t * @param {Object} obj A map-like or array-like object.\n\t * @return {Object} Returns a plain object or array.\n\t */\n\tserialize: makeSerializer(\"serialize\",[canSymbol.for(\"can.serialize\"), canSymbol.for(\"can.unwrap\")]),\n\n\tassignMap: function(target, source) {\n\t\t// read each key and set it on target\n\t\tvar hasOwnKey = fastHasOwnKey(target);\n\t\tvar getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;\n\t\tvar setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;\n\t\tshapeReflections.eachKey(source,function(value, key){\n\t\t\t// if the target doesn't have this key or the keys are not the same\n\t\t\tif(!hasOwnKey(key) || getKeyValue.call(target, key) !==  value) {\n\t\t\t\tsetKeyValue.call(target, key, value);\n\t\t\t}\n\t\t});\n\t\treturn target;\n\t},\n\tassignList: function(target, source) {\n\t\tvar inserting = shapeReflections.toArray(source);\n\t\tgetSetReflections.splice(target, 0, inserting, inserting );\n\t\treturn target;\n\t},\n\t/**\n\t * @function can-reflect.assign assign\n\t * @parent can-reflect/shape\n\t * @description Assign one objects values to another\n\t *\n\t * @signature `.assign(target, source)`\n\t *\n\t * Copies the values (and properties if map-like) from `source` onto `target`.\n\t *\n\t * For map-like objects, every enumerable property on `target` is copied:\n\t *\n\t * ```js\n\t * var target = {};\n\t * var source = {key : \"value\"};\n\t * var restult = canReflect.assign(target, source);\n\t * result === target //-> true\n\t * target //-> {key : \"value\"}\n\t * ```\n\t *\n\t * For Arrays, enumerated values are copied over, but the length of the array will not be\n\t * trunkated.  Use [can-reflect.update] for trunkating.\n\t *\n\t * ```js\n\t * var target = [\"a\",\"b\",\"c\"];\n\t * var source = [\"A\",\"B\"];\n\t * canReflect.assign(target, source);\n\t * target //-> [\"A\",\"B\",\"c\"]\n\t * ```\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s values.\n\t * @param  {Object} source A source of values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tassign: function(target, source) {\n\t\tif(typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source) ) {\n\t\t\t// copy to array and add these keys in place\n\t\t\tshapeReflections.assignList(target, source);\n\t\t} else {\n\t\t\tshapeReflections.assignMap(target, source);\n\t\t}\n\t\treturn target;\n\t},\n\tassignDeepMap: function(target, source) {\n\n\t\tvar hasOwnKey = fastHasOwnKey(target);\n\t\tvar getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;\n\t\tvar setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;\n\n\t\tshapeReflections.eachKey(source, function(newVal, key){\n\t\t\tif(!hasOwnKey(key)) {\n\t\t\t\t// set no matter what\n\t\t\t\tgetSetReflections.setKeyValue(target, key, newVal);\n\t\t\t} else {\n\t\t\t\tvar curVal = getKeyValue.call(target, key);\n\n\t\t\t\t// if either was primitive, no recursive update possible\n\t\t\t\tif(newVal === curVal) {\n\t\t\t\t\t// do nothing\n\t\t\t\t} else if(typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false ) {\n\t\t\t\t\tsetKeyValue.call(target, key, newVal);\n\t\t\t\t} else {\n\t\t\t\t\tshapeReflections.assignDeep(curVal, newVal);\n\t\t\t\t}\n\t\t\t}\n\t\t}, this);\n\t\treturn target;\n\t},\n\tassignDeepList: function(target, source) {\n\t\treturn updateDeepList.call(this, target, source, true);\n\t},\n\t/**\n\t * @function can-reflect.assignDeep assignDeep\n\t * @parent can-reflect/shape\n\t * @description Assign one objects values to another, and performs the same action for all child values.\n\t *\n\t * @signature `.assignDeep(target, source)`\n\t *\n\t * Copies the values (and properties if map-like) from `source` onto `target` and repeates for all child\n\t * values.\n\t *\n\t * For map-like objects, every enumerable property on `target` is copied:\n\t *\n\t * ```js\n\t * var target = {name: {first: \"Justin\"}};\n\t * var source = {name: {last: \"Meyer\"}};\n\t * var restult = canReflect.assignDeep(target, source);\n\t * target //->  {name: {first: \"Justin\", last: \"Meyer\"}}\n\t * ```\n\t *\n\t * An object can control the behavior of `assignDeep` using the [can-symbol/symbols/assignDeep] symbol.\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s values.\n\t * @param  {Object} source A source of values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tassignDeep: function(target, source){\n\t\tvar assignDeep = target[canSymbol.for(\"can.assignDeep\")];\n\t\tif(assignDeep) {\n\t\t\tassignDeep.call(target, source);\n\t\t} else if( typeReflections.isMoreListLikeThanMapLike(source) ) {\n\t\t\t// list-like\n\t\t\tshapeReflections.assignDeepList(target, source);\n\t\t} else {\n\t\t\t// map-like\n\t\t\tshapeReflections.assignDeepMap(target, source);\n\t\t}\n\t\treturn target;\n\t},\n\tupdateMap: function(target, source) {\n\t\tvar sourceKeyMap = makeMap( shapeReflections.getOwnEnumerableKeys(source) );\n\n\t\tvar sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;\n\t\tvar targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;\n\n\t\tshapeReflections.eachKey(target, function(curVal, key){\n\t\t\tif(!sourceKeyMap.get(key)) {\n\t\t\t\tgetSetReflections.deleteKeyValue(target, key);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsourceKeyMap.set(key, false);\n\t\t\tvar newVal = sourceGetKeyValue.call(source, key);\n\n\t\t\t// if either was primitive, no recursive update possible\n\t\t\tif(newVal !== curVal) {\n\t\t\t\ttargetSetKeyValue.call(target, key, newVal);\n\t\t\t}\n\t\t}, this);\n\n\t\tshapeReflections.eachIndex(sourceKeyMap.keys(), function(key){\n\t\t\tif(sourceKeyMap.get(key)) {\n\t\t\t\ttargetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key) );\n\t\t\t}\n\t\t});\n\n\t\treturn target;\n\t},\n\tupdateList: function(target, source) {\n\t\tvar inserting = shapeReflections.toArray(source);\n\n\t\tgetSetReflections.splice(target, 0, target, inserting );\n\t\treturn target;\n\t},\n\t/**\n\t * @function can-reflect.update update\n\t * @parent can-reflect/shape\n\t * @description Updates the values of an object match the values of an other object.\n\t *\n\t * @signature `.update(target, source)`\n\t *\n\t * Updates the values (and properties if map-like) of `target` to match the values of `source`.\n\t * Properties of `target` that are not on `source` will be removed. This does\n\t * not recursively update.  For that, use [can-reflect.updateDeep].\n\t *\n\t * For map-like objects, every enumerable property on `target` is copied:\n\t *\n\t * ```js\n\t * var target = {name: {first: \"Justin\"}, age: 34};\n\t * var source = {name: {last: \"Meyer\"}};\n\t * var result = canReflect.update(target, source);\n\t * target //->  {name: {last: \"Meyer\"}}\n\t * ```\n\t *\n\t * With Arrays all items of the source will be replaced with the new items.\n\t *\n\t * ```js\n\t * var target = [\"a\",\"b\",\"c\"];\n\t * var source = [\"A\",\"B\"];\n\t * canReflect.update(target, source);\n\t * target //-> [\"A\",\"B\"]\n\t * ```\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s values.\n\t * @param  {Object} source A source of values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tupdate: function(target, source) {\n\t\tif(typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source) ) {\n\t\t\t// copy to array and add these keys in place\n\t\t\tshapeReflections.updateList(target, source);\n\t\t} else {\n\t\t\tshapeReflections.updateMap(target, source);\n\t\t}\n\t\treturn target;\n\t},\n\tupdateDeepMap: function(target, source) {\n\t\tvar sourceKeyMap = makeMap( shapeReflections.getOwnEnumerableKeys(source) );\n\n\t\tvar sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;\n\t\tvar targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;\n\n\t\tshapeReflections.eachKey(target, function(curVal, key){\n\n\t\t\tif(!sourceKeyMap.get(key)) {\n\t\t\t\tgetSetReflections.deleteKeyValue(target, key);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsourceKeyMap.set(key, false);\n\t\t\tvar newVal = sourceGetKeyValue.call(source, key);\n\n\t\t\t// if either was primitive, no recursive update possible\n\t\t\tif(typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false ) {\n\t\t\t\ttargetSetKeyValue.call(target, key, newVal);\n\t\t\t} else {\n\t\t\t\tshapeReflections.updateDeep(curVal, newVal);\n\t\t\t}\n\n\t\t}, this);\n\n\t\tshapeReflections.eachIndex(sourceKeyMap.keys(), function(key){\n\t\t\tif(sourceKeyMap.get(key)) {\n\t\t\t\ttargetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key) );\n\t\t\t}\n\t\t});\n\t\treturn target;\n\t},\n\tupdateDeepList: function(target, source) {\n\t\treturn updateDeepList.call(this,target, source);\n\t},\n\t/**\n\t * @function can-reflect.updateDeep updateDeep\n\t * @parent can-reflect/shape\n\t * @description Makes the values of an object match the values of an other object including all children values.\n\t *\n\t * @signature `.updateDeep(target, source)`\n\t *\n\t * Updates the values (and properties if map-like) of `target` to match the values of `source`.\n\t * Removes properties from `target` that are not on `source`.\n\t *\n\t * For map-like objects, every enumerable property on `target` is copied:\n\t *\n\t * ```js\n\t * var target = {name: {first: \"Justin\"}, age: 34};\n\t * var source = {name: {last: \"Meyer\"}};\n\t * var result = canReflect.updateDeep(target, source);\n\t * target //->  {name: {last: \"Meyer\"}}\n\t * ```\n\t *\n\t * An object can control the behavior of `updateDeep` using the [can-symbol/symbols/updateDeep] symbol.\n\t *\n\t * For list-like objects, a diff and patch strategy is used.  This attempts to limit the number of changes.\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s values.\n\t * @param  {Object} source A source of values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tupdateDeep: function(target, source){\n\t\tvar updateDeep = target[canSymbol.for(\"can.updateDeep\")];\n\t\tif(updateDeep) {\n\t\t\tupdateDeep.call(target, source);\n\t\t} else if( typeReflections.isMoreListLikeThanMapLike(source) ) {\n\t\t\t// list-like\n\t\t\tshapeReflections.updateDeepList(target, source);\n\t\t} else {\n\t\t\t// map-like\n\t\t\tshapeReflections.updateDeepMap(target, source);\n\t\t}\n\t\treturn target;\n\t},\n\t// walks up the whole prototype chain\n\t/**\n\t * @function can-reflect.hasKey hasKey\n\t * @parent can-reflect/shape\n\t * @description Determine whether an object contains a key on itself or its prototype chain\n\t *\n\t * @signature `hasKey(obj, key)`\n\t *\n\t * Return `true` if an object's properties include the property key `key` or an object on its prototype\n\t * chain's properties include the key `key`, `false` otherwise.\n\t * An object may implement [can-symbol/symbols/hasKey @@@@can.hasKey] to override default behavior.\n\t * By default, `canReflect.hasKey` will use [can-reflect.hasOwnKey] and return true if the key is present.\n\t * If `hasOwnKey` returns false, the [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in in Operator] will be used.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ \"bar\": \"baz\" });\n\t *\n\t * canReflect.in(foo, \"bar\"); // -> true\n\t * canReflect.in(foo, \"each\"); // -> true\n\t * foo.each // -> function each() {...}\n\t * ```\n\t *\n\t * @param  {Object} obj Any MapLike object\n\t * @param  {String} key The key to look up on `obj`\n\t * @return {Boolean} `true` if `obj`'s key set contains `key` or an object on its prototype chain's key set contains `key`, `false` otherwise\n\t */\n\thasKey: function(obj, key) {\n\t\tif( obj == null ) {\n\t\t\treturn false;\n\t\t}\n\t\tif (typeReflections.isPrimitive(obj)) {\n\t\t\tif (hasOwnProperty.call(obj, key)) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tvar proto;\n\t\t\t\tif(getPrototypeOfWorksWithPrimitives) {\n\t\t\t\t\tproto = Object.getPrototypeOf(obj);\n\t\t\t\t} else {\n\t\t\t\t\t// IE-remove-start\n\t\t\t\t\tproto = obj.__proto__; // jshint ignore:line\n\t\t\t\t\t// IE-remove-end\n\t\t\t\t}\n\t\t\t\tif(proto !== undefined) {\n\t\t\t\t\treturn key in proto;\n\t\t\t\t} else {\n\t\t\t\t\t// IE-remove-start\n\t\t\t\t\treturn obj[key] !== undefined;\n\t\t\t\t\t// IE-remove-end\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar hasKey = obj[canSymbol.for(\"can.hasKey\")];\n\t\tif(hasKey) {\n\t\t\treturn hasKey.call(obj, key);\n\t\t}\n\n\t\tvar found = shapeReflections.hasOwnKey(obj, key);\n\n\t\treturn found || key in obj;\n\t},\n\tgetAllEnumerableKeys: function(){},\n\tgetAllKeys: function(){},\n\t/**\n\t * @function can-reflect.assignSymbols assignSymbols\n\t * @parent can-reflect/shape\n\t * @description Assign well known symbols and values to an object.\n\t *\n\t * @signature `.assignSymbols(target, source)`\n\t *\n\t * Converts each property name on the `source` object to a [can-symbol.for well known symbol]\n\t * and uses that symbol to set the corresponding value on target.\n\t *\n\t * This is used to easily set symbols correctly even when symbol isn't natively supported.\n\t *\n\t * ```js\n\t * canReflect.assignSymbols(Map.prototype, {\n\t *   \"can.getKeyValue\": Map.prototype.get\n\t * })\n\t * ```\n\t *\n\t * If a `source` property name matches a symbol on `Symbol` (like `iterator` on `Symbol.iterator`),\n\t * that symbol will be used:\n\t *\n\t * ```js\n\t * canReflect.assignSymbols(ArrayLike.prototype, {\n\t *   \"iterator\": function() { ... }\n\t * })\n\t * ArrayLike.prototype[Symbol.iterator] = function(){ ... }\n\t * ```\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s symbols and values.\n\t * @param  {Object<name,value>} source A source of symbol names and values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tassignSymbols: function(target, source){\n\t\tshapeReflections.eachKey(source, function(value, key){\n\t\t\tvar symbol = typeReflections.isSymbolLike(canSymbol[key]) ? canSymbol[key] : canSymbol.for(key);\n\t\t\tgetSetReflections.setKeyValue(target, symbol, value);\n\t\t});\n\t\treturn target;\n\t},\n\tisSerialized: isSerializedHelper,\n\t/**\n\t * @function can-reflect.size size\n\t * @parent can-reflect/shape\n\t * @description Return the number of items in the collection.\n\t *\n\t * @signature `.size(target)`\n\t *\n\t * Returns the number of items contained in `target`. Target can\n\t * provide the size using the [can-symbol/symbols/size] symbol.\n\t *\n\t * If the `target` has a numeric `length` property that is greater than or equal to 0, that\n\t * `length` will be returned.\n\t *\n\t * ```js\n\t * canReflect.size([1,2,3]) //-> 3\n\t * ```\n\t *\n\t * If the `target` is [can-reflect.isListLike], the values of the list will be counted.\n\t *\n\t * If the `target` is a plain JS object, the number of enumerable properties will be returned.\n\t *\n\t * ```js\n\t * canReflect.size({foo:\"bar\"}) //-> 1\n\t * ```\n\t *\n\t * If the `target` is anything else, `undefined` is returned.\n\t *\n\t * @param  {Object} target The container object.\n\t * @return {Number} The number of values in the target.\n\t */\n\tsize: function(obj){\n\t\tif(obj == null) {\n\t\t\treturn 0;\n\t\t}\n\t\tvar size = obj[sizeSymbol];\n\t\tvar count = 0;\n\t\tif(size) {\n\t\t\treturn size.call(obj);\n\t\t}\n\t\telse if(helpers.hasLength(obj)){\n\t\t\treturn obj.length;\n\t\t}\n\t\telse if(typeReflections.isListLike(obj)){\n\n\t\t\tshapeReflections.eachIndex(obj, function(){\n\t\t\t\tcount++;\n\t\t\t});\n\t\t\treturn count;\n\t\t}\n\t\telse if( obj ) {\n\t\t\treturn shapeReflections.getOwnEnumerableKeys(obj).length;\n\t\t}\n\t\telse {\n\t\t\treturn undefined;\n\t\t}\n\t},\n\t/**\n\t * @function {Function, String|Symbol, Object} can-reflect.defineInstanceKey defineInstanceKey\n\t * @parent can-reflect/shape\n\t * @description Create a key for all instances of a constructor.\n\t *\n\t * @signature `defineInstanceKey(cls, key, properties)`\n\t *\n\t * Define the property `key` on the prototype of the constructor `cls` using the symbolic\n\t * property [can-symbol/symbols/defineInstanceKey @@can.defineInstanceKey] if it exists; otherwise\n\t * use `Object.defineProperty()` to define the property.  The property definition\n\t *\n\t * @param  {Function} cls  a Constructor function\n\t * @param  {String} key     the String or Symbol key to set.\n\t * @param  {Object} properties a JavaScript property descriptor\n\t */\n\tdefineInstanceKey: function(cls, key, properties) {\n\t\tvar defineInstanceKey = cls[canSymbol.for(\"can.defineInstanceKey\")];\n\t\tif(defineInstanceKey) {\n\t\t\treturn defineInstanceKey.call(cls, key, properties);\n\t\t}\n\t\tvar proto = cls.prototype;\n\t\tdefineInstanceKey = proto[canSymbol.for(\"can.defineInstanceKey\")];\n\t\tif(defineInstanceKey) {\n\t\t\tdefineInstanceKey.call(proto, key, properties);\n\t\t} else {\n\t\t\tObject.defineProperty(\n\t\t\t\tproto,\n\t\t\t\tkey,\n\t\t\t\tshapeReflections.assign({\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: !typeReflections.isSymbolLike(key),\n\t\t\t\t\twritable: true\n\t\t\t\t}, properties)\n\t\t\t);\n\t\t}\n\t}\n};\n\nshapeReflections.isSerializable = shapeReflections.isSerialized;\nshapeReflections.keys = shapeReflections.getOwnEnumerableKeys;\nmodule.exports = shapeReflections;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-reflect/reflections/shape/shape.js?");

/***/ }),

/***/ "../../../../node_modules/can-reflect/reflections/type/type.js":
/*!**************************************************************************!*\
  !*** C:/Projects/game/node_modules/can-reflect/reflections/type/type.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../../../node_modules/can-symbol/can-symbol.js\");\nvar helpers = __webpack_require__(/*! ../helpers */ \"../../../../node_modules/can-reflect/reflections/helpers.js\");\n\nvar plainFunctionPrototypePropertyNames = Object.getOwnPropertyNames((function(){}).prototype);\nvar plainFunctionPrototypeProto = Object.getPrototypeOf( (function(){}).prototype );\n/**\n * @function can-reflect.isConstructorLike isConstructorLike\n * @parent can-reflect/type\n *\n * @description Test if a value looks like a constructor function.\n *\n * @signature `isConstructorLike(func)`\n *\n * Return `true` if `func` is a function and has a non-empty prototype, or implements\n *  [can-symbol/symbols/new `@@@@can.new`]; `false` otherwise.\n *\n * ```js\n * canReflect.isConstructorLike(function() {}); // -> false\n *\n * function Construct() {}\n * Construct.prototype = { foo: \"bar\" };\n * canReflect.isConstructorLike(Construct); // -> true\n *\n * canReflect.isConstructorLike({}); // -> false\n * !!canReflect.isConstructorLike({ [canSymbol.for(\"can.new\")]: function() {} }); // -> true\n * ```\n *\n * @param  {*}  func maybe a function\n * @return {Boolean} `true` if a constructor; `false` if otherwise.\n */\nfunction isConstructorLike(func){\n\t/* jshint unused: false */\n\t// if you can new it ... it's a constructor\n\tvar value = func[canSymbol.for(\"can.new\")];\n\tif(value !== undefined) {\n\t\treturn value;\n\t}\n\n\tif(typeof func !== \"function\") {\n\t\treturn false;\n\t}\n\t// If there are any properties on the prototype that don't match\n\t// what is normally there, assume it's a constructor\n\tvar prototype = func.prototype;\n\tif(!prototype) {\n\t\treturn false;\n\t}\n\t// Check if the prototype's proto doesn't point to what it normally would.\n\t// If it does, it means someone is messing with proto chains\n\tif( plainFunctionPrototypeProto !== Object.getPrototypeOf( prototype ) ) {\n\t\treturn true;\n\t}\n\n\tvar propertyNames = Object.getOwnPropertyNames(prototype);\n\tif(propertyNames.length === plainFunctionPrototypePropertyNames.length) {\n\t\tfor(var i = 0, len = propertyNames.length; i < len; i++) {\n\t\t\tif(propertyNames[i] !== plainFunctionPrototypePropertyNames[i]) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}\n\n/**\n * @function can-reflect.isFunctionLike isFunctionLike\n * @parent can-reflect/type\n * @description Test if a value looks like a function.\n * @signature `isFunctionLike(obj)`\n *\n *  Return `true` if `func` is a function, or implements\n *  [can-symbol/symbols/new `@@@@can.new`] or [can-symbol/symbols/apply `@@@@can.apply`]; `false` otherwise.\n *\n * ```js\n * canReflect.isFunctionLike(function() {}); // -> true\n * canReflect.isFunctionLike({}); // -> false\n * canReflect.isFunctionLike({ [canSymbol.for(\"can.apply\")]: function() {} }); // -> true\n * ```\n *\n * @param  {*}  obj maybe a function\n * @return {Boolean}\n */\nvar getNewOrApply = helpers.makeGetFirstSymbolValue([\"can.new\",\"can.apply\"]);\nfunction isFunctionLike(obj){\n\tvar result,\n\t\tsymbolValue = !!obj && obj[canSymbol.for(\"can.isFunctionLike\")];\n\n\tif (symbolValue !== undefined) {\n\t\treturn symbolValue;\n\t}\n\n\tresult = getNewOrApply(obj);\n\tif(result !== undefined) {\n\t\treturn !!result;\n\t}\n\n\treturn typeof obj === \"function\";\n}\n\n/**\n * @function can-reflect.isPrimitive isPrimitive\n * @parent can-reflect/type\n * @description Test if a value is a JavaScript primitive.\n * @signature `isPrimitive(obj)`\n *\n * Return `true` if `obj` is not a function nor an object via `typeof`, or is null; `false` otherwise.\n *\n * ```js\n * canReflect.isPrimitive(null); // -> true\n * canReflect.isPrimitive({}); // -> false\n * canReflect.isPrimitive(undefined); // -> true\n * canReflect.isPrimitive(1); // -> true\n * canReflect.isPrimitive([]); // -> false\n * canReflect.isPrimitive(function() {}); // -> false\n * canReflect.isPrimitive(\"foo\"); // -> true\n *\n * ```\n *\n * @param  {*}  obj maybe a primitive value\n * @return {Boolean}\n */\nfunction isPrimitive(obj){\n\tvar type = typeof obj;\n\tif(obj == null || (type !== \"function\" && type !== \"object\") ) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nvar coreHasOwn = Object.prototype.hasOwnProperty;\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(obj) {\n\t// Must be an Object.\n\t// Because of IE, we also have to check the presence of the constructor property.\n\t// Make sure that DOM nodes and window objects don't pass through, as well\n\tif (!obj || typeof obj !== 'object' ) {\n\t\treturn false;\n\t}\n\tvar proto = Object.getPrototypeOf(obj);\n\tif(proto === Object.prototype || proto === null) {\n\t\treturn true;\n\t}\n\t// partially inspired by lodash: https://github.com/lodash/lodash\n\tvar Constructor = coreHasOwn.call(proto, 'constructor') && proto.constructor;\n\treturn typeof Constructor === 'function' && Constructor instanceof Constructor &&\n    \tfuncToString.call(Constructor) === objectCtorString;\n}\n\n/**\n * @function can-reflect.isBuiltIn isBuiltIn\n * @parent can-reflect/type\n * @description Test if a value is a JavaScript built-in type.\n * @signature `isBuiltIn(obj)`\n *\n * Return `true` if `obj` is some type of JavaScript native built-in; `false` otherwise.\n *\n * ```js\n * canReflect.isBuiltIn(null); // -> true\n * canReflect.isBuiltIn({}); // -> true\n * canReflect.isBuiltIn(1); // -> true\n * canReflect.isBuiltIn([]); // -> true\n * canReflect.isBuiltIn(function() {}); // -> true\n * canReflect.isBuiltIn(\"foo\"); // -> true\n * canReflect.isBuiltIn(new Date()); // -> true\n * canReflect.isBuiltIn(/[foo].[bar]/); // -> true\n * canReflect.isBuiltIn(new DefineMap); // -> false\n *\n * ```\n *\n * Not supported in browsers that have implementations of Map/Set where\n * `toString` is not properly implemented to return `[object Map]`/`[object Set]`.\n *\n * @param  {*}  obj maybe a built-in value\n * @return {Boolean}\n */\nfunction isBuiltIn(obj) {\n\n\t// If primitive, array, or POJO return true. Also check if\n\t// it is not a POJO but is some type like [object Date] or\n\t// [object Regex] and return true.\n\tif (isPrimitive(obj) ||\n\t\tArray.isArray(obj) ||\n\t\tisPlainObject(obj) ||\n\t\t(Object.prototype.toString.call(obj) !== '[object Object]' &&\n\t\t\tObject.prototype.toString.call(obj).indexOf('[object ') !== -1)) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\n/**\n * @function can-reflect.isValueLike isValueLike\n * @parent can-reflect/type\n * @description Test if a value represents a single value (as opposed to several values).\n *\n * @signature `isValueLike(obj)`\n *\n * Return `true` if `obj` is a primitive or implements [can-symbol/symbols/getValue `@@can.getValue`],\n * `false` otherwise.\n *\n * ```js\n * canReflect.isValueLike(null); // -> true\n * canReflect.isValueLike({}); // -> false\n * canReflect.isValueLike(function() {}); // -> false\n * canReflect.isValueLike({ [canSymbol.for(\"can.isValueLike\")]: true}); // -> true\n * canReflect.isValueLike({ [canSymbol.for(\"can.getValue\")]: function() {} }); // -> true\n * canReflect.isValueLike(canCompute()); // -> true\n * canReflect.isValueLike(new DefineMap()); // -> false\n *\n * ```\n *\n * @param  {*}  obj maybe a primitive or an object that yields a value\n * @return {Boolean}\n */\nfunction isValueLike(obj) {\n\tvar symbolValue;\n\tif(isPrimitive(obj)) {\n\t\treturn true;\n\t}\n\tsymbolValue = obj[canSymbol.for(\"can.isValueLike\")];\n\tif( typeof symbolValue !== \"undefined\") {\n\t\treturn symbolValue;\n\t}\n\tvar value = obj[canSymbol.for(\"can.getValue\")];\n\tif(value !== undefined) {\n\t\treturn !!value;\n\t}\n}\n\n/**\n * @function can-reflect.isMapLike isMapLike\n * @parent can-reflect/type\n *\n * @description Test if a value represents multiple values.\n *\n * @signature `isMapLike(obj)`\n *\n * Return `true` if `obj` is _not_ a primitive, does _not_ have a falsy value for\n * [can-symbol/symbols/isMapLike `@@@@can.isMapLike`], or alternately implements\n * [can-symbol/symbols/getKeyValue `@@@@can.getKeyValue`]; `false` otherwise.\n *\n * ```js\n * canReflect.isMapLike(null); // -> false\n * canReflect.isMapLike(1); // -> false\n * canReflect.isMapLike(\"foo\"); // -> false\n * canReflect.isMapLike({}); // -> true\n * canReflect.isMapLike(function() {}); // -> true\n * canReflect.isMapLike([]); // -> false\n * canReflect.isMapLike({ [canSymbol.for(\"can.isMapLike\")]: false }); // -> false\n * canReflect.isMapLike({ [canSymbol.for(\"can.getKeyValue\")]: null }); // -> false\n * canReflect.isMapLike(canCompute()); // -> false\n * canReflect.isMapLike(new DefineMap()); // -> true\n *\n * ```\n *\n * @param  {*}  obj maybe a Map-like\n * @return {Boolean}\n */\nfunction isMapLike(obj) {\n\tif(isPrimitive(obj)) {\n\t\treturn false;\n\t}\n\tvar isMapLike = obj[canSymbol.for(\"can.isMapLike\")];\n\tif(typeof isMapLike !== \"undefined\") {\n\t\treturn !!isMapLike;\n\t}\n\tvar value = obj[canSymbol.for(\"can.getKeyValue\")];\n\tif(value !== undefined) {\n\t\treturn !!value;\n\t}\n\t// everything else in JS is MapLike\n\treturn true;\n}\n\n/**\n * @function can-reflect.isObservableLike isObservableLike\n * @parent can-reflect/type\n * @description Test if a value (or its keys) can be observed for changes.\n *\n * @signature `isObservableLike(obj)`\n *\n * Return  `true` if `obj` is _not_ a primitive and implements any of\n * [can-symbol/symbols/onValue `@@@@can.onValue`], [can-symbol/symbols/onKeyValue `@@@@can.onKeyValue`], or\n * [can-symbol/symbols/onPatches `@@@@can.onKeys`]; `false` otherwise.\n *\n * ```js\n * canReflect.isObservableLike(null); // -> false\n * canReflect.isObservableLike({}); // -> false\n * canReflect.isObservableLike([]); // -> false\n * canReflect.isObservableLike(function() {}); // -> false\n * canReflect.isObservableLike({ [canSymbol.for(\"can.onValue\")]: function() {} }); // -> true\n * canReflect.isObservableLike({ [canSymbol.for(\"can.onKeyValue\")]: function() {} }); // -> true\n * canReflect.isObservableLike(canCompute())); // -> true\n * canReflect.isObservableLike(new DefineMap())); // -> true\n * ```\n *\n * @param  {*}  obj maybe an observable\n * @return {Boolean}\n */\n\n// Specially optimized\nvar onValueSymbol = canSymbol.for(\"can.onValue\"),\n\tonKeyValueSymbol = canSymbol.for(\"can.onKeyValue\"),\n\tonPatchesSymbol = canSymbol.for(\"can.onPatches\");\nfunction isObservableLike( obj ) {\n\tif(isPrimitive(obj)) {\n\t\treturn false;\n\t}\n\treturn Boolean(obj[onValueSymbol] || obj[onKeyValueSymbol] || obj[onPatchesSymbol]);\n}\n\n/**\n * @function can-reflect.isListLike isListLike\n * @parent can-reflect/type\n *\n * @description Test if a value looks like a constructor function.\n *\n * @signature `isListLike(list)`\n *\n * Return `true` if `list` is a `String`, <br>OR `list` is _not_ a primitive and implements `@@@@iterator`,\n * <br>OR `list` is _not_ a primitive and returns `true` for `Array.isArray()`, <br>OR `list` is _not_ a primitive and has a\n * numerical length and is either empty (`length === 0`) or has a last element at index `length - 1`; <br>`false` otherwise\n *\n * ```js\n * canReflect.isListLike(null); // -> false\n * canReflect.isListLike({}); // -> false\n * canReflect.isListLike([]); // -> true\n * canReflect.isListLike(\"foo\"); // -> true\n * canReflect.isListLike(1); // -> false\n * canReflect.isListLike({ [canSymbol.for(\"can.isListLike\")]: true }); // -> true\n * canReflect.isListLike({ [canSymbol.iterator]: function() {} }); // -> true\n * canReflect.isListLike({ length: 0 }); // -> true\n * canReflect.isListLike({ length: 3 }); // -> false\n * canReflect.isListLike({ length: 3, \"2\": true }); // -> true\n * canReflect.isListLike(new DefineMap()); // -> false\n * canReflect.isListLike(new DefineList()); // -> true\n * ```\n *\n * @param  {*}  list maybe a List-like\n * @return {Boolean}\n */\nfunction isListLike( list ) {\n\tvar symbolValue,\n\t\ttype = typeof list;\n\tif(type === \"string\") {\n\t\treturn true;\n\t}\n\tif( isPrimitive(list) ) {\n\t\treturn false;\n\t}\n\tsymbolValue = list[canSymbol.for(\"can.isListLike\")];\n\tif( typeof symbolValue !== \"undefined\") {\n\t\treturn symbolValue;\n\t}\n\tvar value = list[canSymbol.iterator];\n\tif(value !== undefined) {\n\t\treturn !!value;\n\t}\n\tif(Array.isArray(list)) {\n\t\treturn true;\n\t}\n\treturn helpers.hasLength(list);\n}\n\n/**\n * @function can-reflect.isSymbolLike isSymbolLike\n * @parent can-reflect/type\n *\n * @description Test if a value is a symbol or a [can-symbol].\n *\n * @signature `isSymbolLike(symbol)`\n *\n * Return `true` if `symbol` is a native Symbol, or evaluates to a String with a prefix\n * equal to that of CanJS's symbol polyfill; `false` otherwise.\n *\n * ```js\n * /* ES6 *\\/ canReflect.isSymbolLike(Symbol.iterator); // -> true\n * canReflect.isSymbolLike(canSymbol.for(\"foo\")); // -> true\n * canReflect.isSymbolLike(\"@@symbol.can.isSymbol\"); // -> true (due to polyfill for non-ES6)\n * canReflect.isSymbolLike(\"foo\"); // -> false\n * canReflect.isSymbolLike(null); // -> false\n * canReflect.isSymbolLike(1); // -> false\n * canReflect.isSymbolLike({}); // -> false\n * canReflect.isSymbolLike({ toString: function() { return \"@@symbol.can.isSymbol\"; } }); // -> true\n * ```\n *\n * @param  {*}  symbol maybe a symbol\n * @return {Boolean}\n */\n\nvar supportsNativeSymbols = (function() {\n\tvar symbolExists = typeof Symbol !== \"undefined\" && typeof Symbol.for === \"function\";\n\n\tif (!symbolExists) {\n\t\treturn false;\n\t}\n\n\tvar symbol = Symbol(\"a symbol for testing symbols\");\n\treturn typeof symbol === \"symbol\";\n}());\n\nvar isSymbolLike;\nif(supportsNativeSymbols) {\n\tisSymbolLike = function(symbol) {\n\t\treturn typeof symbol === \"symbol\";\n\t};\n} else {\n\tvar symbolStart = \"@@symbol\";\n\tisSymbolLike = function(symbol) {\n\t\tif(typeof symbol === \"object\" && !Array.isArray(symbol)){\n\t\t\treturn symbol.toString().substr(0, symbolStart.length) === symbolStart;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n}\n\nmodule.exports = {\n\tisConstructorLike: isConstructorLike,\n\tisFunctionLike: isFunctionLike,\n\tisListLike: isListLike,\n\tisMapLike: isMapLike,\n\tisObservableLike: isObservableLike,\n\tisPrimitive: isPrimitive,\n\tisBuiltIn: isBuiltIn,\n\tisValueLike: isValueLike,\n\tisSymbolLike: isSymbolLike,\n\t/**\n\t * @function can-reflect.isMoreListLikeThanMapLike isMoreListLikeThanMapLike\n\t * @parent can-reflect/type\n\t *\n\t * @description Test if a value should be treated as a list instead of a map.\n\t *\n\t * @signature `isMoreListLikeThanMapLike(obj)`\n\t *\n\t * Return  `true` if `obj` is an Array, declares itself to be more ListLike with\n\t * `@@@@can.isMoreListLikeThanMapLike`, or self-reports as ListLike but not as MapLike; `false` otherwise.\n\t *\n\t * ```js\n\t * canReflect.isMoreListLikeThanMapLike([]); // -> true\n\t * canReflect.isMoreListLikeThanMapLike(null); // -> false\n\t * canReflect.isMoreListLikeThanMapLike({}); // -> false\n\t * canReflect.isMoreListLikeThanMapLike(new DefineList()); // -> true\n\t * canReflect.isMoreListLikeThanMapLike(new DefineMap()); // -> false\n\t * canReflect.isMoreListLikeThanMapLike(function() {}); // -> false\n\t * ```\n\t *\n\t * @param  {Object}  obj the object to test for ListLike against MapLike traits.\n\t * @return {Boolean}\n\t */\n\tisMoreListLikeThanMapLike: function(obj){\n\t\tif(Array.isArray(obj)) {\n\t\t\treturn true;\n\t\t}\n\t\tif(obj instanceof Array) {\n\t\t\treturn true;\n\t\t}\n\t\tif( obj == null ) {\n\t\t\treturn false;\n\t\t}\n\t\tvar value = obj[canSymbol.for(\"can.isMoreListLikeThanMapLike\")];\n\t\tif(value !== undefined) {\n\t\t\treturn value;\n\t\t}\n\t\tvar isListLike = this.isListLike(obj),\n\t\t\tisMapLike = this.isMapLike(obj);\n\t\tif(isListLike && !isMapLike) {\n\t\t\treturn true;\n\t\t} else if(!isListLike && isMapLike) {\n\t\t\treturn false;\n\t\t}\n\t},\n\t/**\n\t * @function can-reflect.isIteratorLike isIteratorLike\n\t * @parent can-reflect/type\n\t * @description Test if a value looks like an iterator.\n\t * @signature `isIteratorLike(obj)`\n\t *\n\t * Return `true` if `obj` has a key `\"next\"` pointing to a zero-argument function; `false` otherwise\n\t *\n\t * ```js\n\t * canReflect.isIteratorLike([][Symbol.iterator]()); // -> true\n\t * canReflect.isIteratorLike(new DefineList()[canSymbol.iterator]()); // -> true\n\t * canReflect.isIteratorLike(new DefineMap()[canSymbol.iterator]()); // -> true\n\t * canReflect.isIteratorLike(null); // -> false\n\t * canReflect.isIteratorLike({ next: function() {} }); // -> true\n\t * canReflect.isIteratorLike({ next: function(foo) {} }); // -> false (iterator nexts do not take arguments)\n\t * ```\n\t *\n\t * @param  {Object}  obj the object to test for Iterator traits\n\t * @return {Boolean}\n\t */\n\tisIteratorLike: function(obj){\n\t\treturn obj &&\n\t\t\ttypeof obj === \"object\" &&\n\t\t\ttypeof obj.next === \"function\" &&\n\t\t\tobj.next.length === 0;\n\t},\n\t/**\n\t * @function can-reflect.isPromise isPromise\n\t * @parent can-reflect/type\n\t * @description Test if a value is a promise.\n\t *\n\t * @signature `isPromise(obj)`\n\t *\n\t * Return `true` if `obj` is an instance of promise or `.toString` returns `\"[object Promise]\"`.\n\t *\n\t * ```js\n\t * canReflect.isPromise(Promise.resolve()); // -> true\n\t * ```\n\t *\n\t * @param  {*}  obj the object to test for Promise traits.\n\t * @return {Boolean}\n\t */\n\tisPromise: function(obj){\n\t\treturn (obj instanceof Promise || (Object.prototype.toString.call(obj) === '[object Promise]'));\n\t},\n\t/**\n\t * @function can-reflect.isPlainObject isPlainObject\n\t * @parent can-reflect/type\n\t * @description Test if a value is an object created with `{}` or `new Object()`.\n\t *\n\t * @signature `isPlainObject(obj)`\n\t *\n\t * Attempts to determine if an object is a plain object like those you would create using the curly braces syntax: `{}`. The following are not plain objects:\n\t *\n\t * 1. Objects with prototypes (created using the `new` keyword).\n\t * 2. Booleans.\n\t * 3. Numbers.\n\t * 4. NaN.\n\t *\n\t * ```js\n\t * var isPlainObject = require(\"can-reflect\").isPlainObject;\n\t *\n\t * // Created with {}\n\t * console.log(isPlainObject({})); // -> true\n\t *\n\t * // new Object\n\t * console.log(isPlainObject(new Object())); // -> true\n\t *\n\t * // Custom object\n\t * var Ctr = function(){};\n\t * var obj = new Ctr();\n\t *\n\t * console.log(isPlainObject(obj)); // -> false\n\t * ```\n\t *\n\t * @param  {Object}  obj the object to test.\n\t * @return {Boolean}\n\t */\n\tisPlainObject: isPlainObject\n};\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-reflect/reflections/type/type.js?");

/***/ }),

/***/ "../../../../node_modules/can-reflect/types/map.js":
/*!**************************************************************!*\
  !*** C:/Projects/game/node_modules/can-reflect/types/map.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar shape = __webpack_require__(/*! ../reflections/shape/shape */ \"../../../../node_modules/can-reflect/reflections/shape/shape.js\");\nvar CanSymbol = __webpack_require__(/*! can-symbol */ \"../../../../node_modules/can-symbol/can-symbol.js\");\n\nfunction keysPolyfill() {\n  var keys = [];\n  var currentIndex = 0;\n\n  this.forEach(function(val, key) { // jshint ignore:line\n    keys.push(key);\n  });\n\n  return {\n    next: function() {\n      return {\n        value: keys[currentIndex],\n        done: (currentIndex++ === keys.length)\n      };\n    }\n  };\n}\n\nif (typeof Map !== \"undefined\") {\n  shape.assignSymbols(Map.prototype, {\n    \"can.getOwnEnumerableKeys\": Map.prototype.keys,\n    \"can.setKeyValue\": Map.prototype.set,\n    \"can.getKeyValue\": Map.prototype.get,\n    \"can.deleteKeyValue\": Map.prototype[\"delete\"],\n    \"can.hasOwnKey\": Map.prototype.has\n  });\n\n  if (typeof Map.prototype.keys !== \"function\") {\n    Map.prototype.keys = Map.prototype[CanSymbol.for(\"can.getOwnEnumerableKeys\")] = keysPolyfill;\n  }\n}\n\nif (typeof WeakMap !== \"undefined\") {\n  shape.assignSymbols(WeakMap.prototype, {\n    \"can.getOwnEnumerableKeys\": function() {\n      throw new Error(\"can-reflect: WeakMaps do not have enumerable keys.\");\n    },\n    \"can.setKeyValue\": WeakMap.prototype.set,\n    \"can.getKeyValue\": WeakMap.prototype.get,\n    \"can.deleteKeyValue\": WeakMap.prototype[\"delete\"],\n    \"can.hasOwnKey\": WeakMap.prototype.has\n  });\n}\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-reflect/types/map.js?");

/***/ }),

/***/ "../../../../node_modules/can-reflect/types/set.js":
/*!**************************************************************!*\
  !*** C:/Projects/game/node_modules/can-reflect/types/set.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar shape = __webpack_require__(/*! ../reflections/shape/shape */ \"../../../../node_modules/can-reflect/reflections/shape/shape.js\");\nvar CanSymbol = __webpack_require__(/*! can-symbol */ \"../../../../node_modules/can-symbol/can-symbol.js\");\n\nif (typeof Set !== \"undefined\") {\n  shape.assignSymbols(Set.prototype, {\n    \"can.isMoreListLikeThanMapLike\": true,\n    \"can.updateValues\": function(index, removing, adding) {\n      if (removing !== adding) {\n        shape.each(\n          removing,\n          function(value) {\n            this.delete(value);\n          },\n          this\n        );\n      }\n      shape.each(\n        adding,\n        function(value) {\n          this.add(value);\n        },\n        this\n      );\n    },\n    \"can.size\": function() {\n      return this.size;\n    }\n  });\n\n  // IE11 doesn't support Set.prototype[@@iterator]\n  if (typeof Set.prototype[CanSymbol.iterator] !== \"function\") {\n\t  Set.prototype[CanSymbol.iterator] = function() {\n\t\t  var arr = [];\n\t\t  var currentIndex = 0;\n\n\t\t  this.forEach(function(val) {\n\t\t\t  arr.push(val);\n\t\t  });\n\n\t\t  return {\n\t\t\t  next: function() {\n\t\t\t\t  return {\n\t\t\t\t\t  value: arr[currentIndex],\n\t\t\t\t\t  done: (currentIndex++ === arr.length)\n\t\t\t\t  };\n\t\t\t  }\n\t\t  };\n\t  };\n  }\n}\nif (typeof WeakSet !== \"undefined\") {\n  shape.assignSymbols(WeakSet.prototype, {\n    \"can.isListLike\": true,\n    \"can.isMoreListLikeThanMapLike\": true,\n    \"can.updateValues\": function(index, removing, adding) {\n      if (removing !== adding) {\n        shape.each(\n          removing,\n          function(value) {\n            this.delete(value);\n          },\n          this\n        );\n      }\n      shape.each(\n        adding,\n        function(value) {\n          this.add(value);\n        },\n        this\n      );\n    },\n    \"can.size\": function() {\n      throw new Error(\"can-reflect: WeakSets do not have enumerable keys.\");\n    }\n  });\n}\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-reflect/types/set.js?");

/***/ }),

/***/ "../../../../node_modules/can-stache-key/can-stache-key.js":
/*!**********************************************************************!*\
  !*** C:/Projects/game/node_modules/can-stache-key/can-stache-key.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../../../node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../../../node_modules/can-log/dev/dev.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../../../node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../../../node_modules/can-reflect/can-reflect.js\");\nvar canReflectPromise = __webpack_require__(/*! can-reflect-promise */ \"../../../../node_modules/can-reflect-promise/can-reflect-promise.js\");\n\nvar getValueSymbol = canSymbol.for(\"can.getValue\");\nvar setValueSymbol = canSymbol.for(\"can.setValue\");\n\nvar isValueLikeSymbol = canSymbol.for(\"can.isValueLike\");\nvar peek = ObservationRecorder.ignore(canReflect.getKeyValue.bind(canReflect));\nvar observeReader;\nvar isPromiseLike = ObservationRecorder.ignore(function isPromiseLike(value){\n\treturn typeof value === \"object\" && value && typeof value.then === \"function\";\n});\n\nvar bindName = Function.prototype.bind;\n//!steal-remove-start\nif (true) {\n\tbindName = function(source){\n\t\tvar fn = Function.prototype.bind.call(this, source);\n\t\tObject.defineProperty(fn, \"name\", {\n\t\t\tvalue: canReflect.getName(source) + \".\"+canReflect.getName(this)\n\t\t});\n\t\treturn fn;\n\t};\n}\n//!steal-remove-end\n\nvar isAt = function(index, reads) {\n\tvar prevRead = reads[index-1];\n\treturn prevRead && prevRead.at;\n};\n\nvar readValue = function(value, index, reads, options, state, prev){\n\t// if the previous read is AT false ... we shouldn't be doing this;\n\tvar usedValueReader;\n\tdo {\n\n\t\tusedValueReader = false;\n\t\tfor(var i =0, len = observeReader.valueReaders.length; i < len; i++){\n\t\t\tif( observeReader.valueReaders[i].test(value, index, reads, options) ) {\n\t\t\t\tvalue = observeReader.valueReaders[i].read(value, index, reads, options, state, prev);\n\t\t\t\t//usedValueReader = true;\n\t\t\t}\n\t\t}\n\t} while(usedValueReader);\n\n\treturn value;\n};\n\nvar specialRead = {index: true, key: true, event: true, element: true, viewModel: true};\n\nvar checkForObservableAndNotify = function(options, state, getObserves, value, index){\n\tif(options.foundObservable && !state.foundObservable) {\n\t\tif(ObservationRecorder.trapsCount()) {\n\t\t\tObservationRecorder.addMany( getObserves() );\n\t\t\toptions.foundObservable(value, index);\n\t\t\tstate.foundObservable = true;\n\t\t}\n\t}\n};\n\nvar objHasKeyAtIndex = function(obj, reads, index) {\n\treturn !!(\n\t\treads && reads.length &&\n\t\tcanReflect.hasKey(obj, reads[index].key)\n\t);\n};\n\nobserveReader = {\n\t// there are things that you need to evaluate when you get them back as a property read\n\t// for example a compute or a function you might need to call to get the next value to\n\t// actually check\n\t// - readCompute - can be set to `false` to prevent reading an ending compute.  This is used by component to get a\n\t//   compute as a delegate.  In 3.0, this should be removed and force people to write \"{@prop} change\"\n\t// - callMethodsOnObservables - this is an overwrite ... so normal methods won't be called, but observable ones will.\n\t// - executeAnonymousFunctions - call a function if it's found, defaults to true\n\t// - proxyMethods - if the last read is a method, return a function so `this` will be correct.\n\t// - args - arguments to call functions with.\n\t//\n\t// Callbacks\n\t// - earlyExit - called if a value could not be found\n\t// - foundObservable - called when an observable value is found\n\tread: function (parent, reads, options) {\n\t\toptions = options || {};\n\t\tvar state = {\n\t\t\tfoundObservable: false\n\t\t};\n\t\tvar getObserves;\n\t\tif(options.foundObservable) {\n\t\t\tgetObserves = ObservationRecorder.trap();\n\t\t}\n\n\t\t// `cur` is the current value.\n\t\tvar cur = readValue(parent, 0, reads, options, state),\n\t\t\ttype,\n\t\t\t// `prev` is the object we are reading from.\n\t\t\tprev,\n\t\t\t// `foundObs` did we find an observable.\n\t\t\treadLength = reads.length,\n\t\t\ti = 0,\n\t\t\tlast,\n\t\t\tparentHasKey;\n\n\t\tcheckForObservableAndNotify(options, state, getObserves, parent, 0);\n\n\t\twhile( i < readLength ) {\n\t\t\tprev = cur;\n\t\t\t// try to read the property\n\t\t\tfor(var r=0, readersLength = observeReader.propertyReaders.length; r < readersLength; r++) {\n\t\t\t\tvar reader = observeReader.propertyReaders[r];\n\t\t\t\tif(reader.test(cur)) {\n\t\t\t\t\tcur = reader.read(cur, reads[i], i, options, state);\n\t\t\t\t\tbreak; // there can be only one reading of a property\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckForObservableAndNotify(options, state, getObserves, prev, i);\n\t\t\tlast = cur;\n\t\t\ti = i+1;\n\t\t\t// read the value if it is a compute or function\n\t\t\tcur = readValue(cur, i, reads, options, state, prev);\n\n\t\t\tcheckForObservableAndNotify(options, state, getObserves, prev, i-1);\n\n\t\t\ttype = typeof cur;\n\t\t\t// early exit if need be\n\t\t\tif (i < reads.length && (cur === null || cur === undefined )) {\n\t\t\t\tparentHasKey = objHasKeyAtIndex(prev, reads, i - 1);\n\t\t\t\tif (options.earlyExit && !parentHasKey) {\n\t\t\t\t\toptions.earlyExit(prev, i - 1, cur);\n\t\t\t\t}\n\t\t\t\t// return undefined so we know this isn't the right value\n\t\t\t\treturn {\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t\tparent: prev,\n\t\t\t\t\tparentHasKey: parentHasKey,\n\t\t\t\t\tfoundLastParent: false\n\t\t\t\t};\n\t\t\t}\n\n\t\t}\n\n\t\tparentHasKey = objHasKeyAtIndex(prev, reads, reads.length - 1);\n\t\t// if we don't have a value, exit early.\n\t\tif (cur === undefined && !parentHasKey) {\n\t\t\tif (options.earlyExit) {\n\t\t\t\toptions.earlyExit(prev, i - 1);\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tvalue: cur,\n\t\t\tparent: prev,\n\t\t\tparentHasKey: parentHasKey,\n\t\t\tfoundLastParent: true\n\t\t};\n\t},\n\tget: function(parent, reads, options){\n\t\treturn observeReader.read(parent, observeReader.reads(reads), options || {}).value;\n\t},\n\tvalueReadersMap: {},\n\t// an array of types that might have a value inside them like functions\n\t// value readers check the current value\n\t// and get a new value from it\n\t// ideally they would keep calling until\n\t// none of these passed\n\tvalueReaders: [\n\t\t{\n\t\t\tname: \"function\",\n\t\t\t// if this is a function before the last read and its not a constructor function\n\t\t\ttest: function(value){\n\t\t\t\treturn value && canReflect.isFunctionLike(value) && !canReflect.isConstructorLike(value);\n\t\t\t},\n\t\t\tread: function(value, i, reads, options, state, prev){\n\t\t\t\tif(options.callMethodsOnObservables && canReflect.isObservableLike(prev) && canReflect.isMapLike(prev)) {\n\t\t\t\t\tdev.warn(\"can-stache-key: read() called with `callMethodsOnObservables: true`.\");\n\n\t\t\t\t\treturn value.apply(prev, options.args || []);\n\t\t\t\t}\n\n\t\t\t\treturn options.proxyMethods !== false ? bindName.call(value, prev) : value;\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tname: \"isValueLike\",\n\t\t\t// compute value reader\n\t\t\ttest: function(value, i, reads, options) {\n\t\t\t\treturn value && value[getValueSymbol] && value[isValueLikeSymbol] !== false && (options.foundAt || !isAt(i, reads) );\n\t\t\t},\n\t\t\tread: function(value, i, reads, options){\n\t\t\t\tif(options.readCompute === false && i === reads.length ) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\treturn canReflect.getValue(value);\n\t\t\t},\n\t\t\twrite: function(base, newVal){\n\t\t\t\tif(base[setValueSymbol]) {\n\t\t\t\t\tbase[setValueSymbol](newVal);\n\t\t\t\t} else if(base.set) {\n\t\t\t\t\tbase.set(newVal);\n\t\t\t\t} else {\n\t\t\t\t\tbase(newVal);\n\t\t\t\t}\n\t\t\t}\n\t\t}],\n\tpropertyReadersMap: {},\n\t// an array of things that might have a property\n\tpropertyReaders: [\n\t\t{\n\t\t\tname: \"map\",\n\t\t\ttest: function(value){\n\t\t\t\t// the first time we try reading from a promise, set it up for\n\t\t\t\t//  special reflections.\n\t\t\t\tif(canReflect.isPromise(value) ||\n\t\t\t\t\tisPromiseLike(value)) {\n\t\t\t\t\tcanReflectPromise(value);\n\t\t\t\t}\n\n\t\t\t\treturn canReflect.isObservableLike(value) && canReflect.isMapLike(value);\n\t\t\t},\n\t\t\tread: function(value, prop){\n\t\t\t\tvar res = canReflect.getKeyValue(value, prop.key);\n\t\t\t\tif(res !== undefined) {\n\t\t\t\t\treturn res;\n\t\t\t\t} else {\n\t\t\t\t\treturn value[prop.key];\n\t\t\t\t}\n\t\t\t},\n\t\t\twrite: canReflect.setKeyValue\n\t\t},\n\n\t\t// read a normal object\n\t\t{\n\t\t\tname: \"object\",\n\t\t\t// this is the default\n\t\t\ttest: function(){return true;},\n\t\t\tread: function(value, prop, i, options){\n\t\t\t\tif(value == null) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else {\n\t\t\t\t\tif(typeof value === \"object\") {\n\t\t\t\t\t\tif(prop.key in value) {\n\t\t\t\t\t\t\treturn value[prop.key];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// TODO: remove in 5.0.\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (true) {\n\t\t\t\t\t\t\tif( prop.at && specialRead[prop.key] && ( (\"@\"+prop.key) in value)) {\n\t\t\t\t\t\t\t\toptions.foundAt = true;\n\t\t\t\t\t\t\t\tdev.warn(\"Use %\"+prop.key+\" in place of @\"+prop.key+\".\");\n\t\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn value[prop.key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\twrite: function(base, prop, newVal){\n\t\t\t\tvar propValue = base[prop];\n\t\t\t\t// if newVal is observable object, lets try to update\n\t\t\t\tif(newVal != null && typeof newVal === \"object\" && canReflect.isMapLike(propValue) ) {\n\t\t\t\t\tdev.warn(\"can-stache-key: Merging data into \\\"\" + prop + \"\\\" because its parent is non-observable\");\n\t\t\t\t\tcanReflect.update(propValue, newVal);\n\t\t\t\t} else if(propValue != null && propValue[setValueSymbol] !== undefined){\n\t\t\t\t\tcanReflect.setValue(propValue, newVal);\n\t\t\t\t} else {\n\t\t\t\t\tbase[prop] = newVal;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t],\n\treads: function(keyArg) {\n\t\tvar key = \"\"+keyArg;\n\t\tvar keys = [];\n\t\tvar last = 0;\n\t\tvar at = false;\n\t\tif( key.charAt(0) === \"@\" ) {\n\t\t\tlast = 1;\n\t\t\tat = true;\n\t\t}\n\t\tvar keyToAdd = \"\";\n\t\tfor(var i = last; i < key.length; i++) {\n\t\t\tvar character = key.charAt(i);\n\t\t\tif(character === \".\" || character === \"@\") {\n\t\t\t\tif( key.charAt(i -1) !== \"\\\\\" ) {\n\t\t\t\t\tkeys.push({\n\t\t\t\t\t\tkey: keyToAdd,\n\t\t\t\t\t\tat: at\n\t\t\t\t\t});\n\t\t\t\t\tat = character === \"@\";\n\t\t\t\t\tkeyToAdd = \"\";\n\t\t\t\t} else {\n\t\t\t\t\tkeyToAdd = keyToAdd.substr(0,keyToAdd.length - 1) + \".\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkeyToAdd += character;\n\t\t\t}\n\t\t}\n\t\tkeys.push({\n\t\t\tkey: keyToAdd,\n\t\t\tat: at\n\t\t});\n\n\t\treturn keys;\n\t},\n\t// This should be able to set a property similar to how read works.\n\twrite: function(parent, key, value, options) {\n\t\tvar keys = typeof key === \"string\" ? observeReader.reads(key) : key;\n\t\tvar last;\n\n\t\toptions = options || {};\n\t\tif(keys.length > 1) {\n\t\t\tlast = keys.pop();\n\t\t\tparent = observeReader.read(parent, keys, options).value;\n\t\t\tkeys.push(last);\n\t\t} else {\n\t\t\tlast = keys[0];\n\t\t}\n\t\tif(!parent) {\n\t\t\treturn;\n\t\t}\n\t\tvar keyValue = peek(parent, last.key);\n\t\t// here's where we need to figure out the best way to write\n\n\t\t// if property being set points at a compute, set the compute\n\t\tif( observeReader.valueReadersMap.isValueLike.test(keyValue, keys.length - 1, keys, options) ) {\n\t\t\tobserveReader.valueReadersMap.isValueLike.write(keyValue, value, options);\n\t\t} else {\n\t\t\tif(observeReader.valueReadersMap.isValueLike.test(parent, keys.length - 1, keys, options) ) {\n\t\t\t\tparent = parent[getValueSymbol]();\n\t\t\t}\n\t\t\tif(observeReader.propertyReadersMap.map.test(parent)) {\n\t\t\t\tobserveReader.propertyReadersMap.map.write(parent, last.key, value, options);\n\t\t\t}\n\t\t\telse if(observeReader.propertyReadersMap.object.test(parent)) {\n\t\t\t\tobserveReader.propertyReadersMap.object.write(parent, last.key, value, options);\n\t\t\t\tif(options.observation) {\n\t\t\t\t\toptions.observation.update();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nobserveReader.propertyReaders.forEach(function(reader){\n\tobserveReader.propertyReadersMap[reader.name] = reader;\n});\nobserveReader.valueReaders.forEach(function(reader){\n\tobserveReader.valueReadersMap[reader.name] = reader;\n});\nobserveReader.set = observeReader.write;\n\nmodule.exports = observeReader;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-stache-key/can-stache-key.js?");

/***/ }),

/***/ "../../../../node_modules/can-string/can-string.js":
/*!**************************************************************!*\
  !*** C:/Projects/game/node_modules/can-string/can-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// ##string.js\n// _Miscellaneous string utility functions._\n// Several of the methods in this plugin use code adapted from Prototype\n// Prototype JavaScript framework, version 1.6.0.1.\n// © 2005-2007 Sam Stephenson\nvar strUndHash = /_|-/,\n\tstrColons = /\\=\\=/,\n\tstrWords = /([A-Z]+)([A-Z][a-z])/g,\n\tstrLowUp = /([a-z\\d])([A-Z])/g,\n\tstrDash = /([a-z\\d])([A-Z])/g,\n\tstrQuote = /\"/g,\n\tstrSingleQuote = /'/g,\n\tstrHyphenMatch = /-+(.)?/g,\n\tstrCamelMatch = /[a-z][A-Z]/g,\n\tconvertBadValues = function (content) {\n\t\t// Convert bad values into empty strings\n\t\tvar isInvalid = content === null || content === undefined || isNaN(content) && '' + content === 'NaN';\n\t\treturn '' + (isInvalid ? '' : content);\n\t};\n\nvar string = {\n\t/**\n\t * @function can-string.esc esc\n\t * @signature `string.esc(content)`\n\t * @param  {String} content a string\n\t * @return {String}         the string safely HTML-escaped\n\t *\n\t * ```js\n\t * var string = require(\"can-string\");\n\t *\n\t * string.esc(\"<div>&nbsp;</div>\"); //-> \"&lt;div&gt;&amp;nbsp;&lt;/div&gt;\"\n\t * ```\n\t */\n\tesc: function (content) {\n\t\treturn convertBadValues(content)\n\t\t\t.replace(/&/g, '&amp;')\n\t\t\t.replace(/</g, '&lt;')\n\t\t\t.replace(/>/g, '&gt;')\n\t\t\t.replace(strQuote, '&#34;')\n\t\t\t.replace(strSingleQuote, '&#39;');\n\t},\n\t/**\n\t * @function can-string.capitalize capitalize\n\t * @signature `string.capitalize(s)`\n\t * @param  {String} s     the string to capitalize\n\t * @return {String}       the supplied string with the first character uppercased if it is a letter\n\t *\n\t * ```js\n\t * var string = require(\"can-string\");\n\t *\n\t * console.log(string.capitalize(\"foo\")); // -> \"Foo\"\n\t * console.log(string.capitalize(\"123\")); // -> \"123\"\n\t * ```\n\t */\n\tcapitalize: function (s) {\n\t\t// Used to make newId.\n\t\treturn s.charAt(0)\n\t\t\t.toUpperCase() + s.slice(1);\n\t},\n\t/**\n\t * @function can-string.camelize camelize\n\t * @signature `string.camelize(s)`\n\t * @param  {String} str   the string to camelCase\n\t * @return {String}       the supplied string with hyphens removed and following letters capitalized.\n\t *\n\t * ```js\n\t * var string = require(\"can-string\");\n\t *\n\t * console.log(string.camelize(\"foo-bar\")); // -> \"fooBar\"\n\t * console.log(string.camelize(\"-webkit-flex-flow\")); // -> \"WebkitFlexFlow\"\n\t * ```\n\t */\n\tcamelize: function (str) {\n\t\treturn convertBadValues(str)\n\t\t\t.replace(strHyphenMatch, function (match, chr) {\n\t\t\t\treturn chr ? chr.toUpperCase() : '';\n\t\t\t});\n\t},\n\t/**\n\t * @function can-string.hyphenate hyphenate\n\t * @signature `string.hyphenate(s)`\n\t * @param  {String} str   a string in camelCase\n\t * @return {String}       the supplied string with camelCase converted to hyphen-lowercase digraphs\n\t *\n\t * ```js\n\t * var string = require(\"can-string\");\n\t *\n\t * console.log(string.hyphenate(\"fooBar\")); // -> \"foo-bar\"\n\t * console.log(string.hyphenate(\"WebkitFlexFlow\")); // -> \"Webkit-flex-flow\"\n\t * ```\n\t */\n\thyphenate: function (str) {\n\t\treturn convertBadValues(str)\n\t\t\t.replace(strCamelMatch, function (str) {\n\t\t\t\treturn str.charAt(0) + '-' + str.charAt(1)\n\t\t\t\t\t.toLowerCase();\n\t\t\t});\n\t},\n\t/**\n\t * @function can-string.pascalize pascalize\n\t * @signature `string.pascalize(s)`\n\t * @param  {String} str   the string in hyphen case | camelCase\n\t * @return {String}       the supplied string with hyphens | camelCase converted to PascalCase\n\t *\n\t * ```js\n\t * var string = require(\"can-string\");\n\t *\n\t * console.log(string.pascalize(\"fooBar\")); // -> \"FooBar\"\n\t * console.log(string.pascalize(\"baz-bar\")); // -> \"BazBar\"\n\t * ```\n\t */\n\tpascalize: function (str) {\n\t\treturn string.capitalize(string.camelize(str));\n\t},\n\t/**\n\t * @function can-string.underscore underscore\n\t * @signature `string.underscore(s)`\n\t * @param  {String} str   a string in camelCase\n\t * @return {String}       the supplied string with camelCase converted to underscore-lowercase digraphs\n\t *\n\t * ```js\n\t * var string = require(\"can-string\");\n\t *\n\t * console.log(string.underscore(\"fooBar\")); // -> \"foo_bar\"\n\t * console.log(string.underscore(\"HTMLElement\")); // -> \"html_element\"\n\t * ```\n\t */\n\tunderscore: function (s) {\n\t\treturn s.replace(strColons, '/')\n\t\t\t.replace(strWords, '$1_$2')\n\t\t\t.replace(strLowUp, '$1_$2')\n\t\t\t.replace(strDash, '_')\n\t\t\t.toLowerCase();\n\t},\n\t/**\n\t * @property {RegExp} can-string.strUndHash strUndHash\n\t *\n\t * A regex which matches an underscore or hyphen character\n\t */\n\tundHash: strUndHash\n};\nmodule.exports = string;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-string/can-string.js?");

/***/ }),

/***/ "../../../../node_modules/can-symbol/can-symbol.js":
/*!**************************************************************!*\
  !*** C:/Projects/game/node_modules/can-symbol/can-symbol.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../../../node_modules/can-namespace/can-namespace.js\");\n\nvar supportsNativeSymbols = (function() {\n\tvar symbolExists = typeof Symbol !== \"undefined\" && typeof Symbol.for === \"function\";\n\n\tif (!symbolExists) {\n\t\treturn false;\n\t}\n\n\tvar symbol = Symbol(\"a symbol for testing symbols\");\n\treturn typeof symbol === \"symbol\";\n}());\n\nvar CanSymbol;\nif(supportsNativeSymbols) {\n\tCanSymbol = Symbol;\n} else {\n\n\tvar symbolNum = 0;\n\tCanSymbol = function CanSymbolPolyfill(description){\n\t\tvar symbolValue = \"@@symbol\"+(symbolNum++)+(description);\n\n\t\tvar symbol = {}; // make it object type\n\n\t\tObject.defineProperties(symbol, {\n\t\t\ttoString: {\n\t\t\t\tvalue: function(){\n\t\t\t\t\treturn symbolValue;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn symbol;\n\t};\n\n\tvar descriptionToSymbol = {};\n\tvar symbolToDescription = {};\n\n\t/**\n\t * @function can-symbol.for for\n\t * @parent  can-symbol/methods\n\t * @description  Get a symbol based on a known string identifier, or create it if it doesn't exist.\n\t *\n\t * @signature `canSymbol.for(String)`\n\t *\n\t * @param { String } description  The string value of the symbol\n\t * @return { CanSymbol } The globally unique and consistent symbol with the given string value.\n\t */\n\tCanSymbol.for = function(description){\n\t\tvar symbol = descriptionToSymbol[description];\n\t\tif(!symbol) {\n\t\t\tsymbol = descriptionToSymbol[description] = CanSymbol(description);\n\t\t\tsymbolToDescription[symbol] = description;\n\t\t}\n\t\treturn symbol;\n\t};\n\t/**\n\t * @function can-symbol.keyFor keyFor\n\t * @parent  can-symbol\n\t * @description  Get the description for a symbol.\n\t *\n\t * @signature `canSymbol.keyFor(CanSymbol)`\n\t *\n\t * @param { String } description  The string value of the symbol\n\t * @return { CanSymbol } The globally unique and consistent symbol with the given string value.\n\t */\n\tCanSymbol.keyFor = function(symbol) {\n\t\treturn symbolToDescription[symbol];\n\t};\n\t[\"hasInstance\",\"isConcatSpreadable\",\n\t\t\"iterator\",\"match\",\"prototype\",\"replace\",\"search\",\"species\",\"split\",\n\t\"toPrimitive\",\"toStringTag\",\"unscopables\"].forEach(function(name){\n\t\tCanSymbol[name] = CanSymbol(\"Symbol.\"+name);\n\t});\n}\n\n// Generate can. symbols.\n[\n\t// ======= Type detection ==========\n\t\"isMapLike\",\n\t\"isListLike\",\n\t\"isValueLike\",\n\t\"isFunctionLike\",\n\t// ======= Shape detection =========\n\t\"getOwnKeys\",\n\t\"getOwnKeyDescriptor\",\n\t\"proto\",\n\t// optional\n\t\"getOwnEnumerableKeys\",\n\t\"hasOwnKey\",\n\t\"hasKey\",\n\t\"size\",\n\t\"getName\",\n\t\"getIdentity\",\n\n\t// shape manipulation\n\t\"assignDeep\",\n\t\"updateDeep\",\n\n\t// ======= GET / SET\n\t\"getValue\",\n\t\"setValue\",\n\t\"getKeyValue\",\n\t\"setKeyValue\",\n\t\"updateValues\",\n\t\"addValue\",\n\t\"removeValues\",\n\t// ======= Call =========\n\t\"apply\",\n\t\"new\",\n\t// ======= Observe =========\n\t\"onValue\",\n\t\"offValue\",\n\t\"onKeyValue\",\n\t\"offKeyValue\",\n\t\"getKeyDependencies\",\n\t\"getValueDependencies\",\n\t\"keyHasDependencies\",\n\t\"valueHasDependencies\",\n\t\"onKeys\",\n\t\"onKeysAdded\",\n\t\"onKeysRemoved\",\n\t\"onPatches\"\n\t].forEach(function(name){\n\tCanSymbol.for(\"can.\"+name);\n});\n\nmodule.exports = namespace.Symbol = CanSymbol;\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/can-symbol/can-symbol.js?");

/***/ }),

/***/ "../../../../node_modules/process/browser.js":
/*!********************************************************!*\
  !*** C:/Projects/game/node_modules/process/browser.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///C:/Projects/game/node_modules/process/browser.js?");

/***/ }),

/***/ "../../../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "../game-engine/Time.js":
/*!******************************!*\
  !*** ../game-engine/Time.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar Time = function Time() {};\n\nTime.deltaTime = 0;\nTime.lastAnimationFrameTime = 0;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Time);\n\n//# sourceURL=webpack:///../game-engine/Time.js?");

/***/ }),

/***/ "../game-engine/game.js":
/*!******************************!*\
  !*** ../game-engine/game.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game_objects_block__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game-objects/block */ \"../game-objects/block.js\");\n/* harmony import */ var _game_objects_fps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../game-objects/fps */ \"../game-objects/fps.js\");\n/* harmony import */ var _game_engine_Time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../game-engine/Time */ \"../game-engine/Time.js\");\n/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./input */ \"../game-engine/input.js\");\n\n\n\n\n\nvar Game = /*#__PURE__*/function () {\n  function Game(canvasContext) {\n    this.classes = {};\n    this.idx = 0;\n    this.gameObjects = {};\n    this.collidingObjects = {};\n    this.context = null;\n    this.context = canvasContext;\n    this.classes = {\n      Block: _game_objects_block__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n      Fps: _game_objects_fps__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n    };\n    _input__WEBPACK_IMPORTED_MODULE_3__[\"default\"].initInputs();\n  }\n\n  var _proto = Game.prototype;\n\n  _proto.start = function start(time) {\n    if (time === void 0) {\n      time = 0;\n    }\n\n    this.context.clear();\n    _input__WEBPACK_IMPORTED_MODULE_3__[\"default\"].updateInputs();\n\n    for (var objectId in this.gameObjects) {\n      this.gameObjects[objectId].render();\n      this.gameObjects[objectId].update();\n    }\n\n    _game_engine_Time__WEBPACK_IMPORTED_MODULE_2__[\"default\"].deltaTime = time - _game_engine_Time__WEBPACK_IMPORTED_MODULE_2__[\"default\"].lastAnimationFrameTime;\n    _game_engine_Time__WEBPACK_IMPORTED_MODULE_2__[\"default\"].lastAnimationFrameTime = time;\n    requestAnimationFrame(this.start.bind(this));\n  };\n\n  _proto.createObject = function createObject(objectName, params) {\n    var object = this.classes[objectName];\n    if (!object) return false;\n    var objectInstance = new object(params);\n    objectInstance.id = ++this.idx;\n    objectInstance.context = this.context;\n    objectInstance.game = this;\n\n    if (objectInstance.isColliding()) {\n      this.addToColliding(objectInstance);\n    }\n\n    this.gameObjects[objectInstance.getId()] = objectInstance;\n    objectInstance.onStart();\n    return objectInstance;\n  };\n\n  _proto.addToColliding = function addToColliding(object) {\n    this.collidingObjects[object.getId()] = object;\n  };\n\n  _proto.removeFromColliding = function removeFromColliding(objectId) {\n    delete this.collidingObjects[objectId];\n  };\n\n  _proto.destroyObject = function destroyObject(objectId) {\n    var object = this.gameObjects[objectId];\n    if (!object) return;\n    object.beforeDestroy();\n  };\n\n  return Game;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Game);\n\n//# sourceURL=webpack:///../game-engine/game.js?");

/***/ }),

/***/ "../game-engine/input.js":
/*!*******************************!*\
  !*** ../game-engine/input.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _helper_keyboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helper/keyboard */ \"../helper/keyboard.js\");\n/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper */ \"../helper/index.js\");\n/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vector */ \"../game-engine/vector.js\");\n\n\n\n\nvar Input = /*#__PURE__*/function () {\n  function Input() {}\n\n  Input.initInputs = function initInputs() {\n    var _this = this;\n\n    window.addEventListener(\"keydown\", function (ev) {\n      _this.PRESSED_BUTTONS[ev.code] = true;\n    });\n    window.addEventListener(\"keyup\", function (ev) {\n      _this.PRESSED_BUTTONS[ev.code] = false;\n    });\n    window.addEventListener(\"mousemove\", function (ev) {\n      _this.MOUSE_POSITION.updatePosition(ev.offsetX, ev.offsetY);\n    });\n    window.addEventListener(\"mousedown\", function (ev) {\n      _this.PRESSED_BUTTONS[_helper_keyboard__WEBPACK_IMPORTED_MODULE_0__[\"Keyboard\"].MOUSE_CLICK] = true;\n    });\n    window.addEventListener(\"mouseup\", function (ev) {\n      _this.PRESSED_BUTTONS[_helper_keyboard__WEBPACK_IMPORTED_MODULE_0__[\"Keyboard\"].MOUSE_CLICK] = false;\n    });\n  };\n\n  Input.updateInputs = function updateInputs() {\n    for (var keyCode in this.PRESSED_BUTTONS) {\n      if (!this.PRESSED_BUTTONS.hasOwnProperty(keyCode)) continue;\n      var value = this.PRESSED_BUTTONS[keyCode];\n\n      switch (keyCode) {\n        case _helper_keyboard__WEBPACK_IMPORTED_MODULE_0__[\"Keyboard\"].A:\n          this.HORIZONTAL = Object(_helper__WEBPACK_IMPORTED_MODULE_1__[\"lerp\"])(this.HORIZONTAL, value ? -1 : 0);\n          break;\n\n        case _helper_keyboard__WEBPACK_IMPORTED_MODULE_0__[\"Keyboard\"].D:\n          this.HORIZONTAL = Object(_helper__WEBPACK_IMPORTED_MODULE_1__[\"lerp\"])(this.HORIZONTAL, value ? 1 : 0);\n          break;\n\n        case _helper_keyboard__WEBPACK_IMPORTED_MODULE_0__[\"Keyboard\"].W:\n          this.VERTICAL = Object(_helper__WEBPACK_IMPORTED_MODULE_1__[\"lerp\"])(this.VERTICAL, value ? -1 : 0);\n          break;\n\n        case _helper_keyboard__WEBPACK_IMPORTED_MODULE_0__[\"Keyboard\"].S:\n          this.VERTICAL = Object(_helper__WEBPACK_IMPORTED_MODULE_1__[\"lerp\"])(this.VERTICAL, value ? 1 : 0);\n          break;\n\n        case _helper_keyboard__WEBPACK_IMPORTED_MODULE_0__[\"Keyboard\"].MOUSE_CLICK:\n          this.MOUSE_CLICK = value ? 1 : 0;\n          break;\n      }\n    }\n  };\n\n  return Input;\n}();\n\nInput.VERTICAL = 0;\nInput.HORIZONTAL = 0;\nInput.MOUSE_CLICK = 0;\nInput.MOUSE_POSITION = new _vector__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0);\nInput.PRESSED_BUTTONS = {};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Input);\n\n//# sourceURL=webpack:///../game-engine/input.js?");

/***/ }),

/***/ "../game-engine/vector.js":
/*!********************************!*\
  !*** ../game-engine/vector.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar Vector = /*#__PURE__*/function () {\n  function Vector(x, y) {\n    this.x = 0;\n    this.y = 0;\n    this.updatePosition(x, y);\n  }\n\n  var _proto = Vector.prototype;\n\n  _proto.updatePosition = function updatePosition(x, y) {\n    if (!x) x = 0;\n    if (!y) y = 0;\n    this.x = x;\n    this.y = y;\n  };\n\n  _proto.setPositionByVector = function setPositionByVector(newVector) {\n    this.x = newVector.x;\n    this.y = newVector.y;\n  };\n\n  return Vector;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Vector);\n\n//# sourceURL=webpack:///../game-engine/vector.js?");

/***/ }),

/***/ "../game-objects/block.js":
/*!********************************!*\
  !*** ../game-objects/block.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game-object */ \"../game-objects/game-object.js\");\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n\n\nvar Block = /*#__PURE__*/function (_GameObject) {\n  _inheritsLoose(Block, _GameObject);\n\n  function Block() {\n    return _GameObject.apply(this, arguments) || this;\n  }\n\n  var _proto = Block.prototype;\n\n  _proto.render = function render() {\n    var _this$params$fillColo;\n\n    this.context.fillColor = (_this$params$fillColo = this.params.fillColor) != null ? _this$params$fillColo : \"black\";\n    this.context.fillRect(this.position.x, this.position.y, this.params.width, this.params.height);\n  };\n\n  return Block;\n}(_game_object__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Block);\n\n//# sourceURL=webpack:///../game-objects/block.js?");

/***/ }),

/***/ "../game-objects/fps.js":
/*!******************************!*\
  !*** ../game-objects/fps.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game-object */ \"../game-objects/game-object.js\");\n/* harmony import */ var _game_engine_Time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../game-engine/Time */ \"../game-engine/Time.js\");\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n\n\n\nvar Fps = /*#__PURE__*/function (_GameObject) {\n  _inheritsLoose(Fps, _GameObject);\n\n  function Fps() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _GameObject.call.apply(_GameObject, [this].concat(args)) || this;\n    _this.delay = 500;\n    _this.currentDelay = 0;\n    _this.fps = 0;\n    return _this;\n  }\n\n  var _proto = Fps.prototype;\n\n  _proto.render = function render() {\n    if (_game_engine_Time__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deltaTime === 0) return;\n    this.currentDelay += _game_engine_Time__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deltaTime;\n\n    if (this.currentDelay > this.delay || this.fps === 0) {\n      this.fps = Math.round(1000 / _game_engine_Time__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deltaTime);\n      this.currentDelay = 0;\n    }\n\n    this.context.font = \"30px Arial\";\n    this.context.fillText(\"FPS \" + this.fps, this.position.x, this.position.y);\n  };\n\n  return Fps;\n}(_game_object__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Fps);\n\n//# sourceURL=webpack:///../game-objects/fps.js?");

/***/ }),

/***/ "../game-objects/game-object.js":
/*!**************************************!*\
  !*** ../game-objects/game-object.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game_engine_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game-engine/vector */ \"../game-engine/vector.js\");\n/* harmony import */ var _game_engine_Time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../game-engine/Time */ \"../game-engine/Time.js\");\n\n\n\nvar GameObject = /*#__PURE__*/function () {\n  function GameObject(params) {\n    this.canColliding = false;\n    this.params = {};\n    this.id = 0;\n    this.context = null;\n    this.position = null;\n    this.game = null;\n    this.updateCallback = null;\n    this.params = params;\n    this.position = new _game_engine_vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](params.x, params.y);\n\n    if (params.updateCallback && typeof params.updateCallback === \"function\") {\n      this.setUpdateCallback(params.updateCallback);\n    }\n  }\n\n  var _proto = GameObject.prototype;\n\n  _proto.isColliding = function isColliding() {\n    return this.canColliding;\n  };\n\n  _proto.toggleColliding = function toggleColliding(state) {\n    state = !!state;\n\n    if (state) {\n      this.game.addToColliding(this);\n    } else {\n      this.game.removeFromColliding(this.getId());\n    }\n  };\n\n  _proto.getId = function getId() {\n    return this.id;\n  };\n\n  _proto.onStart = function onStart() {};\n\n  _proto.update = function update() {\n    if (typeof this.updateCallback !== \"function\") return;\n    this.updateCallback();\n  };\n\n  _proto.setUpdateCallback = function setUpdateCallback(callback) {\n    this.updateCallback = callback;\n  };\n\n  _proto.render = function render() {};\n\n  _proto.getPosition = function getPosition() {\n    return this.position;\n  };\n\n  _proto.beforeDestroy = function beforeDestroy() {};\n\n  return GameObject;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GameObject);\n\n//# sourceURL=webpack:///../game-objects/game-object.js?");

/***/ }),

/***/ "../helper/index.js":
/*!**************************!*\
  !*** ../helper/index.js ***!
  \**************************/
/*! exports provided: lerp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\nvar lerp = function lerp(value1, value2, amount) {\n  if (amount === void 0) {\n    amount = 0.1;\n  }\n\n  amount = amount < 0 ? 0 : amount;\n  amount = amount > 1 ? 1 : amount;\n  return value1 + (value2 - value1) * amount;\n};\n\n//# sourceURL=webpack:///../helper/index.js?");

/***/ }),

/***/ "../helper/keyboard.js":
/*!*****************************!*\
  !*** ../helper/keyboard.js ***!
  \*****************************/
/*! exports provided: Keyboard */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Keyboard\", function() { return Keyboard; });\nvar Keyboard = {\n  W: \"KeyW\",\n  S: \"KeyS\",\n  A: \"KeyA\",\n  D: \"KeyD\",\n  MOUSE_CLICK: \"mouseClick\",\n  MOUSE_POSITION: \"mousePosition\"\n};\n\n//# sourceURL=webpack:///../helper/keyboard.js?");

/***/ }),

/***/ "../prototypes/canvas-context.js":
/*!***************************************!*\
  !*** ../prototypes/canvas-context.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("CanvasRenderingContext2D.prototype.clear = CanvasRenderingContext2D.prototype.clear || function (preserveTransform) {\n  if (preserveTransform) {\n    this.save();\n    this.setTransform(1, 0, 0, 1, 0, 0);\n  }\n\n  this.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n  if (preserveTransform) {\n    this.restore();\n  }\n};\n\n//# sourceURL=webpack:///../prototypes/canvas-context.js?");

/***/ }),

/***/ "../prototypes/index.js":
/*!******************************!*\
  !*** ../prototypes/index.js ***!
  \******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _canvas_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./canvas-context */ \"../prototypes/canvas-context.js\");\n/* harmony import */ var _canvas_context__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_canvas_context__WEBPACK_IMPORTED_MODULE_0__);\n\n\n//# sourceURL=webpack:///../prototypes/index.js?");

/***/ }),

/***/ "./base.js":
/*!*****************!*\
  !*** ./base.js ***!
  \*****************/
/*! exports provided: BasePage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasePage\", function() { return BasePage; });\n/* harmony import */ var can_control__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-control */ \"../../../../node_modules/can-control/can-control.js\");\n/* harmony import */ var can_control__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_control__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var can_construct_super__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! can-construct-super */ \"../../../../node_modules/can-construct-super/can-construct-super.js\");\n/* harmony import */ var can_construct_super__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(can_construct_super__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _prototypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../prototypes */ \"../prototypes/index.js\");\n\n\n\nvar BasePage = can_control__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n  defaults: {}\n}, {\n  init: function init() {}\n});\n\n\n//# sourceURL=webpack:///./base.js?");

/***/ }),

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"./base.js\");\n/* harmony import */ var _game_engine_game__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../game-engine/game */ \"../game-engine/game.js\");\n/* harmony import */ var _game_engine_input__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../game-engine/input */ \"../game-engine/input.js\");\n/* harmony import */ var _game_engine_Time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../game-engine/Time */ \"../game-engine/Time.js\");\n\n\n\n\nvar MainPage = _base__WEBPACK_IMPORTED_MODULE_0__[\"BasePage\"].extend({\n  defaults: {\n    canvas: \"canvas\"\n  }\n}, {\n  init: function init() {\n    var _this = this;\n\n    this._super();\n\n    this.canvas = this.element.querySelector(this.options.canvas);\n    this.resize();\n    this.game = new _game_engine_game__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.canvas.getContext(\"2d\"));\n    this.blockObject = this.game.createObject(\"Block\", {\n      x: 300,\n      y: 250,\n      width: 10,\n      height: 10\n    });\n    this.blockObject2 = this.game.createObject(\"Block\", {\n      x: 300,\n      y: 250,\n      width: 25,\n      height: 25\n    });\n    this.blockObject3 = this.game.createObject(\"Block\", {\n      x: 300,\n      y: 250,\n      width: 25,\n      height: 25\n    });\n    this.game.createObject(\"Fps\", {\n      x: 0,\n      y: 30\n    });\n    this.game.start();\n    this.speed = 0.2;\n    this.blockObject.setUpdateCallback(function () {\n      _this.blockObject.position.setPositionByVector(_game_engine_input__WEBPACK_IMPORTED_MODULE_2__[\"default\"].MOUSE_POSITION);\n\n      _this.blockObject.position.y += _this.speed * _game_engine_input__WEBPACK_IMPORTED_MODULE_2__[\"default\"].MOUSE_CLICK * _game_engine_Time__WEBPACK_IMPORTED_MODULE_3__[\"default\"].deltaTime;\n    });\n    this.blockObject2.setUpdateCallback(function () {\n      _this.blockObject2.position.x += _this.speed * _game_engine_input__WEBPACK_IMPORTED_MODULE_2__[\"default\"].HORIZONTAL * _game_engine_Time__WEBPACK_IMPORTED_MODULE_3__[\"default\"].deltaTime;\n      _this.blockObject2.position.y += _this.speed * _game_engine_input__WEBPACK_IMPORTED_MODULE_2__[\"default\"].VERTICAL * _game_engine_Time__WEBPACK_IMPORTED_MODULE_3__[\"default\"].deltaTime;\n    });\n    this.blockObject3.setUpdateCallback(function () {\n      _this.blockObject3.position.x -= _this.speed * _game_engine_input__WEBPACK_IMPORTED_MODULE_2__[\"default\"].HORIZONTAL * _game_engine_Time__WEBPACK_IMPORTED_MODULE_3__[\"default\"].deltaTime;\n      _this.blockObject3.position.y -= _this.speed * _game_engine_input__WEBPACK_IMPORTED_MODULE_2__[\"default\"].VERTICAL * _game_engine_Time__WEBPACK_IMPORTED_MODULE_3__[\"default\"].deltaTime;\n    });\n  },\n  \"{window} resize\": function windowResize() {\n    this.resize();\n  },\n  // \"{window} keyup\"(el, ev) {\n  //     switch (ev.which) {\n  //         case Keyboard.W:\n  //             this.blockObject.position.y -= 1;\n  //             break;\n  //         case Keyboard.S:\n  //             this.blockObject.position.y += 1;\n  //             break;\n  //         case Keyboard.A:\n  //             this.blockObject.position.x -= 1;\n  //             break;\n  //         case Keyboard.D:\n  //             this.blockObject.position.x += 1;\n  //             break;\n  //     }\n  // },\n  resize: function resize() {\n    var bound = document.body.getBoundingClientRect();\n    this.canvas.width = bound.width;\n    this.canvas.height = bound.height;\n  }\n});\nnew MainPage(document.querySelector(\"body\"));\n\n//# sourceURL=webpack:///./main.js?");

/***/ })

/******/ });